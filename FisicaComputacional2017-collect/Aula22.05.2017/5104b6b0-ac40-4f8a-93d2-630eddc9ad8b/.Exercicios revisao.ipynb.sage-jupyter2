{"type":"settings","kernel":"anaconda3","backend_state":"ready","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}},"kernel_state":"idle"}
{"type":"file","last_load":1495499942474}
{"start":1495499945807,"input":"##Exercício 3\n##De os valores para a, b e c respectivamente\na = int(input(\"Digite um valor para A: \"))\nb = int(input(\"Digite um valor para B: \"))\nc = int(input(\"Digite um valor para C: \"))\n\n#Calculando o delta\n\ndelta = b*b - 4 * a * c\n\n\nif delta < 0:\n    print(\"A equacão possui raízes imaginárias\")\nelif delta == 0:\n    raiz = (-1*b + math.sqrt(delta))/(2 * a)\n    print(\"A equacao possui apenas uma raiz \",raiz)\nelif delta > 0:\n    raiz1 =(-1*b + math.sqrt(delta))/(2 * a)\n    raiz2 =(-1*b - math.sqrt(delta))/(2 * a)\n    print(\"As raizes da equacao sao \",raiz1, \"e\",raiz2)","state":"done","pos":1,"type":"cell","end":1495499945807,"id":"61367b","kernel":"python2"}
{"output":{"0":{"ename":"SyntaxError","evalue":"invalid syntax (<ipython-input-2-f89e5167e866>, line 3)","traceback":["\u001b[0;36m  File \u001b[0;32m\"<ipython-input-2-f89e5167e866>\"\u001b[0;36m, line \u001b[0;32m3\u001b[0m\n\u001b[0;31m    for i in r for j in r # iterate over range in 2d\u001b[0m\n\u001b[0m                 ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"]}},"exec_count":2,"start":1495499945812,"input":"##Exercício jogo da vida\n\nfor i in r for j in r # iterate over range in 2d\n            if not i == j == 0) # exclude the center cell\n\n\ndef advance(board):\n    \"\"\"Advance the board one step and return it.\"\"\"\n    new_board = set()\n    for cell in board:\n        cell_neighbors = set(neighbors(cell))\n        # test if live cell dies\n        if len(board & cell_neighbors) in [2, 3]:\n            new_board.add(cell)\n\n return new_board\n\n\ndef print_board(board, size=None):\n    sizex = sizey = size or 0\n    for x, y in board:\n        sizex = x if x > sizex else sizex\n        sizey = y if y > sizey else sizey\n    for i in xrange(sizex + 1):\n        for j in xrange(sizey + 1):\n            sys.stdout.write(' x ' if (i, j) in board else ' . ')\n        print\n\n\ndef constrain(board, size):\n    return set(cell for cell in board if cell[0] <= size and cell[1] <= size)\n\n\ndef main(board, steps=75, size=20):\n    for i in xrange(1, steps + 1):\n        sys.stdout.write('\\033[H')  # move to the top\n        sys.stdout.write('\\033[J')  # clear the screen\n        print 'step:', i, '/', steps\n        print_board(board, size)\n        time.sleep(0.1)\n        board = constrain(advance(board), size)\n\n\nif __name__ == '__main__':\n    main(GLIDER)","state":"done","pos":3,"type":"cell","end":1495499945825,"id":"16770b","kernel":"python2"}
{"type":"cell","id":"0151f1","pos":2,"input":"##Exercício jogo da vida\n\nfor i in r for j in r # iterate over range in 2d\n            if not i == j == 0) # exclude the center cell\n\n\ndef advance(board):\n    \"\"\"Advance the board one step and return it.\"\"\"\n    new_board = set()\n    for cell in board:\n        cell_neighbors = set(neighbors(cell))\n        # test if live cell dies\n        if len(board & cell_neighbors) in [2, 3]:\n            new_board.add(cell)\n\n return new_board\n\n\ndef print_board(board, size=None):\n    sizex = sizey = size or 0\n    for x, y in board:\n        sizex = x if x > sizex else sizex\n        sizey = y if y > sizey else sizey\n    for i in xrange(sizex + 1):\n        for j in xrange(sizey + 1):\n            sys.stdout.write(' x ' if (i, j) in board else ' . ')\n        print\n\n\ndef constrain(board, size):\n    return set(cell for cell in board if cell[0] <= size and cell[1] <= size)\n\n\ndef main(board, steps=75, size=20):\n    for i in xrange(1, steps + 1):\n        sys.stdout.write('\\033[H')  # move to the top\n        sys.stdout.write('\\033[J')  # clear the screen\n        print 'step:', i, '/', steps\n        print_board(board, size)\n        time.sleep(0.1)\n        board = constrain(advance(board), size)\n\n\nif __name__ == '__main__':\n    main(GLIDER)","cell_type":"code","exec_count":0}
{"type":"cell","id":"8ea34a","pos":0,"input":"##Exercício 3\n##De os valores para a, b e c respectivamente\na = int(input(\"Digite um valor para A: \"))\nb = int(input(\"Digite um valor para B: \"))\nc = int(input(\"Digite um valor para C: \"))\n\n#Calculando o delta\n\ndelta = b*b - 4 * a * c\n\n\nif delta < 0:\n    print(\"A equacão possui raízes imaginárias\")\nelif delta == 0:\n    raiz = (-1*b + math.sqrt(delta))/(2 * a)\n    print(\"A equacao possui apenas uma raiz \",raiz)\nelif delta > 0:\n    raiz1 =(-1*b + math.sqrt(delta))/(2 * a)\n    raiz2 =(-1*b - math.sqrt(delta))/(2 * a)\n    print(\"As raizes da equacao sao \",raiz1, \"e\",raiz2)","cell_type":"code","exec_count":0}