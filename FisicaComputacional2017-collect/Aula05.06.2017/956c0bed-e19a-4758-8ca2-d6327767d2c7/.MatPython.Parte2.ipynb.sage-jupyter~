{"kernelspec":{"display_name":"Python 3 (Anaconda)","language":"python","name":"anaconda3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.3"}}
{"cell_type":"markdown","metadata":{},"source":"# Visualização de dados em Python com Matplotlib (Parte 2)"}
{"cell_type":"markdown","metadata":{},"source":"#### - Utilizando os dados do DataFrame da aula anterior:"}
{"cell_type":"code","execution_count":23,"metadata":{"trusted":false},"outputs":[],"source":"def read_auto_data(fileName = \"Automobile price data.csv\"):\n    'Function to load the auto price data set from a .csv file' \n    import pandas as pd\n    import numpy as np\n\n    ## Read the .csv file with the pandas read_csv method\n    auto_prices = pd.read_csv(fileName)\n    \n    ## Remove rows with missing values, accounting for mising values coded as '?'\n    cols = ['price', 'bore', 'stroke', \n          'horsepower', 'peak-rpm']\n    for column in cols:\n        auto_prices.loc[auto_prices[column] == '?', column] = np.nan\n    auto_prices.dropna(axis = 0, inplace = True)\n\n    ## Convert some columns to numeric values\n    for column in cols:\n        auto_prices[column] = pd.to_numeric(auto_prices[column])\n#    auto_prices[cols] = auto_prices[cols].as_type(int64)\n        \n    return auto_prices\nauto_prices = read_auto_data()"}
{"cell_type":"code","execution_count":24,"metadata":{"trusted":false},"outputs":[{"data":{"text/html":"smc-blob::54de8f4e-ddca-413a-9030-38b0cadf6d27"},"execution_count":24,"metadata":{},"output_type":"execute_result"}],"source":"auto_prices.head()"}
{"cell_type":"code","execution_count":3,"metadata":{"trusted":false},"outputs":[{"data":{"text/html":"smc-blob::29ed2335-1ffb-41f7-96e9-87b6d1d4b0c7"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"auto_prices.describe()"}
{"cell_type":"markdown","metadata":{},"source":"** d) Histogramas**\n- Os histogramas são usados para variáveis numéricas. Considerando que, um gráfico de barras mostra as contagens de categorias exclusivas, um histograma mostra o número de dados com valores dentro de uma caixa. As caixas dividem os valores da variável em segmentos iguais. \n- O eixo vertical do histograma mostra a contagem de valores de dados dentro de cada caixa.\n- O código abaixo segue nossa mesma receita básica para criar um histograma de tamanho do motor. Observe, no entanto, que a coluna do quadro de dados que desejamos plotar é especificada pelo nome como ***auto_prices ['engine-size']***."}
{"cell_type":"code","execution_count":25,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5ab4ede208>"},"execution_count":25,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::2dc1e8cf-cdb9-4095-85ea-ecbc6b5b2fe7"},"execution_count":25,"metadata":{},"output_type":"execute_result"}],"source":"import matplotlib.pyplot as plt\nfig = plt.figure(figsize=(10,10)) # define plot area\nax = fig.gca() # define axis    \nauto_prices['engine-size'].plot.hist(ax = ax) # Use the plot.hist method on subset of the data frame\nax.set_title('Histogram of auto engine size') # Give the plot a main title\nax.set_xlabel('Engine size') # Set text for the x axis\nax.set_ylabel('Number of autos')# Set text for y axis"}
{"cell_type":"markdown","metadata":{},"source":"**e) Box-Plot**\n- Os box-plots foram introduzidos por John Tukey em 1970. Estes gráficos são outra maneira de visualizar a distribuição de valores de dados. A este respeito, os gráficos de caixa são comparáveis aos histogramas, mas são bastante diferentes na apresentação.\n\n- Em um gráfico de caixa, o valor médio é mostrado com uma barra escura. Os dois qartiles internos dos valores de dados estão contidos na \"caixa\". Os \"wiskers\" incluem a maioria dos dados. Os outliers são mostrados por símbolos através dos wiskers.\n\n- Vários parcelas de caixa podem ser empilhadas ao longo de um eixo. Os dados são divididos usando uma operação 'por grupo', e os gráficos de caixa para cada grupo são empilhados um ao lado do outro. Desta forma, o gráfico de caixa permite exibir duas dimensões do seu conjunto de dados.\n\n- O código na célula abaixo geralmente segue a receita que estamos usando. O quadro de dados está subconectado a duas colunas. Uma coluna contém os valores numéricos para plotar e a outra coluna é o grupo por variável. Nesse caso, o grupo por variável é especificado com o argumento by = 'fuel-type'."}
{"cell_type":"code","execution_count":26,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5ab4e5fe80>"},"execution_count":26,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::59e46bb7-fa2a-4375-bc4a-8874093b6895"},"execution_count":26,"metadata":{},"output_type":"execute_result"}],"source":"fig = plt.figure(figsize=(10,10)) # define plot area\nax = fig.gca() # define axis    \nauto_prices[['engine-size','fuel-type']].boxplot(by = 'fuel-type', ax = ax) # Use the plot.bar method on the new data frame\nax.set_title('Box plots of auto engine size by fule type') # Give the plot a main title\nax.set_xlabel('Fuel type') # Set text for the x axis\nax.set_ylabel('Engine size')# Set text for y axis"}
{"cell_type":"markdown","metadata":{},"source":"- Examine o gráfico acima e observe as diferenças na distribuição do tamanho do motor por tipo de combustível. Existe uma sobreposição considerável na faixa inter-quartil (o intervalo dentro das caixas), com carros a gás com motores geralmente mais pequenos. O tamanho médio do motor (a barra vermelha) para carros a gás é visivelmente menor do que para carros a diesel. No entanto, a gama de tamanhos de motores para carros a gás é maior, incluindo alguns outliers. É provável, estes são os valores anormais que vimos no histograma."}
{"cell_type":"markdown","metadata":{},"source":"** 3. Parcelas de densidade de kernel e introdução a Seaborn**\n- Até agora, trabalhamos exclusivamente com os métodos de traçado em pandas. Agora vamos começar a trabalhar com o pacote Seaborn. Seaborn é um pacote Python mais recente que abstrai gráficos de matplotlib de nível inferior. Seaborn também inclui alguns tipos adicionais de gráficos de ponta."}
{"cell_type":"markdown","metadata":{},"source":"\n- As parcelas de densidade de Kernel são semelhantes em conceito a um histograma. Um gráfico de densidade de kernel exibe os valores de uma curva de densidade suavizada dos valores de dados. Em outras palavras, o gráfico de densidade do núcleo é uma versão suavizada de um histograma.\n\n- O código na célula abaixo cria um gráfico de violino usando a seguinte receita:\n\n1. Importe o pacote Seaborn,\n2. Defina um estilo para a grade do gráfico.\n3. Defina o kdeplot da coluna do tamanho do motor.\n\n**Nota:**Dependendo da sua plataforma e versões do Numpy, você pode ver um aviso de decomposição. Você pode ignorar este aviso com segurança."}
{"cell_type":"code","execution_count":6,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f5ab7680cf8>"},"execution_count":6,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::e45e9adf-2e05-44d7-bdb4-f645f3ededff"},"execution_count":6,"metadata":{},"output_type":"execute_result"}],"source":"import seaborn as sns\nsns.set_style(\"whitegrid\")\nsns.kdeplot(auto_prices['engine-size'])"}
{"cell_type":"markdown","metadata":{},"source":"- Os resultados do plot do KDE são semelhantes aos que observamos com o histograma do tamanho do motor. O tamanho do motor é inclinado em direção ao tamanho pequeno, e existem outliers de alguns carros com grandes motores claramente visíveis.\n\n- Como fizemos com os dataframes pandas, controlamos as propriedades de um terreno de Seaborn, especificando os eixos. O código na célula abaixo amplia nossa receita simples para lotes de Seaborn:\n\n1. Defina uma figura.\n2. Defina um ou mais eixos na figura.\n3. Defina um estilo para a grade do gráfico.\n4. Defina o kdeplot da coluna do tamanho do motor.\n5. Use métodos nos eixos para controlar atributos como títulos e rótulos de eixos."}
{"cell_type":"code","execution_count":7,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5ab9e1aac8>"},"execution_count":7,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::9ae4f3c7-71d8-4eb2-8e69-a846a3890fb7"},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":"fig = plt.figure(figsize=(10,10)) # define plot area\nax = fig.gca() # define axis \nsns.set_style(\"whitegrid\")\nsns.kdeplot(auto_prices['engine-size'], ax = ax)\nax.set_title('KDE plot of auto engine size') # Give the plot a main title\nax.set_xlabel('Engine Size') # Set text for the x axis\nax.set_ylabel('Density')# Set text for y axis"}
{"cell_type":"markdown","metadata":{},"source":"- Também podemos criar um gráfico bidimensional do KDE. O código na célula abaixo cria um gráfico de preço e tamanho do motor bidimensional segundo a mesma receita."}
{"cell_type":"code","execution_count":8,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5abb8002e8>"},"execution_count":8,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::b68c10f6-4bca-4605-b1bd-f2939c1ad7f3"},"execution_count":8,"metadata":{},"output_type":"execute_result"}],"source":"fig = plt.figure(figsize=(10,10)) # define plot area\nax = fig.gca() # define axis \nsns.set_style(\"whitegrid\")\nsns.kdeplot(auto_prices[['engine-size', 'price']], ax = ax, cmap=\"Blues_d\")\nax.set_title('KDE plot of auto engine size and price') # Give the plot a main title\nax.set_xlabel('Engine Size') # Set text for the x axis\nax.set_ylabel('Price')# Set text for y axis"}
{"cell_type":"markdown","metadata":{},"source":"- Podemos ver claramente que existe um único modo forte para o preço do automóvel e o tamanho do motor. Existe uma inclinação de ambas as variáveis para carros de menor custo com motores menores."}
{"cell_type":"markdown","metadata":{},"source":"**3. 1- Violin plot**\n- O código na célula abaixo segue a receita que estabelecemos para plotar Seaborn. O método ***sns.violinplot*** possui mais argumentos do que o método kdeplot.\n\n1. As colunas utilizadas para o enredo são definidas com os argumentos x e y.\n2. A coluna x é o grupo por variável.\n3. O argumento de dados especifica um quadro de dados de pandas ou uma matriz numpy."}
{"cell_type":"code","execution_count":9,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5ab76a3470>"},"execution_count":9,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::57d4e232-d749-4189-9445-9ec76f891c1c"},"execution_count":9,"metadata":{},"output_type":"execute_result"}],"source":"fig = plt.figure(figsize=(10,10)) # define plot area\nax = fig.gca() # define axis \nsns.set_style(\"whitegrid\")\nsns.violinplot(x = 'fuel-type', y = 'engine-size', data = auto_prices, ax = ax)\nax.set_title('Violine plots of auto engine size by fule type') # Give the plot a main title\nax.set_xlabel('Fuel type') # Set text for the x axis\nax.set_ylabel('Engine size')# Set text for y axis"}
{"cell_type":"markdown","metadata":{},"source":"- As diferenças na distribuição dos tamanhos de motores entre carros a gás e diesel são claramente visíveis no plot violino. Podemos confirmar que o tamanho do motor dos carros a gás está inclinado para o tamanho pequeno. Existem alguns carros a gás com tamanhos de motores muito pequenos e uma série de automóveis que aparecem como outliers com motores grandes. A distribuição de tamanhos de motores diesel é mais uniforme."}
{"cell_type":"markdown","metadata":{},"source":"** 4. Exibindo várias dimensões com estética**\n\n- Nós já exploramos alguns tipos básicos de plot. Todas as parcelas que criamos até agora são projetadas em uma superfície bidimensional. Assim, ficamos limitados à visualização de apenas duas dimensões do nosso conjunto de dados.\n\n- Agora, usaremos a estética do gráfico para visualizar dimensões adicionais do conjunto de dados. Estéticas específicas são usadas para projetar dimensões adicionais em uma superfície de trama bidimensional. Além disso, a escolha cuidadosa da estética do plot pode destacar certos aspectos de um conjunto de dados que você está explorando.\n\n- Há uma possível estética possível para a visualização. Exemplos específicos com os quais trabalharemos incluem:\n\n1. Cor\n2. Transparência\n3. Tamanho\n4. Forma do marcador\n5. Estética específica para o tipo de lote\n\n- O uso de estética com um pouco de inteligência pode levar a informações interessantes sobre um conjunto de dados. "}
{"cell_type":"markdown","metadata":{},"source":"**4.1- Cor**\n- A cor pode ser usada para ver uma dimensão adicional em um gráfico de dispersão. Um fator categórico pode ser mostrado usando cores diferentes para as diferentes categorias.\n- Cuidado! Certifique-se de usar uma paleta com cores distintivas para cada cateogria. Muitas categorias usando cores similares são invariavelmente difíceis de ver e impossíveis de interpretar.\n- O código na célula abaixo usa o argumento de matiz para adicionar uma terceira dimensão, tipo de combustível para um gráfico de dispersão. Uma paleta de cores também é especificada."}
{"cell_type":"code","execution_count":27,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<seaborn.axisgrid.FacetGrid at 0x7f5ab4f18400>"},"execution_count":27,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::5de36135-59bb-4455-be56-8f6c2d3ad7ce"},"execution_count":27,"metadata":{},"output_type":"execute_result"}],"source":"sns.lmplot(x = 'city-mpg', y = 'price', data = auto_prices, hue = \"fuel-type\", palette=\"Set2\", fit_reg = False)"}
{"cell_type":"markdown","metadata":{},"source":"- No gráfico acima, podemos ver que um carro diesel é geralmente mais caro em uma determinada eficiência de combustível. Também podemos ver que todos os carros menos eficientes e mais caros possuem motores a gás.\n- Se estamos dispostos a criar mais códigos, podemos ganhar muito mais controle sobre a estética do plano. O código na função mostrada abaixo divide os dados em subconjuntos e os traça com diferentes estéticas no mesmo conjunto de eixos. A receita é:\n\n1. Importe os pacotes necessários\n2. Loop sobre uma lista de nomes de colunas para o eixo horizontal. Neste exemplo, nós apenas especificamos um.\n4. Defina uma figura e eixos para o enredo\n5. Divida os dados por carros a gás e diesel.\n6. Se o subconjunto tiver mais de zero membros, crie gráficos de dispersão com a estética definida. Nesse caso, o atributo é cor definida como DarkBlue ou Red.\n7. Crie uma lista de patches e exiba os patches para o ledgend."}
{"cell_type":"code","execution_count":11,"metadata":{"trusted":false},"outputs":[{"name":"stderr","output_type":"stream","text":"/projects/anaconda3/lib/python3.5/site-packages/ipykernel/__main__.py:7: DeprecationWarning: \n.ix is deprecated. Please use\n.loc for label based indexing or\n.iloc for positional indexing\n\nSee the documentation here:\nhttp://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate_ix\n"},{"data":{"text/plain":"'Done'"},"execution_count":11,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::47ff09cf-86e4-4e2e-b511-c9303823feeb"},"execution_count":11,"metadata":{},"output_type":"execute_result"}],"source":"def auto_color(df, plot_cols):\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    for col in plot_cols:\n        fig = plt.figure(figsize=(10, 10))\n        ax = fig.gca()\n        temp1 = df.ix[df['fuel-type'] == 'gas']       \n        temp2 = df.ix[df['fuel-type'] == 'diesel']\n        if temp1.shape[0] > 0:                    \n            temp1.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'DarkBlue')                          \n        if temp2.shape[0] > 0:                    \n            temp2.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'Red') \n    ax.set_title('Scatter plot of price vs. ' + col)\n    red_patch = mpatches.Patch(color='Red', label='Diesel')   \n    blue_patch = mpatches.Patch(color='DarkBlue', label='Gas')\n    plt.legend(handles=[red_patch, blue_patch])\n    return 'Done'\nauto_color(auto_prices, ['city-mpg'])"}
{"cell_type":"markdown","metadata":{},"source":"**4.2 - Transparência**\n- No gráfico de dispersão acima, observe que há áreas na trama com densos agrupamentos de pontos. Em particular, existem pontos sobrepostos para carros a gás com mpg da cidade entre 19 e 31 (o mpg é aparentemente relatado em unidades inteiras).\n- Por causa do efeito de \"excesso de traçado\" é difícil ver exatamente quantos carros estão representados em algumas regiões da trama. Transparência, é uma estética útil para superar o excesso de traçado. A transparência é definida em uma escala de 0 (completamente transparente ou invisível) para 1 (perfeitamente opaco). Ao escolher valores de transparência razoáveis, você pode ter uma idéia de quantos pontos são agrupados em uma pequena área de um enredo.\n- O código na célula abaixo segue a receita acima mencionada. Um argumento de transparência, alfa, foi adicionado."}
{"cell_type":"code","execution_count":12,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"['city-mpg']"},"execution_count":12,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::18c71c5c-ae3c-4593-bd7f-bec123060ef7"},"execution_count":12,"metadata":{},"output_type":"execute_result"}],"source":"def auto_color(df, plot_cols):\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    for col in plot_cols:\n        fig = plt.figure(figsize=(10, 10))\n        ax = fig.gca()\n        temp1 = df.ix[df['fuel-type'] == 'gas']       \n        temp2 = df.ix[df['fuel-type'] == 'diesel']\n        if temp1.shape[0] > 0:                    \n            temp1.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'DarkBlue', alpha = 0.3)                          \n        if temp2.shape[0] > 0:                    \n            temp2.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'Red', alpha = 0.3) \n        ax.set_title('Scatter plot of price vs. ' + col)\n        red_patch = mpatches.Patch(color='Red', label='Diesel')   \n        blue_patch = mpatches.Patch(color='DarkBlue', label='Gas')\n        plt.legend(handles=[red_patch, blue_patch])\n    return plot_cols\nauto_color(auto_prices, ['city-mpg'])"}
{"cell_type":"markdown","metadata":{},"source":"**4.3 -Usando o tamanho do marcador**\n- Outra estética que pode projetar uma dimensão adicional em um gráfico bidimensional é o tamanho do marcador. O código na célula abaixo usa o tamanho escalonado do marcador para indicar o tamanho do motor."}
{"cell_type":"code","execution_count":13,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"['city-mpg']"},"execution_count":13,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::2da4102a-ba57-4712-b895-772d692c7a3f"},"execution_count":13,"metadata":{},"output_type":"execute_result"}],"source":"def auto_size(df, plot_cols):\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    for col in plot_cols:\n        fig = plt.figure(figsize=(10, 10))\n        ax = fig.gca()\n        temp1 = df.ix[df['fuel-type'] == 'gas']       \n        temp2 = df.ix[df['fuel-type'] == 'diesel']\n        if temp1.shape[0] > 0:                    \n            temp1.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'DarkBlue', s= .5 * auto_prices['engine-size'], alpha = 0.3)                          \n        if temp2.shape[0] > 0:                    \n            temp2.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'Red', s= .5 * auto_prices['engine-size'], alpha = 0.3) \n    ax.set_title('Scatter plot of price vs. ' + col + ' with engine size')\n    red_patch = mpatches.Patch(color='Red', label='Diesel')   \n    blue_patch = mpatches.Patch(color='DarkBlue', label='Gas')\n    plt.legend(handles=[red_patch, blue_patch])\n    return plot_cols\nauto_size(auto_prices, ['city-mpg'])"}
{"cell_type":"markdown","metadata":{},"source":"- Examine o gráfico acima observando os diferentes tamanhos de marcador. Com marcadores maiores, a configuração da transparência é mais necessária do que nunca.\n- Você pode notar que a diferença no tamanho do motor nem sempre é aparente no gráfico acima. Usar o tamanho do marcador pode ser um pouco complicado. Outra opção é usar o quadrado do valor que está sendo projetado para determinar o tamanho do marcador. A área do marcador é então proporcional ao valor de interesse, em vez do tamanho do marcador menos perceptível.\n- O código na célula abaixo usa o quadrado do tamanho do motor para determinar o tamanho do marcador."}
{"cell_type":"code","execution_count":14,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"'Done'"},"execution_count":14,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::18d51626-6362-475a-b453-87a45981058c"},"execution_count":14,"metadata":{},"output_type":"execute_result"}],"source":"def auto_size_2(df, plot_cols):\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    for col in plot_cols:\n        fig = plt.figure(figsize=(10, 10))\n        ax = fig.gca()\n        temp1 = df.ix[df['fuel-type'] == 'gas']       \n        temp2 = df.ix[df['fuel-type'] == 'diesel']\n        if temp1.shape[0] > 0:                    \n            temp1.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'DarkBlue', s= .02 * auto_prices['engine-size'] * auto_prices['engine-size'], \n                       alpha = 0.3)                          \n        if temp2.shape[0] > 0:                    \n            temp2.plot(kind = 'scatter', x = col, y = 'price' , \n                           ax = ax, color = 'Red', s= .02 * auto_prices['engine-size']  * auto_prices['engine-size'], \n                       alpha = 0.3) \n    ax.set_title('Scatter plot of price vs. ' + col + ' with engine size')\n    red_patch = mpatches.Patch(color='Red', label='Diesel')   \n    blue_patch = mpatches.Patch(color='DarkBlue', label='Gas')\n    plt.legend(handles=[red_patch, blue_patch])\n    return 'Done'\nauto_size_2(auto_prices, ['city-mpg']) "}
{"cell_type":"markdown","metadata":{},"source":"**4.4 - Usando formas de marcador**\n- A forma do marcador pode ser usada para projetar uma dimensão adicional em uma superfície de traçado bidimensional. Tipicamente, diferentes formas de marcador são usadas para indicar as categorias de uma variável categórica. Como com outras estética, não faça isso. Muitos marcadores semelhantes em um gráfico apenas ofuscarão as relações que você está tentando mostrar.\n- O código na célula abaixo usa diferentes formas de marcador para indicar carros de aspiração padrão e turbo."}
{"cell_type":"code","execution_count":29,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"'Done'"},"execution_count":29,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::7e19a2b7-21b2-4ff2-9e43-2407b18c0fba"},"execution_count":29,"metadata":{},"output_type":"execute_result"}],"source":"def auto_shape(df):\n    import matplotlib.pyplot as plt\n    import matplotlib.lines as mlines\n    aspiration = ['turbo', 'turbo', 'std', 'std']\n    fuel = ['diesel', 'gas', 'diesel', 'gas']\n    mrks = ['o', 'o', '+', '+']\n    cols = ['Red', 'DarkBlue', 'Red', 'DarkBlue']\n    ldg = []\n    fig = plt.figure(figsize=(10, 10))\n    ax = fig.gca()\n    for asp, fl, mk, cl in zip(aspiration, fuel, mrks, cols):\n        temp = df.loc[(df['aspiration'] == asp) & (df['fuel-type'] == fl)]       \n        if temp.shape[0] > 0:                    \n            temp.plot(kind = 'scatter', x = 'city-mpg', y = 'price' , ax = ax, color = cl, marker = mk,\n                       s= .02 * df['engine-size'] * df['engine-size'], alpha = 0.5)    \n        ldg.append(mlines.Line2D([], [], color=cl, marker=mk, markersize=10, \n                                 label=(asp + ' and ' + fl)))    \n    ax.set_title('Scatter plot of price vs. city mpg with marker size = engine size')\n    plt.legend(handles=ldg)\n    return'Done'\nauto_shape(auto_prices)"}
{"cell_type":"markdown","metadata":{},"source":"- O plano acima planeja cinco dimensões na superfície do enredo bidimensional: preço, mpg da cidade, tamanho do motor, tipo de aspiração e tipo de combustível. Demora algum tempo e esforço para entender completamente todas as informações fornecidas.\n- Algumas conclusões que podemos extrair do gráfico acima incluem:\n- Os carros mais caros possuem aspirações maiores, padrão, motores a gás.\nA maioria dos carros diesel usa aspiração de tubo e estes tendem a ser mais caros.\nOs carros do motor a gás de aspiração turbo estão na baixa gama de eficiência de combustível, mas no meio da faixa de preço.\nAlguns carros de baixo custo possuem grandes motores a gás."}
{"cell_type":"markdown","metadata":{},"source":"** 4.5 - Estética específica: caixas de histograma**\n- Nós usamos alguma estética bastante geral para produzir relacionamentos em nosso conjunto de dados. Vamos agora ver uma estética adicional que tende a ser mais específica do tipo de gráfico.\n- Como primeiro exemplo, examinaremos o efeito de mudar o número de caixas em um histograma. O código abaixo agrupa o histograma do tamanho do motor usando diferentes números de caixas; O padrão de 10 caixas e 40 caixas. Esta é também a primeira vez que colocamos vários conjuntos de eixos na mesma figura. A primeira linha de código define dois subplots em uma linha na figura."}
{"cell_type":"code","execution_count":30,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.text.Text at 0x7f5ab4bfef60>"},"execution_count":30,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::534dceda-b638-46f4-8839-abb4feb51be9"},"execution_count":30,"metadata":{},"output_type":"execute_result"}],"source":"fig, ax = plt.subplots(1, 2, figsize = (16, 6))\nauto_prices['engine-size'].plot.hist(ax = ax[0]) \nax[0].set_title('Histogram of auto engine size with 10 bins') # Give the plot a main title\nax[0].set_xlabel('Engine size') # Set text for the x axis\nax[0].set_ylabel('Number of autos')# Set text for y axis\nauto_prices['engine-size'].plot.hist(ax = ax[1], bins = 40) \nax[1].set_title('Histogram of auto engine size with 40 bins') \nax[1].set_xlabel('Engine size') \nax[1].set_ylabel('Number of autos')"}
{"cell_type":"markdown","metadata":{},"source":"- Observe que o histograma com 10 compartimentos dá um resultado mais suave, o que pode ser melhor para obter uma impressão geral da distribuição. O histograma com 40 compartimentos mostra mais detalhes, particularmente para os outliers."}
{"cell_type":"markdown","metadata":{},"source":"**4.6- Estética específica - Parcelas de violin plot**\n- No código mostrado abaixo, o argumento tonalidade é usado para mostrar os KDEs de carros de aspiração padrão e turbo, agrupados pela variável do eixo x do tipo de combustível. O gráfico resultante mostra três dimensões: preço, tipo de combustível e aspiração."}
{"cell_type":"code","execution_count":31,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f5ab4b0a390>"},"execution_count":31,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::208c9c1d-612b-44d6-8bd9-23325452467d"},"execution_count":31,"metadata":{},"output_type":"execute_result"}],"source":"import seaborn as sns\nsns.set_style(\"whitegrid\")\nsns.violinplot(data = auto_prices, x = 'fuel-type', y = 'price', hue=\"aspiration\",  split=True)"}
{"cell_type":"markdown","metadata":{},"source":"- Da parcela acima, podemos ver que os carros de motores de aspiração padrão têm a mais ampla gama de preços. \n- Também podemos ver que os carros a diesel tendem a ser mais caros. Finalmente, os carros de motores a gasolina e a diesel com aspiração padrão apresentam preços distorcidos para o lado inferior."}
{"cell_type":"markdown","metadata":{},"source":"**4.7 - Estética específica: Parcelas de caixa**\n- Usando Seaborn podemos adicionar dados de grupo para gráficos de caixa por tonalidade, como acabamos de fazer com parcelas de violino. \n- O código abaixo usa a tonalidade para agrupar os carros por estilo corporal. Como antes, o eixo x agrupa os automóveis pelo tipo de combustível."}
{"cell_type":"code","execution_count":32,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f5ab4bd5828>"},"execution_count":32,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::ec615f29-337f-4c46-b220-d534534e3532"},"execution_count":32,"metadata":{},"output_type":"execute_result"}],"source":"sns.set_style(\"whitegrid\")\nsns.boxplot(data = auto_prices, x = 'fuel-type', y = 'price', hue=\"body-style\")"}
{"cell_type":"markdown","metadata":{},"source":"- Examine o plot, observando vários relacionamentos interessantes, incluindo:\n- Os hardtops de gás têm a mais ampla gama de preços, seguidos de conversíveis a gás.\n- Existem poucos estilos disponíveis para carros diesel.\n- Os hatchback a gás são geralmente os carros de menor custo, seguem os sedans de gás e diesel.\n- Existem dois carros diesel com tipos de corpo únicos. Uma trama diferente ou um subconjunto simples dos dados é necessário para identificar estes tipos de corpo."}
{"cell_type":"markdown","metadata":{},"source":"** 5. Parcelas de múltiplos plots e facetas**\n- Nós exploramos os tipos básicos de lote e usamos a estética para projetar múltiplas dimensões em tipos de enredo básicos. Agora vamos investigar o uso de múltiplos eixos de tramas e de uma técnica conhecida como facetada. Faceting envolve o uso de valores de variáveis categóricas ou numéricas para criar uma grade sistemática de plots relacionados. As facetas são feitas por vários outros elementos, incluindo plotagem condicionada ou traçado de rede.\n- Vamos agora explorar vários aspectos destes:\n\n1. Paramentos com densidade marginal\n2. Parcelas de dispersão em par\n3. Parcelas de múltiplos eixos\n4. Parcelas facetadas"}
{"cell_type":"markdown","metadata":{},"source":"**5.1- Parcelas com densidade  nas margens**\n- Um tipo de gráfico de multi-eixo simples é um gráfico de dispersão com a densidade marginal de cada dimensão mostrada ao longo do eixo horizontal ou vertical.\n- O código na célula abaixo usa o método de junção conjunta de Seaborn para criar apenas um enredo. As colunas a serem plotadas nos eixos x e y, juntamente com o nome de uma moldura de dados pandas ou numpy, são especificadas como argumentos. O argumento de transparência alfa é especificado para lidar com ***overplotting***.\n- O gráfico abaixo mostra a relação entre preço e tamanho do motor. A distribuição marginal do preço é mostrada ao longo do eixo y e a distribuição marginal do tamanho do motor é mostrada ao longo do eixo x."}
{"cell_type":"code","execution_count":19,"metadata":{"trusted":false},"outputs":[{"data":{"text/plain":"<seaborn.axisgrid.JointGrid at 0x7f5abb7f6d30>"},"execution_count":19,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::51343304-071c-4a1d-aa12-ede6080dfce4"},"execution_count":19,"metadata":{},"output_type":"execute_result"}],"source":"sns.set_style(\"whitegrid\")\nsns.jointplot('engine-size', 'price', data = auto_prices, alpha = 0.3)"}
{"cell_type":"markdown","metadata":{},"source":"#### Exercício 1\n###### Até agora, na nossa exploração dos dados automotivos com gráficos de dispersão, focamos a relação entre preço e mpg da cidade. Neste exercício, você criará gráficos para algumas colunas adicionais:\n\n- Mude pelo menos uma das opções de cores.\n- Ligue para a função auto_color com uma lista de colunas diferentes: ***['engine-size', 'curb-weight']***.\n- Examine os plots resultantes. O que você pode aprender com essas plots?"}
{"cell_type":"markdown","metadata":{},"source":"#### Exercício 2\n###### Você já viu vários exemplos de usar a estética do gráfico para destacar vários relacionamentos no conjunto de dados. Você pode continuar a explorar o conjunto de dados usando a estética. Experimente o seguinte:\n\n- Copie o código usado para o plano de violino em uma nova célula.\n- Altere o grupo x por variável para \"wheel-base\".\n- Examine o plot resultante. Qual a nova informação agora aparente?"}
{"cell_type":"markdown","metadata":{},"source":"#### Exercício 3\n###### Agora é sua vez de tentar alguns plots com densidades nas margens. Faça o seguinte:\n\n- Altere a variável do eixo x para 'city-mpg'.\n- Examine o plot resultante. Qual a nova informação agora aparente?"}
{"cell_type":"code","execution_count":0,"metadata":{"trusted":false},"outputs":[],"source":""}