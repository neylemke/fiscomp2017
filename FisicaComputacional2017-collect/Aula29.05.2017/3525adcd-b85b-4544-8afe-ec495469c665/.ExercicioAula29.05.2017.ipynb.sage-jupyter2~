{"type":"settings","kernel":"python2","backend_state":"running","trust":true,"kernel_state":"idle"}
{"type":"file","last_load":1496079594135}
{"output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7f0ea832da90>]"},"exec_count":44},"1":{"data":{"image/png":"98b01cb6f66cb50971743f807332ef9cb64d2baa"}}},"exec_count":44,"start":1496082915728,"input":"#A “classificação” de uma palavra é a sua posição em uma lista de palavras classificadas por frequência: a palavra mais comum tem a classificação 1, a segunda mais comum é 2 etc.\n#A lei de Zipf descreve a relação entre classificações e frequências das palavras em linguagens naturais (http://en.wikipedia.org/wiki/Zipf’s_law). Ela prevê especificamente que a frequência, , da palavra com classificação  é:\n\n#onde s e c são parâmetros que# dependem do idioma e do texto. Se você tomar o logaritmo de ambos os lados desta equação, obtemos:\n\n#Se você traçar o log de f contra o log de r, terá uma linha reta com uma elevação -s e interceptar o log de c.\n\n#- Escreva um programa que leia um texto em um arquivo, conte as frequências das palavras e exiba uma linha para cada palavra, em ordem descendente da frequência, com log de f e log de r. Use o programa gráfico de sua escolha para traçar os resultados e verifique se formam uma linha reta. Você pode estimar o valor de s?\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\narq = open(\"frankstein.txt\", \"r\")\ndict ={}\nfor i in arq.readlines():\n    for word in i.split():\n        if word in dict:\n            dict[word] = dict[word]+1\n        else:\n            dict[word]=1\noc = dict.values()\noc.sort()\noc.reverse()\nX = np.array(range(len(oc)))+1\nY = np.array(oc)\nlogx = np.log(X)\nlogy = np.log(Y)\nfig = plt.figure(figsize=(10,10))\nax = fig.gca()\nx = plt.gca()\nax.set_title(\"Frequencia de palavras do Frankstein\")\nax.set_xlabel(\"rank\")\nax.set_ylabel(\"freq\")\nplt.plot(logx, logy)\n","scrolled":true,"state":"done","pos":0,"type":"cell","end":1496082916012,"id":"2fb334","kernel":"python2"}
{"output":{"0":{"data":{"text/plain":"<matplotlib.text.Text at 0x7f79e016b2d0>"},"exec_count":1},"1":{"data":{"image/png":"f6e06ac08248f2214fe8d7bf78b91f0e7e2f801b"}}},"exec_count":1,"start":1496358111331,"input":"#Exercício 2\n#Agora que você já viu como criar alguns plots simples, é sua vez de realizar uma visualização. Crie o seguinte gráfico de dispersão:\n\n#Traçar o tamanho do motor contra o preço.\n#Defina o tamanho da figura como 8 x 8.\n#Forneça um título significativo, rótulo do eixo x e rótulo do eixo y.\n\ndef read_auto_data(fileName = \"Automobile price data.csv\"):\n    'Function to load the auto price data set from a .csv file' \n    import pandas as pd\n    import numpy as np\n\n    ## Read the .csv file with the pandas read_csv method\n    auto_prices = pd.read_csv(fileName)\n    \n    ## Remove rows with missing values, accounting for mising values coded as '?'\n    cols = ['price', 'bore', 'stroke', \n          'horsepower', 'peak-rpm']\n    for column in cols:\n        auto_prices.loc[auto_prices[column] == '?', column] = np.nan\n    auto_prices.dropna(axis = 0, inplace = True)\n\n    ## Convert some columns to numeric values\n    for column in cols:\n        auto_prices[column] = pd.to_numeric(auto_prices[column])\n#    auto_prices[cols] = auto_prices[cols].as_type(int64)\n        \n    return auto_prices\nauto_prices = read_auto_data()\n\nimport matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=(8,8))\nax = fig.gca()\nauto_prices.plot(kind = \"hexbin\", x=\"engine-size\", y = \"price\", ax=ax)\nax.set_title(\"Scatter\")\nax.set_xlabel(\"Price\")\nax.set_ylabel(\"Engine-Size\")","scrolled":true,"state":"done","pos":1,"type":"cell","end":1496358112876,"id":"c0ff63","kernel":"python2"}
{"type":"cell","id":"9e0477","pos":2,"input":""}