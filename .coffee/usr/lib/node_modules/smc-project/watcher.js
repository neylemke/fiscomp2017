
/*
Watch a file for changes

Watch for changes to the given file.  Returns obj, which
is an event emitter with events:

   - 'change' - when file changes or is created
   - 'delete' - when file is deleted

and a method .close().

If debounce is given, only fires after the file
definitely has not had its ctime changed
for at least debounce ms.  Does NOT fire when
the file first has ctime changed.
 */

(function() {
  var EventEmitter, fs,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  exports.Watcher = (function(superClass) {
    extend(Watcher, superClass);

    function Watcher(path, interval, debounce) {
      this.path = path;
      this.interval = interval;
      this.debounce = debounce;
      this._emit_when_stable = bind(this._emit_when_stable, this);
      this._listen = bind(this._listen, this);
      this.close = bind(this.close, this);
      fs.watchFile(this.path, {
        interval: this.interval,
        persistent: false
      }, this._listen);
    }

    Watcher.prototype.close = function() {
      this.removeAllListeners();
      return fs.unwatchFile(this.path, this.listener);
    };

    Watcher.prototype._listen = function(curr, prev) {
      if (curr.dev === 0) {
        return this.emit('delete');
      } else {
        if (this.debounce) {
          return this._emit_when_stable(true);
        } else {
          return this.emit('change');
        }
      }
    };

    Watcher.prototype._emit_when_stable = function(first) {

      /*
      @_emit_when_stable gets called
      periodically until the last ctime of the file
      is at least @debounce ms in the past, or there
      is an error.
       */
      if (first && this._waiting_for_stable) {
        return;
      }
      this._waiting_for_stable = true;
      return fs.stat(this.path, (function(_this) {
        return function(err, stats) {
          var elapsed;
          if (err) {
            delete _this._waiting_for_stable;
            return;
          }
          elapsed = new Date() - stats.ctime;
          if (elapsed < _this.debounce) {
            return setTimeout((function() {
              return _this._emit_when_stable(false);
            }), Math.max(500, _this.debounce - elapsed + 100));
          } else {
            delete _this._waiting_for_stable;
            return _this.emit('change');
          }
        };
      })(this));
    };

    return Watcher;

  })(EventEmitter);

}).call(this);
