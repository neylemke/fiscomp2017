
/*
Jupyter in-memory blob store, which hooks into the raw http server.
 */

(function() {
  var BASE64_TYPES, BlobStore, fs, misc, misc_node,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  misc = require('smc-util/misc');

  misc_node = require('smc-util-node/misc_node');

  BASE64_TYPES = ['image/png', 'image/jpeg', 'application/pdf', 'base64'];

  BlobStore = (function() {
    function BlobStore() {
      this.express_router = bind(this.express_router, this);
      this.keys = bind(this.keys, this);
      this.get_ipynb = bind(this.get_ipynb, this);
      this.get = bind(this.get, this);
      this.free = bind(this.free, this);
      this.readFile = bind(this.readFile, this);
      this.save = bind(this.save, this);
      this._blobs = {};
    }

    BlobStore.prototype.save = function(data, type, ipynb) {
      var base1, sha1, x;
      if (indexOf.call(BASE64_TYPES, type) >= 0) {
        data = new Buffer.from(data, 'base64');
      } else {
        data = new Buffer.from(data);
      }
      sha1 = misc_node.sha1(data);
      x = (base1 = this._blobs)[sha1] != null ? base1[sha1] : base1[sha1] = {
        ref: 0,
        data: data,
        type: type
      };
      x.ref += 1;
      x.ipynb = ipynb;
      return sha1;
    };

    BlobStore.prototype.readFile = function(path, type, cb) {
      return fs.readFile(path, (function(_this) {
        return function(err, data) {
          var base1, ext, ref, sha1, x;
          if (err) {
            return cb(err);
          } else {
            sha1 = misc_node.sha1(data);
            ext = (ref = misc.filename_extension(path)) != null ? ref.toLowerCase() : void 0;
            x = (base1 = _this._blobs)[sha1] != null ? base1[sha1] : base1[sha1] = {
              ref: 0,
              data: data,
              type: type
            };
            x.ref += 1;
            return cb(void 0, sha1);
          }
        };
      })(this));
    };

    BlobStore.prototype.free = function(sha1) {
      var x;
      x = this._blobs[sha1];
      if (x != null) {
        x.ref -= 1;
        if (x.ref <= 0) {
          delete this._blobs[sha1];
        }
      }
    };

    BlobStore.prototype.get = function(sha1) {
      var ref;
      return (ref = this._blobs[sha1]) != null ? ref.data : void 0;
    };

    BlobStore.prototype.get_ipynb = function(sha1) {
      var ref, x;
      x = this._blobs[sha1];
      if (x == null) {
        return;
      }
      if (x.ipynb != null) {
        return x.ipynb;
      }
      if (ref = x.type, indexOf.call(BASE64_TYPES, ref) >= 0) {
        return x.data.toString('base64');
      } else {
        return x.data.toString();
      }
    };

    BlobStore.prototype.keys = function() {
      return misc.keys(this._blobs);
    };

    BlobStore.prototype.express_router = function(base, express) {
      var router;
      router = express.Router();
      base += 'blobs/';
      router.get(base, (function(_this) {
        return function(req, res) {
          var sha1s;
          sha1s = misc.to_json(_this.keys());
          return res.send(sha1s);
        };
      })(this));
      router.get(base + '*', (function(_this) {
        return function(req, res) {
          var filename, sha1;
          filename = req.path.slice(base.length);
          sha1 = req.query.sha1;
          res.type(filename);
          return res.send(_this.get(sha1));
        };
      })(this));
      return router;
    };

    return BlobStore;

  })();

  exports.blob_store = new BlobStore();

}).call(this);
