
/*
Jupyter Backend

For interactive testing:

coffee> k = require('./jupyter').kernel(name:'sagemath', path:'a.ipynb'); k.execute_code(all:true, cb:console.log, code:'2+3')
 */

(function() {
  var Client, EventEmitter, Kernel, SAGE_JUPYTER_ENV, _jupyter_kernels, _kernel_data, async, blob_store, defaults, fs, get_kernel_data, iframe, jupyter_kernel_http_server, jupyter_kernel_info_handler, kernelspecs, key_value_store, logger, misc, misc_node, nbconvert, node_cleanup, remove_redundant_reps, required, util,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  kernelspecs = require('kernelspecs');

  fs = require('fs');

  misc = require('smc-util/misc');

  defaults = misc.defaults, required = misc.required;

  key_value_store = require('smc-util/key-value-store').key_value_store;

  misc_node = require('smc-util-node/misc_node');

  blob_store = require('./jupyter-blobs').blob_store;

  node_cleanup = require('node-cleanup');

  util = require('smc-webapp/jupyter/util');

  iframe = require('smc-webapp/jupyter/iframe');

  remove_redundant_reps = require('smc-webapp/jupyter/import-from-ipynb').remove_redundant_reps;

  nbconvert = require('./nbconvert');


  /*
  We set a few extra user-specific options for the environment in which
  Sage-based Jupyter kernels run; these are more multi-user friendly.
   */

  SAGE_JUPYTER_ENV = misc.merge(misc.copy(process.env), {
    "PYTHONUSERBASE": process.env.HOME + "/.local",
    "PYTHON_EGG_CACHE": process.env.HOME + "/.sage/.python-eggs",
    "R_MAKEVARS_USER": process.env.HOME + "/.sage/R/Makevars.user"
  });

  exports.jupyter_backend = function(syncdb, client) {
    var JupyterActions, JupyterStore, actions, dbg, path, project_id, redux_name, smc_react, store;
    dbg = client.dbg("jupyter_backend");
    dbg();
    JupyterActions = require('smc-webapp/jupyter/project-actions').JupyterActions;
    JupyterStore = require('smc-webapp/jupyter/store').JupyterStore;
    smc_react = require('smc-webapp/smc-react');
    project_id = client.client_id();
    path = misc.original_path(syncdb._path);
    redux_name = smc_react.redux_name(project_id, path);
    actions = new JupyterActions(redux_name, smc_react.redux);
    store = new JupyterStore(redux_name, smc_react.redux);
    actions._init(project_id, path, syncdb, store, client);
    return syncdb.once('init', function(err) {
      return dbg("syncdb init complete -- " + err);
    });
  };

  Client = (function() {
    function Client() {}

    Client.prototype.dbg = function(f) {
      return function() {
        var m;
        m = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return console.log.apply(console, ["Client." + f + ": "].concat(slice.call(m)));
      };
    };

    return Client;

  })();

  exports.kernel = function(opts) {
    var ref;
    opts = defaults(opts, {
      name: required,
      client: void 0,
      verbose: true,
      path: required,
      actions: void 0
    });
    if (opts.client == null) {
      opts.client = new Client();
    }
    return new Kernel(opts.name, (opts.verbose ? (ref = opts.client) != null ? ref.dbg : void 0 : void 0), opts.path, opts.actions);
  };


  /*
  Jupyter Kernel interface.
  
  The kernel does *NOT* start up until either spawn is explicitly called, or
  code execution is explicitly requested.  This makes it possible to
  call process_output without spawning an actual kernel.
   */

  _jupyter_kernels = {};

  node_cleanup((function(_this) {
    return function() {
      var id, kernel, results;
      results = [];
      for (id in _jupyter_kernels) {
        kernel = _jupyter_kernels[id];
        results.push(kernel.close());
      }
      return results;
    };
  })(this));

  logger = void 0;

  Kernel = (function(superClass) {
    extend(Kernel, superClass);

    function Kernel(name1, _dbg, _path, _actions) {
      var dbg, head, ref, tail;
      this.name = name1;
      this._dbg = _dbg;
      this._path = _path;
      this._actions = _actions;
      this.http_server = bind(this.http_server, this);
      this.process_attachment = bind(this.process_attachment, this);
      this.load_attachment = bind(this.load_attachment, this);
      this.nbconvert = bind(this.nbconvert, this);
      this.more_output = bind(this.more_output, this);
      this.kernel_info = bind(this.kernel_info, this);
      this.introspect = bind(this.introspect, this);
      this.complete = bind(this.complete, this);
      this._call = bind(this._call, this);
      this.call = bind(this.call, this);
      this.get_kernel_data = bind(this.get_kernel_data, this);
      this.get_blob_store = bind(this.get_blob_store, this);
      this.process_output = bind(this.process_output, this);
      this._execute_code = bind(this._execute_code, this);
      this._clear_execute_code_queue = bind(this._clear_execute_code_queue, this);
      this._process_execute_code_queue = bind(this._process_execute_code_queue, this);
      this.cancel_execute = bind(this.cancel_execute, this);
      this.execute_code = bind(this.execute_code, this);
      this._ensure_running = bind(this._ensure_running, this);
      this._low_level_dbg = bind(this._low_level_dbg, this);
      this.dbg = bind(this.dbg, this);
      this.close = bind(this.close, this);
      this.signal = bind(this.signal, this);
      this.spawn = bind(this.spawn, this);
      this._set_state = bind(this._set_state, this);
      this.store = key_value_store();
      ref = misc.path_split(this._path), head = ref.head, tail = ref.tail;
      this._directory = head;
      this._filename = tail;
      this._set_state('off');
      this._identity = misc.uuid();
      this._start_time = new Date() - 0;
      _jupyter_kernels[this._path] = this;
      dbg = this.dbg('constructor');
      dbg();
      logger = this.dbg;
      process.on('exit', this.close);
      this.setMaxListeners(100);
    }

    Kernel.prototype._set_state = function(state) {
      this._state = state;
      return this.emit('state', this._state);
    };

    Kernel.prototype.spawn = function(cb) {
      var dbg, fail, opts, ref, success;
      dbg = this.dbg('spawn');
      if (this._state === 'closed') {
        if (typeof cb === "function") {
          cb('closed');
        }
        return;
      }
      if ((ref = this._state) === 'running' || ref === 'starting') {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (this._state === 'spawning') {
        this._spawn_cbs.push(cb);
        return;
      }
      this._spawn_cbs = [cb];
      this._set_state('spawning');
      dbg('spawning kernel...');
      success = (function(_this) {
        return function(kernel) {
          dbg("spawned kernel; now creating comm channels...");
          kernel.spawn.on('error', function(err) {
            dbg("kernel spawn error", err);
            return _this.emit("spawn_error", err);
          });
          _this._kernel = kernel;
          _this._channels = require('enchannel-zmq-backend').createChannels(_this._identity, _this._kernel.config);
          _this._channels.shell.subscribe(function(mesg) {
            return _this.emit('shell', mesg);
          });
          _this._channels.stdin.subscribe(function(mesg) {
            return _this.emit('stdin', mesg);
          });
          _this._channels.iopub.subscribe(function(mesg) {
            var ref1, ref2;
            if (((ref1 = mesg.content) != null ? ref1.execution_state : void 0) != null) {
              _this.emit('execution_state', (ref2 = mesg.content) != null ? ref2.execution_state : void 0);
            }
            return _this.emit('iopub', mesg);
          });
          _this.once('iopub', function(m) {
            var f;
            dbg("iopub: " + (misc.to_json(m)));
            f = function() {
              var j, len, ref1, results;
              _this._set_state('running');
              ref1 = _this._spawn_cbs;
              results = [];
              for (j = 0, len = ref1.length; j < len; j++) {
                cb = ref1[j];
                results.push(typeof cb === "function" ? cb() : void 0);
              }
              return results;
            };
            return setTimeout(f, 100);
          });
          kernel.spawn.on('close', _this.close);
          _this._set_state('starting');
          return misc.retry_until_success({
            start_delay: 500,
            max_delay: 5000,
            factor: 1.4,
            max_time: 45000,
            f: function(cb) {
              _this.kernel_info({
                cb: function() {}
              });
              return cb(_this._state === 'starting');
            }
          });
        };
      })(this);
      fail = (function(_this) {
        return function(err) {
          var j, len, ref1, results;
          _this._set_state('off');
          err = "" + err;
          ref1 = _this._spawn_cbs;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            cb = ref1[j];
            results.push(typeof cb === "function" ? cb(err) : void 0);
          }
          return results;
        };
      })(this);
      opts = {
        detached: true,
        stdio: 'ignore'
      };
      if (this.name.indexOf('sage')) {
        opts.env = SAGE_JUPYTER_ENV;
      }
      if (this._directory !== '') {
        opts.cwd = this._directory;
      }
      require('spawnteract').launch(this.name, opts).then(success, fail);
    };

    Kernel.prototype.signal = function(signal) {
      var dbg, err, pid, ref, ref1;
      dbg = this.dbg("signal");
      pid = (ref = this._kernel) != null ? (ref1 = ref.spawn) != null ? ref1.pid : void 0 : void 0;
      dbg("pid=" + pid + ", signal=" + signal);
      if (pid) {
        try {
          this._clear_execute_code_queue();
          return process.kill(-pid, signal);
        } catch (error) {
          err = error;
          return dbg("error: " + err);
        }
      }
    };

    Kernel.prototype.close = function() {
      var cb, err, j, k, len, len1, opts, ref, ref1, ref2, ref3;
      this.dbg("close")();
      if (this._state === 'closed') {
        return;
      }
      this.store.close();
      delete this.store;
      this._set_state('closed');
      if (((ref = _jupyter_kernels[this._path]) != null ? ref._identity : void 0) === this._identity) {
        delete _jupyter_kernels[this._path];
      }
      this.removeAllListeners();
      process.removeListener('exit', this.close);
      if (this._kernel != null) {
        if ((ref1 = this._kernel.spawn) != null) {
          ref1.removeAllListeners();
        }
        this.signal('SIGKILL');
        try {
          fs.unlink(this._kernel.connectionFile);
        } catch (error) {
          err = error;
        }
        delete this._kernel;
        delete this._channels;
      }
      if (this._execute_code_queue != null) {
        ref2 = this._execute_code_queue;
        for (j = 0, len = ref2.length; j < len; j++) {
          opts = ref2[j];
          opts.cb('closed');
        }
        delete this._execute_code_queue;
      }
      delete this._kernel_info;
      if (this._kernel_info_cbs != null) {
        ref3 = this._kernel_info_cbs;
        for (k = 0, len1 = ref3.length; k < len1; k++) {
          cb = ref3[k];
          cb('closed');
        }
        return delete this._kernel_info_cbs;
      }
    };

    Kernel.prototype.dbg = function(f) {
      if (this._dbg == null) {
        return function() {};
      } else {
        return this._dbg("jupyter.Kernel('" + this.name + "',path='" + this._path + "')." + f);
      }
    };

    Kernel.prototype._low_level_dbg = function() {
      var channel, f, j, len, ref, results;
      f = (function(_this) {
        return function(channel) {
          return _this._channels[channel].subscribe(function(mesg) {
            return console.log(channel, mesg);
          });
        };
      })(this);
      ref = ['shell', 'iopub', 'control', 'stdin'];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        channel = ref[j];
        results.push(f(channel));
      }
      return results;
    };

    Kernel.prototype._ensure_running = function(cb) {
      if (this._state === 'closed') {
        cb("closed");
        return;
      }
      if (this._state !== 'running') {
        this.spawn(cb);
      } else {
        cb();
      }
    };

    Kernel.prototype.execute_code = function(opts) {
      opts = defaults(opts, {
        code: required,
        id: void 0,
        all: false,
        stdin: void 0,
        halt_on_error: true,
        cb: void 0
      });
      if (this._state === 'closed') {
        if (typeof opts.cb === "function") {
          opts.cb("closed");
        }
        return;
      }
      if (this._execute_code_queue == null) {
        this._execute_code_queue = [];
      }
      this._execute_code_queue.push(opts);
      if (this._execute_code_queue.length === 1) {
        return this._process_execute_code_queue();
      }
    };

    Kernel.prototype.cancel_execute = function(opts) {
      var dbg, i, j, o, ref;
      opts = defaults(opts, {
        id: required
      });
      if (this._state === 'closed') {
        return;
      }
      dbg = this.dbg("cancel_execute(id='" + opts.id + "')");
      if ((this._execute_code_queue == null) || this._execute_code_queue.length === 0) {
        dbg("nothing to do");
        return;
      }
      if (this._execute_code_queue.length > 1) {
        dbg("mutate @_execute_code_queue removing everything with the given id");
        for (i = j = ref = this._execute_code_queue.length - 1; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
          o = this._execute_code_queue[i];
          if (o.id === opts.id) {
            dbg("removing entry " + i + " from queue");
            this._execute_code_queue.splice(i, 1);
            o.cb("cancelled");
          }
        }
      }
      if (this._execute_code_queue[0].id === opts.id) {
        dbg("interrupting running computation");
        return this.signal("SIGINT");
      }
    };

    Kernel.prototype._process_execute_code_queue = function() {
      var dbg, n;
      dbg = this.dbg("_process_execute_code_queue");
      dbg("state='" + this._state + "'");
      if (this._state === 'closed') {
        dbg("closed");
        return;
      }
      if (this._execute_code_queue == null) {
        dbg("no queue");
        return;
      }
      n = this._execute_code_queue.length;
      if (n === 0) {
        dbg("queue is empty");
        return;
      }
      dbg("queue has " + n + " items; ensure kernel running");
      this._ensure_running((function(_this) {
        return function(err) {
          var j, len, opts, ref;
          if (err) {
            dbg("error running kernel -- " + err);
            ref = _this._execute_code_queue;
            for (j = 0, len = ref.length; j < len; j++) {
              opts = ref[j];
              if (typeof opts.cb === "function") {
                opts.cb(err);
              }
            }
            return _this._execute_code_queue = [];
          } else {
            dbg("now executing oldest item in queue");
            return _this._execute_code(_this._execute_code_queue[0]);
          }
        };
      })(this));
    };

    Kernel.prototype._clear_execute_code_queue = function() {
      var j, len, mesg, opts, ref;
      if (this._state === 'closed') {
        return;
      }
      if (this._execute_code_queue == null) {
        return;
      }
      mesg = {
        done: true
      };
      ref = this._execute_code_queue.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        opts = ref[j];
        if (opts.all) {
          if (typeof opts.cb === "function") {
            opts.cb(void 0, [mesg]);
          }
        } else {
          if (typeof opts.cb === "function") {
            opts.cb(void 0, mesg);
          }
        }
      }
      return this._execute_code_queue = [];
    };

    Kernel.prototype._execute_code = function(opts) {
      var all_mesgs, dbg, f, finish, g, h, iopub_done, message, push_mesg, shell_done;
      opts = defaults(opts, {
        code: required,
        id: void 0,
        all: false,
        stdin: void 0,
        halt_on_error: true,
        cb: required
      });
      dbg = this.dbg("_execute_code('" + (misc.trunc(opts.code, 15)) + "')");
      dbg("code='" + opts.code + "', all=" + opts.all);
      if (this._state === 'closed') {
        if (typeof opts.cb === "function") {
          opts.cb("closed");
        }
        return;
      }
      message = {
        header: {
          msg_id: "execute_" + (misc.uuid()),
          username: '',
          session: '',
          msg_type: 'execute_request',
          version: '5.0'
        },
        content: {
          code: opts.code,
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: opts.stdin != null
        }
      };
      if (opts.all) {
        all_mesgs = [];
      }
      f = g = h = shell_done = iopub_done = void 0;
      push_mesg = (function(_this) {
        return function(mesg) {
          var msg_type, ref;
          msg_type = (ref = mesg.header) != null ? ref.msg_type : void 0;
          mesg = misc.copy_with(mesg, ['metadata', 'content', 'buffers', 'done']);
          mesg = misc.deep_copy(mesg);
          mesg.msg_type = msg_type;
          if (opts.all) {
            return all_mesgs.push(mesg);
          } else {
            return typeof opts.cb === "function" ? opts.cb(void 0, mesg) : void 0;
          }
        };
      })(this);
      if (opts.stdin != null) {
        g = (function(_this) {
          return function(mesg) {
            dbg("got STDIN message -- " + (JSON.stringify(mesg)));
            if (mesg.parent_header.msg_id !== message.header.msg_id) {
              return;
            }
            return opts.stdin(mesg.content, function(err, response) {
              var m;
              if (err) {
                response = "ERROR -- " + err;
              }
              m = {
                header: {
                  msg_id: message.header.msg_id,
                  username: '',
                  session: '',
                  msg_type: 'input_reply',
                  version: '5.0'
                },
                content: {
                  value: response
                }
              };
              return _this._channels.stdin.next(m);
            });
          };
        })(this);
        this.on('stdin', g);
      }
      h = (function(_this) {
        return function(mesg) {
          var ref;
          if (mesg.parent_header.msg_id !== message.header.msg_id) {
            return;
          }
          dbg("got SHELL message -- " + (JSON.stringify(mesg)));
          if (((ref = mesg.content) != null ? ref.status : void 0) === 'error') {
            if (opts.halt_on_error) {
              _this._clear_execute_code_queue();
            }
            return typeof finish === "function" ? finish() : void 0;
          } else {
            push_mesg(mesg);
            shell_done = true;
            if (iopub_done && shell_done) {
              return typeof finish === "function" ? finish() : void 0;
            }
          }
        };
      })(this);
      this.on('shell', h);
      f = (function(_this) {
        return function(mesg) {
          var ref;
          if (mesg.parent_header.msg_id !== message.header.msg_id) {
            return;
          }
          dbg("got IOPUB message -- " + (JSON.stringify(mesg)));
          iopub_done = ((ref = mesg.content) != null ? ref.execution_state : void 0) === 'idle';
          push_mesg(mesg);
          if (iopub_done && shell_done) {
            return typeof finish === "function" ? finish() : void 0;
          }
        };
      })(this);
      this.on('iopub', f);
      finish = (function(_this) {
        return function() {
          if (f != null) {
            _this.removeListener('iopub', f);
          }
          if (g != null) {
            _this.removeListener('stdin', g);
          }
          if (h != null) {
            _this.removeListener('shell', h);
          }
          _this._execute_code_queue.shift();
          _this._process_execute_code_queue();
          push_mesg({
            done: true
          });
          if (opts.all) {
            if (typeof opts.cb === "function") {
              opts.cb(void 0, all_mesgs);
            }
          }
          delete opts.cb;
          return finish = void 0;
        };
      })(this);
      dbg("send the message");
      return this._channels.shell.next(message);
    };

    Kernel.prototype.process_output = function(content) {
      var dbg, j, len, ref, results, type;
      if (this._state === 'closed') {
        return;
      }
      dbg = this.dbg("process_output");
      dbg(JSON.stringify(content));
      if (content.data == null) {
        dbg("no data, so nothing to do");
        return;
      }
      remove_redundant_reps(content.data);
      ref = util.JUPYTER_MIMETYPES;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        if (content.data[type] != null) {
          if (type.split('/')[0] === 'image' || type === 'application/pdf') {
            results.push(content.data[type] = blob_store.save(content.data[type], type));
          } else if (type === 'text/html' && iframe.is_likely_iframe(content.data[type])) {
            content.data['iframe'] = iframe.process(content.data[type], blob_store);
            results.push(delete content.data[type]);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Kernel.prototype.get_blob_store = function() {
      return blob_store;
    };

    Kernel.prototype.get_kernel_data = function(cb) {
      return get_kernel_data(cb);
    };

    Kernel.prototype.call = function(opts) {
      opts = defaults(opts, {
        msg_type: required,
        content: {},
        cb: required
      });
      return this._ensure_running((function(_this) {
        return function(err) {
          if (err) {
            return opts.cb(err);
          } else {
            return _this._call(opts);
          }
        };
      })(this));
    };

    Kernel.prototype._call = function(opts) {
      var all_mesgs, f, message;
      message = {
        header: {
          msg_id: misc.uuid(),
          username: '',
          session: '',
          msg_type: opts.msg_type,
          version: '5.0'
        },
        content: opts.content
      };
      if (opts.all) {
        all_mesgs = [];
      }
      f = (function(_this) {
        return function(mesg) {
          if (mesg.parent_header.msg_id === message.header.msg_id) {
            _this.removeListener('shell', f);
            mesg = misc.deep_copy(mesg.content);
            if (misc.len(mesg.metadata) === 0) {
              delete mesg.metadata;
            }
            return opts.cb(void 0, mesg);
          }
        };
      })(this);
      this.on('shell', f);
      return this._channels.shell.next(message);
    };

    Kernel.prototype.complete = function(opts) {
      var dbg;
      opts = defaults(opts, {
        code: required,
        cursor_pos: required,
        cb: required
      });
      dbg = this.dbg("complete");
      dbg("code='" + opts.code + "', cursor_pos='" + opts.cursor_pos + "'");
      return this.call({
        msg_type: 'complete_request',
        content: {
          code: opts.code,
          cursor_pos: opts.cursor_pos
        },
        cb: opts.cb
      });
    };

    Kernel.prototype.introspect = function(opts) {
      var dbg;
      opts = defaults(opts, {
        code: required,
        cursor_pos: required,
        detail_level: required,
        cb: required
      });
      dbg = this.dbg("introspect");
      dbg("code='" + opts.code + "', cursor_pos='" + opts.cursor_pos + "', detail_level=" + opts.detail_level);
      return this.call({
        msg_type: 'inspect_request',
        content: {
          code: opts.code,
          cursor_pos: opts.cursor_pos,
          detail_level: opts.detail_level
        },
        cb: opts.cb
      });
    };

    Kernel.prototype.kernel_info = function(opts) {
      opts = defaults(opts, {
        cb: required
      });
      if (this._kernel_info != null) {
        opts.cb(void 0, this._kernel_info);
        return;
      }
      if (this._kernel_info_cbs != null) {
        this._kernel_info_cbs.push(opts.cb);
        return;
      }
      this._kernel_info_cbs = [opts.cb];
      return this.call({
        msg_type: 'kernel_info_request',
        cb: (function(_this) {
          return function(err, info) {
            var cb, j, len, ref, ref1;
            if (!err) {
              info.nodejs_version = process.version;
              info.start_time = (ref = _this._actions) != null ? ref.store.get('start_time') : void 0;
              _this._kernel_info = info;
            }
            ref1 = _this._kernel_info_cbs;
            for (j = 0, len = ref1.length; j < len; j++) {
              cb = ref1[j];
              cb(err, info);
            }
            return delete _this._kernel_info_cbs;
          };
        })(this)
      });
    };

    Kernel.prototype.more_output = function(opts) {
      var ref, ref1;
      opts = defaults(opts, {
        id: void 0,
        cb: required
      });
      if (opts.id == null) {
        opts.cb("must specify id");
        return;
      }
      if (this._actions == null) {
        opts.cb("must have redux actions");
        return;
      }
      return opts.cb(void 0, (ref = (ref1 = this._actions) != null ? ref1.store.get_more_output(opts.id) : void 0) != null ? ref : []);
    };

    Kernel.prototype.nbconvert = function(opts) {
      var args;
      opts = defaults(opts, {
        args: required,
        timeout: 30,
        cb: required
      });
      if (this._nbconvert_lock) {
        opts.cb("lock");
        return;
      }
      if (!misc.is_array(opts.args)) {
        opts.cb("args must be an array");
        return;
      }
      this._nbconvert_lock = true;
      args = misc.copy(opts.args);
      args.push(this._filename);
      return nbconvert.nbconvert({
        args: args,
        timeout: opts.timeout,
        directory: this._directory,
        cb: (function(_this) {
          return function(err) {
            delete _this._nbconvert_lock;
            return opts.cb(err);
          };
        })(this)
      });
    };

    Kernel.prototype.load_attachment = function(opts) {
      var dbg, sha1;
      opts = defaults(opts, {
        path: required,
        cb: required
      });
      dbg = this.dbg("load_attachment");
      dbg("path='" + opts.path + "'");
      if (opts.path[0] !== '/') {
        opts.path = process.env.HOME + '/' + opts.path;
      }
      sha1 = void 0;
      return misc.retry_until_success({
        f: (function(_this) {
          return function(cb) {
            return blob_store.readFile(opts.path, 'base64', function(err, _sha1) {
              sha1 = _sha1;
              return cb(err);
            });
          };
        })(this),
        max_time: 30000,
        cb: (function(_this) {
          return function(err) {
            fs.unlink(opts.path);
            return opts.cb(err, sha1);
          };
        })(this)
      });
    };

    Kernel.prototype.process_attachment = function(base64, mime) {
      return blob_store.save(base64, mime);
    };

    Kernel.prototype.http_server = function(opts) {
      var code, cursor_pos, dbg, err, key, level, value;
      opts = defaults(opts, {
        segments: required,
        query: required,
        cb: required
      });
      dbg = this.dbg("http_server");
      dbg(opts.segments.join('/'));
      switch (opts.segments[0]) {
        case 'signal':
          this.signal(opts.segments[1]);
          return opts.cb(void 0, {});
        case 'kernel_info':
          return this.kernel_info({
            cb: opts.cb
          });
        case 'more_output':
          return this.more_output({
            id: opts.query.id,
            cb: opts.cb
          });
        case 'complete':
          code = opts.query.code;
          if (!code) {
            opts.cb('must specify code to complete');
            return;
          }
          if (opts.query.cursor_pos != null) {
            try {
              cursor_pos = parseInt(opts.query.cursor_pos);
            } catch (error) {
              cursor_pos = code.length;
            }
          } else {
            cursor_pos = code.length;
          }
          return this.complete({
            code: opts.query.code,
            cursor_pos: cursor_pos,
            cb: opts.cb
          });
        case 'introspect':
          code = opts.query.code;
          if (code == null) {
            opts.cb('must specify code to introspect');
            return;
          }
          if (opts.query.cursor_pos != null) {
            try {
              cursor_pos = parseInt(opts.query.cursor_pos);
            } catch (error) {
              cursor_pos = code.length;
            }
          } else {
            cursor_pos = code.length;
          }
          if (opts.query.level != null) {
            try {
              level = parseInt(opts.query.level);
              if (level < 0 || level > 1) {
                level = 0;
              }
            } catch (error) {
              level = 0;
            }
          } else {
            level = 0;
          }
          return this.introspect({
            code: opts.query.code,
            cursor_pos: cursor_pos,
            detail_level: level,
            cb: opts.cb
          });
        case 'store':
          try {
            if (opts.query.key != null) {
              key = JSON.parse(opts.query.key);
            } else {
              key = void 0;
            }
            if (opts.query.value != null) {
              value = JSON.parse(opts.query.value);
            } else {
              value = void 0;
            }
          } catch (error) {
            err = error;
            opts.cb(err);
            return;
          }
          if (value == null) {
            return opts.cb(void 0, this.store.get(key));
          } else if (value === null) {
            this.store["delete"](key);
            return opts.cb();
          } else {
            this.store.set(key, value);
            return opts.cb();
          }
          break;
        default:
          return opts.cb("no route '" + (opts.segments.join('/')) + "'");
      }
    };

    return Kernel;

  })(EventEmitter);

  _kernel_data = void 0;

  exports.get_kernel_data = get_kernel_data = function(cb) {
    var fail, success;
    if (_kernel_data != null) {
      cb(void 0, _kernel_data);
      return;
    }
    fail = (function(_this) {
      return function(err) {
        return cb(err != null ? err : 'fail');
      };
    })(this);
    success = (function(_this) {
      return function(kernelspecs) {
        var kernel, ref, v, value;
        _kernel_data = {
          kernelspecs: kernelspecs
        };
        v = [];
        ref = _kernel_data.kernelspecs;
        for (kernel in ref) {
          value = ref[kernel];
          v.push({
            name: kernel,
            display_name: value.spec.display_name,
            language: value.spec.language
          });
        }
        v.sort(misc.field_cmp('display_name'));
        _kernel_data.jupyter_kernels = v;
        _kernel_data.jupyter_kernels_json = JSON.stringify(_kernel_data.jupyter_kernels);
        setTimeout((function() {
          return _kernel_data = void 0;
        }), 5000);
        return cb(void 0, _kernel_data);
      };
    })(this);
    return kernelspecs.findAll().then(success, fail);
  };

  jupyter_kernel_info_handler = function(base, router) {
    router.get(base + 'kernels.json', function(req, res) {
      return get_kernel_data(function(err, kernel_data) {
        if (err) {
          return res.send(err);
        } else {
          return res.send(kernel_data.jupyter_kernels_json);
        }
      });
    });
    router.get(base + 'kernelspecs/*', function(req, res) {
      return get_kernel_data(function(err, kernel_data) {
        var kernel, name, path, ref, resource_dir, segments;
        if (err) {
          return res.send(err);
        } else {
          path = req.path.slice((base + 'kernelspecs/').length).trim();
          if (path.length === 0) {
            res.send(kernel_data.jupyter_kernels_json);
            return;
          }
          segments = path.split('/');
          name = segments[0];
          kernel = kernel_data.kernelspecs[name];
          if (kernel == null) {
            res.send("no such kernel '" + name + "'");
            return;
          }
          resource_dir = (ref = kernel.resource_dir) != null ? ref : kernel.resources_dir;
          path = require('path').join(resource_dir, segments.slice(1).join('/'));
          path = require('path').resolve(path);
          if (!misc.startswith(path, resource_dir)) {
            return res.send("suspicious path '" + path + "'");
          } else {
            return fs.exists(path, function(exists) {
              if (!exists) {
                return res.send("no such path '" + path + "'");
              } else {
                return res.sendFile(path);
              }
            });
          }
        }
      });
    });
    return router;
  };

  jupyter_kernel_http_server = function(base, router) {
    router.get(base + 'kernels/*', function(req, res) {
      var kernel, path, segments;
      path = req.path.slice((base + 'kernels/').length).trim();
      if (path.length === 0) {
        res.send(kernel_data.jupyter_kernels_json);
        return;
      }
      segments = path.split('/');
      path = req.query.path;
      kernel = _jupyter_kernels[path];
      if (kernel == null) {
        res.send(JSON.stringify({
          error: "no kernel with path '" + path + "'"
        }));
        return;
      }
      return kernel.http_server({
        segments: segments,
        query: req.query,
        cb: function(err, resp) {
          if (err) {
            return res.send(JSON.stringify({
              error: err
            }));
          } else {
            return res.send(JSON.stringify(resp != null ? resp : {}));
          }
        }
      });
    });
    return router;
  };

  exports.jupyter_router = function(express) {
    var base, router;
    base = '/.smc/jupyter/';
    router = blob_store.express_router(base, express);
    router = jupyter_kernel_info_handler(base, router);
    router = jupyter_kernel_http_server(base, router);
    return router;
  };

}).call(this);
