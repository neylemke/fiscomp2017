
/*
Manage console sessions and the console server

This runs as part of the local hub.

NOTE: This code is complicated mainly because it supports multiple users
connecting (or reconnecting) to the **same** session, and also handles bursts
of output.
 */

(function() {
  var CONSOLE_SERVER_MAX_STARTUP_TIME_S, ConsoleSessions, _restarted_console_server, _restarting_console_server, async, fs, message, misc, misc_node, port_manager, restart_console_server, winston,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  async = require('async');

  winston = require('winston');

  message = require('smc-util/message');

  misc = require('smc-util/misc');

  misc_node = require('smc-util-node/misc_node');

  port_manager = require('./port_manager');

  CONSOLE_SERVER_MAX_STARTUP_TIME_S = 10;

  _restarting_console_server = false;

  _restarted_console_server = 0;

  restart_console_server = function(cb) {
    var dbg, err, port, port_file, t;
    dbg = function(m) {
      return winston.debug("restart_console_server: " + (misc.to_json(m)));
    };
    dbg();
    if (_restarting_console_server) {
      dbg("hit lock -- already restarting console server");
      cb("already restarting console server");
      return;
    }
    t = new Date() - _restarted_console_server;
    if (t <= CONSOLE_SERVER_MAX_STARTUP_TIME_S * 1000) {
      err = "restarted console server " + t + "ms ago -- still waiting for it to start";
      dbg(err);
      cb(err);
      return;
    }
    _restarting_console_server = true;
    dbg("restarting daemon");
    port_file = misc_node.abspath(port_manager.port_file('console'));
    port = void 0;
    return async.series([
      function(cb) {
        dbg("remove port_file=" + port_file);
        return fs.unlink(port_file, function(err) {
          return cb();
        });
      }, function(cb) {
        var cmd;
        dbg("restart console server");
        cmd = "smc-console-server";
        return misc_node.execute_code({
          command: cmd + " stop; " + cmd + " start",
          timeout: 15,
          ulimit_timeout: false,
          err_on_exit: true,
          bash: true,
          verbose: true,
          cb: cb
        });
      }, function(cb) {
        var f;
        dbg("wait a little to see if " + port_file + " appears, and if so read it and return port");
        f = function(cb) {
          return fs.exists(port_file, function(exists) {
            if (!exists) {
              return cb(true);
            } else {
              return fs.readFile(port_file, function(err, data) {
                var s;
                if (err) {
                  return cb(err);
                } else {
                  s = data.toString();
                  port = parseInt(s);
                  return cb();
                }
              });
            }
          });
        };
        return misc.retry_until_success({
          f: f,
          max_time: 7000,
          cb: cb
        });
      }
    ], (function(_this) {
      return function(err) {
        _restarting_console_server = false;
        _restarted_console_server = new Date();
        dbg("finished trying to restart console_server");
        if (err) {
          dbg("ERROR: " + err);
        }
        return cb(err, port);
      };
    })(this));
  };

  ConsoleSessions = (function() {
    function ConsoleSessions() {
      this.info = bind(this.info, this);
      this._new_session = bind(this._new_session, this);
      this._get_console_server_socket = bind(this._get_console_server_socket, this);
      this.get_session = bind(this.get_session, this);
      this.connect = bind(this.connect, this);
      this.terminate_all_sessions = bind(this.terminate_all_sessions, this);
      this.terminate_session = bind(this.terminate_session, this);
      this.session_exists = bind(this.session_exists, this);
      this.set_secret_token = bind(this.set_secret_token, this);
      this._sessions = {};
      this._get_session_cbs = {};
    }

    ConsoleSessions.prototype.set_secret_token = function(secret_token) {
      return this._secret_token = secret_token;
    };

    ConsoleSessions.prototype.session_exists = function(session_uuid) {
      return this._sessions[session_uuid] != null;
    };

    ConsoleSessions.prototype.terminate_session = function(session_uuid, cb) {
      var session;
      session = this._sessions[session_uuid];
      if (session == null) {
        return typeof cb === "function" ? cb() : void 0;
      } else {
        winston.debug("terminate console session '" + session_uuid + "'");
        if (session.status === 'running') {
          session.socket.end();
          session.status = 'done';
          return typeof cb === "function" ? cb() : void 0;
        } else {
          return typeof cb === "function" ? cb() : void 0;
        }
      }
    };

    ConsoleSessions.prototype.terminate_all_sessions = function() {
      var e, ref, results, session, session_uuid;
      ref = this._sessions[session_uuid];
      results = [];
      for (session_uuid in ref) {
        session = ref[session_uuid];
        try {
          results.push(session.socket.end());
        } catch (error) {
          e = error;
          results.push(session.status = 'done');
        }
      }
      return results;
    };

    ConsoleSessions.prototype.connect = function(client_socket, mesg, cb) {
      if (mesg.session_uuid == null) {
        mesg.session_uuid = misc.uuid();
      }
      client_socket.on('end', (function(_this) {
        return function() {
          return winston.debug("a console session client socket ended -- session_uuid=" + mesg.session_uuid);
        };
      })(this));
      return this.get_session(mesg, (function(_this) {
        return function(err, session) {
          if (err) {
            client_socket.write_mesg('json', message.error({
              id: mesg.id,
              error: err
            }));
            return typeof cb === "function" ? cb(err) : void 0;
          } else {
            client_socket.write_mesg('json', {
              desc: session.desc,
              history: session.history.toString()
            });
            misc_node.plug(client_socket, session.socket, 20000);
            session.clients.push(client_socket);
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      })(this));
    };

    ConsoleSessions.prototype.get_session = function(mesg, cb) {
      var history, port, session;
      winston.debug("get_session: console session " + mesg.session_uuid);
      session = this._sessions[mesg.session_uuid];
      if ((session != null) && session.status === 'running') {
        winston.debug("console session: done -- it's already there and working");
        cb(void 0, session);
        return;
      }
      if (this._get_session_cbs[mesg.session_uuid] == null) {
        winston.debug("console session not yet created -- put on stack");
        this._get_session_cbs[mesg.session_uuid] = [cb];
      } else {
        winston.debug("console session already being created -- just push cb onto stack and return");
        this._get_session_cbs[mesg.session_uuid].push(cb);
        return;
      }
      port = void 0;
      history = void 0;
      return async.series([
        (function(_this) {
          return function(cb) {
            if (session != null) {
              history = session.history;
            }
            winston.debug("console session does not exist or is not running, so we make a new session");
            session = void 0;
            return port_manager.get_port('console', function(err, _port) {
              if (err) {
                return cb();
              } else {
                port = _port;
                winston.debug("got console server port = " + port);
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (port != null) {
              return cb();
            } else {
              winston.debug("couldn't determine console server port; probably console server not running -- try restarting it");
              _this.terminate_all_sessions();
              return restart_console_server(function(err, _port) {
                if (err) {
                  return cb(err);
                } else {
                  port = _port;
                  winston.debug("restarted console server, then got port = " + port);
                  return cb();
                }
              });
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            winston.debug("console: Got port -- now create the new session");
            return _this._new_session(mesg, port, function(err, _session) {
              if (err) {
                return cb(err);
              } else {
                session = _session;
                if (history != null) {
                  session.history = history;
                }
                return cb();
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          var i, len, ref;
          ref = _this._get_session_cbs[mesg.session_uuid];
          for (i = 0, len = ref.length; i < len; i++) {
            cb = ref[i];
            cb(err, session);
          }
          return delete _this._get_session_cbs[mesg.session_uuid];
        };
      })(this));
    };

    ConsoleSessions.prototype._get_console_server_socket = function(port, cb) {
      var f, socket;
      socket = void 0;
      f = (function(_this) {
        return function(cb) {
          return misc_node.connect_to_locked_socket({
            port: port,
            token: _this._secret_token,
            cb: function(err, _socket) {
              if (err) {
                return cb(err);
              } else {
                socket = _socket;
                return cb();
              }
            }
          });
        };
      })(this);
      return async.series([
        (function(_this) {
          return function(cb) {
            return misc.retry_until_success({
              f: f,
              start_delay: 50,
              factor: 1.7,
              max_delay: 2000,
              max_time: 5000,
              cb: function(err) {
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (socket != null) {
              cb();
              return;
            }
            port_manager.forget_port('console');
            _this.terminate_all_sessions();
            return restart_console_server(function(err, _port) {
              if (err) {
                return cb(err);
              } else {
                port = _port;
                return cb();
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (socket != null) {
              cb();
              return;
            }
            return misc.retry_until_success({
              f: f,
              max_time: 5000,
              cb: cb
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return cb(err);
          } else {
            return cb(void 0, socket);
          }
        };
      })(this));
    };

    ConsoleSessions.prototype._new_session = function(mesg, port, cb) {
      winston.debug("_new_session: defined by " + (misc.to_json(mesg)));
      return this._get_console_server_socket(port, (function(_this) {
        return function(err, console_socket) {
          var no_response, no_response_timeout;
          if (err) {
            cb("_new_session: console server failed to connect -- " + err);
            return;
          }
          misc_node.enable_mesg(console_socket);
          console_socket.write_mesg('json', mesg);
          no_response = function() {
            if (cb != null) {
              cb("no response");
              console_socket.destroy();
              return cb = void 0;
            }
          };
          no_response_timeout = setTimeout(no_response, 5000);
          console_socket.once('mesg', function(type, desc) {
            var session;
            clearTimeout(no_response_timeout);
            if (cb == null) {
              return;
            }
            misc_node.disable_mesg(console_socket);
            session = {
              socket: console_socket,
              desc: desc,
              status: 'running',
              clients: [],
              history: '',
              session_uuid: mesg.session_uuid,
              project_id: mesg.project_id
            };
            session.amount_of_data = 0;
            session.last_data = misc.mswalltime();
            console_socket.on('data', function(data) {
              var n, tm;
              tm = misc.mswalltime();
              if (tm - session.last_data >= 2) {
                session.amount_of_data = 0;
              }
              session.last_data = tm;
              if (session.amount_of_data > 50000) {
                data = '[...]';
              }
              session.history += data;
              session.amount_of_data += data.length;
              n = session.history.length;
              if (n > 150000) {
                return session.history = session.history.slice(session.history.length - 100000);
              }
            });
            _this._sessions[mesg.session_uuid] = session;
            return cb(void 0, session);
          });
          return console_socket.on('end', function() {
            var client, i, len, ref, results, session;
            winston.debug("console session " + mesg.session_uuid + " ended");
            session = _this._sessions[mesg.session_uuid];
            if (session != null) {
              session.status = 'done';
              ref = session.clients;
              results = [];
              for (i = 0, len = ref.length; i < len; i++) {
                client = ref[i];
                results.push(client.end());
              }
              return results;
            }
          });
        };
      })(this));
    };

    ConsoleSessions.prototype.info = function(project_id) {
      var id, obj, ref, session;
      obj = {};
      ref = this._sessions;
      for (id in ref) {
        session = ref[id];
        if (session.project_id === project_id) {
          obj[id] = {
            desc: session.desc,
            status: session.status,
            history_length: session.history.length
          };
        }
      }
      return obj;
    };

    return ConsoleSessions;

  })();

  exports.ConsoleSessions = ConsoleSessions;

}).call(this);
