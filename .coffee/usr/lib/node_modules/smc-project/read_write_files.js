(function() {
  var async, child_process, common, fs, message, misc, misc_node, temp, winston;

  fs = require('fs');

  temp = require('temp');

  child_process = require('child_process');

  async = require('async');

  winston = require('winston');

  message = require('smc-util/message');

  misc_node = require('smc-util-node/misc_node');

  misc = require('smc-util/misc');

  common = require('./common');

  exports.read_file_from_project = function(socket, mesg) {
    var archive, data, id, is_dir, path, stats;
    data = void 0;
    path = misc_node.abspath(mesg.path);
    is_dir = void 0;
    id = void 0;
    archive = void 0;
    stats = void 0;
    return async.series([
      function(cb) {
        return fs.stat(path, function(err, _stats) {
          if (err) {
            return cb(err);
          } else {
            stats = _stats;
            is_dir = stats.isDirectory();
            return cb();
          }
        });
      }, function(cb) {
        return cb(common.check_file_size(stats.size));
      }, function(cb) {
        var args, split, target;
        if (is_dir) {
          if (mesg.archive !== 'tar.bz2') {
            cb("The only supported directory archive format is tar.bz2");
            return;
          }
          target = temp.path({
            suffix: '.' + mesg.archive
          });
          archive = mesg.archive;
          if (path[path.length - 1] === '/') {
            path = path.slice(0, path.length - 1);
          }
          split = misc.path_split(path);
          path = target;
          args = ["--exclude=.sagemathcloud*", '--exclude=.forever', '--exclude=.node*', '--exclude=.npm', '--exclude=.sage', '-jcf', target, split.tail];
          return child_process.execFile('tar', args, {
            cwd: split.head
          }, function(err, stdout, stderr) {
            if (err) {
              winston.debug("Issue creating tarball: " + err + ", " + stdout + ", " + stderr);
              return cb(err);
            } else {
              return cb();
            }
          });
        } else {
          return cb();
        }
      }, function(cb) {
        return fs.readFile(path, function(err, _data) {
          data = _data;
          return cb(err);
        });
      }, function(cb) {
        id = misc_node.uuidsha1(data);
        return cb();
      }, function(cb) {
        socket.write_mesg('json', message.file_read_from_project({
          id: mesg.id,
          data_uuid: id,
          archive: archive
        }));
        socket.write_mesg('blob', {
          uuid: id,
          blob: data
        });
        return cb();
      }
    ], function(err) {
      if (err && err !== 'file already known') {
        socket.write_mesg('json', message.error({
          id: mesg.id,
          error: err
        }));
      }
      if (is_dir) {
        return fs.exists(path, function(exists) {
          if (exists) {
            return fs.unlink(path);
          }
        });
      }
    });
  };

  exports.write_file_to_project = function(socket, mesg) {
    var data_uuid, path, write_file;
    data_uuid = mesg.data_uuid;
    path = misc_node.abspath(mesg.path);
    write_file = function(type, value) {
      if (type === 'blob' && value.uuid === data_uuid) {
        socket.removeListener('mesg', write_file);
        return async.series([
          function(cb) {
            return misc_node.ensure_containing_directory_exists(path, cb);
          }, function(cb) {
            return fs.writeFile(path, value.blob, cb);
          }
        ], function(err) {
          if (err) {
            return socket.write_mesg('json', message.error({
              id: mesg.id,
              error: err
            }));
          } else {
            return socket.write_mesg('json', message.file_written_to_project({
              id: mesg.id
            }));
          }
        });
      }
    };
    return socket.on('mesg', write_file);
  };

}).call(this);
