
/*
Manage Jupyter server
 */

(function() {
  var async, jupyter_port_queue, jupyter_start, jupyter_status, message, misc, misc_node, winston;

  async = require('async');

  winston = require('winston');

  misc_node = require('smc-util-node/misc_node');

  misc = require('smc-util/misc');

  message = require('smc-util/message');

  jupyter_status = function(cb) {
    return misc_node.execute_code({
      command: "smc-jupyter",
      args: ['status'],
      err_on_exit: true,
      bash: false,
      timeout: 20,
      ulimit_timeout: false,
      cb: function(err, out) {
        var e;
        if (err) {
          return cb(void 0, {
            "status": "stopped"
          });
        } else {
          try {
            return cb(void 0, misc.from_json(out.stdout));
          } catch (error) {
            e = error;
            return cb(void 0, {
              "status": "stopped"
            });
          }
        }
      }
    });
  };

  jupyter_start = function(mathjax, cb) {
    return misc_node.execute_code({
      command: "smc-jupyter",
      args: ['start', mathjax],
      err_on_exit: true,
      bash: false,
      timeout: 60,
      ulimit_timeout: false,
      cb: function(err, out) {
        var e, status;
        if (!err) {
          try {
            status = misc.from_json(out.stdout);
            if (!(status != null ? status.port : void 0)) {
              err = "unable to start -- no port; status=" + (misc.to_json(out));
            }
          } catch (error) {
            e = error;
            err = "error parsing smc-jupyter startup output -- " + e + ", {misc.to_json(out)}";
          }
        }
        return cb(err, status);
      }
    });
  };

  jupyter_port_queue = [];

  exports.jupyter_port = function(socket, mesg) {
    var dbg, mathjax, ref, status;
    dbg = function(m) {
      return winston.debug("jupyter_port: " + m);
    };
    dbg();
    jupyter_port_queue.push({
      socket: socket,
      mesg: mesg
    });
    mathjax = (ref = mesg.mathjax_url) != null ? ref : "/static/mathjax/MathJax.js";
    if (jupyter_port_queue.length > 1) {
      dbg("already " + jupyter_port_queue.length + " requests -- return immediately");
      return;
    }
    status = void 0;
    return async.series([
      function(cb) {
        dbg("checking jupyter status");
        return jupyter_status(function(err, _status) {
          status = _status;
          dbg("got status=" + (misc.to_json(status)));
          return cb(err);
        });
      }, function(cb) {
        if (status != null ? status.port : void 0) {
          dbg("already running; nothing more to do");
          cb();
          return;
        }
        dbg("not running, so start it running");
        return jupyter_start(mathjax, function(err, _status) {
          status = _status;
          dbg("after starting, got status=" + (misc.to_json(status)));
          return cb(err);
        });
      }
    ], function(err) {
      var i, len, resp, x;
      dbg("finished; (err=" + err + "); now sending resp");
      for (i = 0, len = jupyter_port_queue.length; i < len; i++) {
        x = jupyter_port_queue[i];
        if (err) {
          resp = message.error({
            id: x.mesg.id,
            error: "error starting jupyter -- " + err
          });
        } else {
          resp = message.jupyter_port({
            id: x.mesg.id,
            port: status.port
          });
        }
        x.socket.write_mesg('json', resp);
      }
      return jupyter_port_queue = [];
    });
  };

}).call(this);
