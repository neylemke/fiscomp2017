
/*
client.coffee -- A project viewed as a client for a hub.

For security reasons, a project does initiate a TCP connection to a hub,
but rather hubs initiate TCP connections to projects:

 * MINUS: This makes various things more complicated, e.g., a project
   might not have any open connection to a hub, but still "want" to write
   something to the database; in such a case it is simply out of luck
   and must wait.

 * PLUS: Security is simpler since a hub initiates the connection to
   a project.   A hub doesn't have to receive TCP connections and decide
   whether or not to trust what is on the other end of those connections.

That said, this architecture could change, and very little code would change
as a result.
 */

(function() {
  var DEBUG, DEBUG_FILE, EventEmitter, NEVER_CLOSE_SYNCSTRING_EXTENSIONS, SYNCSTRING_MAX_AGE_M, Watcher, async, db_doc, defaults, fs, join, json, jupyter, message, misc, misc_node, required, sage_session, syncstring, synctable, winston,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  SYNCSTRING_MAX_AGE_M = 20;

  NEVER_CLOSE_SYNCSTRING_EXTENSIONS = {
    sagews: true,
    'sage-jupyter2': true
  };

  fs = require('fs');

  join = require('path').join;

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  winston = require('winston');

  winston.remove(winston.transports.Console);

  winston.add(winston.transports.Console, {
    level: 'debug',
    timestamp: true,
    colorize: true
  });

  require('coffee-script/register');

  message = require('smc-util/message');

  misc = require('smc-util/misc');

  misc_node = require('smc-util-node/misc_node');

  synctable = require('smc-util/synctable');

  syncstring = require('smc-util/syncstring');

  db_doc = require('smc-util/db-doc');

  sage_session = require('./sage_session');

  jupyter = require('./jupyter/jupyter');

  json = require('./common').json;

  Watcher = require('./watcher').Watcher;

  defaults = misc.defaults, required = misc.required;

  DEBUG = false;

  DEBUG_FILE = process.env.HOME + '/.smc-DEBUG';

  if (fs.existsSync(DEBUG_FILE)) {
    winston.debug("'" + DEBUG_FILE + "' exists, so enabling very verbose logging");
    DEBUG = true;
  } else {
    winston.debug("'" + DEBUG_FILE + "' does not exist; minimal logging");
  }

  exports.Client = (function(superClass) {
    var get_all_hub_sockets;

    extend(Client, superClass);

    function Client(project_id) {
      this.project_id = project_id;
      this.watch_file = bind(this.watch_file, this);
      this.jupyter_kernel_info = bind(this.jupyter_kernel_info, this);
      this.jupyter_kernel = bind(this.jupyter_kernel, this);
      this.sage_session = bind(this.sage_session, this);
      this.shell = bind(this.shell, this);
      this.file_size = bind(this.file_size, this);
      this.path_stat = bind(this.path_stat, this);
      this.path_exists = bind(this.path_exists, this);
      this.path_access = bind(this.path_access, this);
      this.path_read = bind(this.path_read, this);
      this.write_file = bind(this.write_file, this);
      this.sync_db = bind(this.sync_db, this);
      this.sync_string = bind(this.sync_string, this);
      this.sync_table = bind(this.sync_table, this);
      this.query_get_changefeed_ids = bind(this.query_get_changefeed_ids, this);
      this.query_cancel = bind(this.query_cancel, this);
      this.query = bind(this.query, this);
      this.call = bind(this.call, this);
      this.get_hub_socket = bind(this.get_hub_socket, this);
      this.handle_mesg = bind(this.handle_mesg, this);
      this.active_socket = bind(this.active_socket, this);
      this.server_time = bind(this.server_time, this);
      this.is_connected = bind(this.is_connected, this);
      this.is_signed_in = bind(this.is_signed_in, this);
      this.is_user = bind(this.is_user, this);
      this.is_project = bind(this.is_project, this);
      this.client_id = bind(this.client_id, this);
      this.close = bind(this.close, this);
      this.alert_message = bind(this.alert_message, this);
      this.dbg = bind(this.dbg, this);
      this._update_recent_syncstrings = bind(this._update_recent_syncstrings, this);
      this._init_recent_syncstrings_table = bind(this._init_recent_syncstrings_table, this);
      this.dbg('constructor')();
      this.setMaxListeners(300);
      this._hub_callbacks = {};
      this._hub_client_sockets = {};
      this._changefeed_sockets = {};
      this._connected = false;
      this._init_recent_syncstrings_table();
    }


    /*
    _test_ping: () =>
        dbg = @dbg("_test_ping")
        test = () =>
            dbg("ping")
            t0 = new Date()
            @call
                message : message.ping()
                timeout : 3
                cb      : (err, resp) =>
                    dbg("pong: #{new Date()-t0}ms; got err=#{err}, resp=#{json(resp)}")
        setInterval(test, 7*1000)
    
    _test_query_set: () =>
        dbg = @dbg("_test_query_set")
        test = () =>
            dbg("query")
            @query
                query   :
                    projects : {title:"the project takes over!", description:"description set too"}
                cb      : (err, resp) =>
                    dbg("got: err=#{err}, resp=#{json(resp)}")
        setInterval(test, 6*1000)
    
    _test_query_get: () =>
        dbg = @dbg("_test_query_get")
        test = () =>
            dbg("query")
            @query
                query   :
                    projects : [{project_id:null, title:null, description:null}]
                timeout : 3
                cb      : (err, resp) =>
                    dbg("got: err=#{err}, resp=#{json(resp)}")
        setInterval(test, 5*1000)
    
    _test_sync_table: () =>
        dbg = @dbg("_test_sync_table")
        table = @sync_table(projects : [{project_id:null, title:null, description:null}])
        table.on 'change', (x) =>
            dbg("table=#{json(table.get().toJS())}")
            #table.set({title:'foo'})
    
    _test_sync_string: () =>
        dbg = @dbg("_test_sync_string")
        dbg()
        s = @sync_string(id:'5039592f55e13b2d1b78c55ae4a4d3188f3e98a6')
        s.on 'change', () =>
            dbg("sync_string changed to='#{s.version()}'")
        return s
     */

    Client.prototype._init_recent_syncstrings_table = function() {
      var dbg, obj;
      dbg = this.dbg("_init_recent_syncstrings_table");
      dbg();
      obj = {
        project_id: this.project_id,
        max_age_m: SYNCSTRING_MAX_AGE_M,
        path: null,
        last_active: null,
        deleted: null,
        doctype: null
      };
      this._open_syncstrings = {};
      this._recent_syncstrings = this.sync_table({
        recent_syncstrings_in_project: [obj]
      });
      this._recent_syncstrings.on('change', (function(_this) {
        return function() {
          return _this._update_recent_syncstrings();
        };
      })(this));
      return this._recent_syncstrings.once('change', (function(_this) {
        return function() {
          return _this._recent_syncstrings_interval = setInterval(_this._update_recent_syncstrings, 300);
        };
      })(this));
    };

    Client.prototype._update_recent_syncstrings = function() {
      var cutoff, dbg, keys, log_message, path, ref, results, string_id, val, x;
      dbg = this.dbg("update_recent_syncstrings");
      cutoff = misc.minutes_ago(SYNCSTRING_MAX_AGE_M);
      if (this._wait_syncstrings == null) {
        this._wait_syncstrings = {};
      }
      keys = {};
      x = this._recent_syncstrings.get();
      if (x == null) {
        return;
      }
      log_message = "open_syncstrings: " + (misc.len(this._open_syncstrings)) + "; recent_syncstrings: " + x.size;
      if (log_message !== this._update_recent_syncstrings_last) {
        winston.debug(log_message);
        this._update_recent_syncstrings_last = log_message;
      }
      x.map((function(_this) {
        return function(val, key) {
          var deleted, path, string_id;
          string_id = val.get('string_id');
          path = val.get('path');
          if (path === '.smc/local_hub/local_hub.log') {
            return;
          }
          if (val.get("last_active") > cutoff) {
            keys[string_id] = true;
            if ((_this._open_syncstrings[string_id] != null) || _this._wait_syncstrings[string_id]) {
              return;
            }
            if (_this._open_syncstrings[string_id] == null) {
              deleted = val.get('deleted');
              dbg("path='" + path + "', deleted=" + deleted + ", string_id='" + string_id + "'");
              async.series([
                function(cb) {
                  if (!deleted) {
                    cb();
                    return;
                  }
                  dbg("check if '" + path + "' exists");
                  return _this.path_exists({
                    path: path,
                    cb: function(err, exists) {
                      if (err) {
                        return cb(err);
                      } else {
                        deleted = !exists;
                        return cb();
                      }
                    }
                  });
                }
              ], function(err) {
                var doctype, ext, opts, ref, ss, type;
                if (err) {
                  return dbg("SERIOUS ERROR -- " + err);
                } else if (deleted) {
                  return dbg("ignoring deleted path '" + path + "'");
                } else if (_this._open_syncstrings[string_id] == null) {
                  dbg("open syncstring '" + path + "' with id '" + string_id + "'");
                  ext = misc.separate_file_extension(path).ext;
                  doctype = val.get('doctype');
                  if (doctype != null) {
                    dbg("using doctype='" + doctype + "'");
                    doctype = misc.from_json(doctype);
                    opts = (ref = doctype.opts) != null ? ref : {};
                    opts.path = path;
                    type = doctype.type;
                  } else {
                    opts = {
                      path: path
                    };
                    type = 'string';
                  }
                  if (ext === 'sage-ipython') {
                    opts.change_throttle = opts.patch_interval = 5;
                    opts.save_interval = 25;
                  }
                  ss = _this._open_syncstrings[string_id] = _this["sync_" + type](opts);
                  ss.on('error', function(err) {
                    dbg("ERROR creating syncstring '" + path + "' -- " + err + "; will try again later");
                    return ss.close();
                  });
                  ss.on('close', function() {
                    dbg("remove syncstring '" + path + "' with id '" + string_id + "' from cache due to close");
                    delete _this._open_syncstrings[string_id];
                    _this._wait_syncstrings[string_id] = true;
                    return setTimeout((function() {
                      return delete _this._wait_syncstrings[string_id];
                    }), 10000);
                  });
                  switch (ext) {
                    case 'sage-jupyter2':
                      return jupyter.jupyter_backend(ss, _this);
                  }
                }
              });
            }
          }
        };
      })(this));
      ref = this._open_syncstrings;
      results = [];
      for (string_id in ref) {
        val = ref[string_id];
        path = val._path;
        if (!keys[string_id] && !NEVER_CLOSE_SYNCSTRING_EXTENSIONS[misc.filename_extension(path)]) {
          dbg("close syncstring '" + path + "' with id '" + string_id + "'");
          val.close();
          results.push(delete this._open_syncstrings[string_id]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Client.prototype.dbg = function(f) {
      if (DEBUG) {
        return function() {
          var m, s;
          m = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          switch (m.length) {
            case 0:
              s = '';
              break;
            case 1:
              s = m[0];
              break;
            default:
              s = JSON.stringify(m);
          }
          return winston.debug("Client." + f + ": " + (misc.trunc_middle(s, 1000)));
        };
      } else {
        return function(m) {};
      }
    };

    Client.prototype.alert_message = function(opts) {
      opts = defaults(opts, {
        type: 'default',
        title: void 0,
        message: required,
        block: void 0,
        timeout: void 0
      });
      return this.dbg('alert_message')(opts.title, opts.message);
    };

    Client.prototype.close = function() {
      var _, ref, s;
      ref = misc.keys(this._open_syncstrings);
      for (_ in ref) {
        s = ref[_];
        s.close();
      }
      delete this._open_syncstrings;
      return clearInterval(this._recent_syncstrings_interval);
    };

    Client.prototype.client_id = function() {
      return this.project_id;
    };

    Client.prototype.is_project = function() {
      return true;
    };

    Client.prototype.is_user = function() {
      return false;
    };

    Client.prototype.is_signed_in = function() {
      return true;
    };

    Client.prototype.is_connected = function() {
      return this._connected;
    };

    Client.prototype.server_time = function() {
      return new Date();
    };

    Client.prototype.active_socket = function(socket) {
      var dbg, x;
      dbg = this.dbg("active_socket(id=" + socket.id + ")");
      x = this._hub_client_sockets[socket.id];
      if (x == null) {
        dbg();
        x = this._hub_client_sockets[socket.id] = {
          socket: socket,
          callbacks: {},
          activity: new Date()
        };
        socket.on('end', (function(_this) {
          return function() {
            var cb, id, ref;
            dbg("end");
            if (x.callbacks != null) {
              ref = x.callbacks;
              for (id in ref) {
                cb = ref[id];
                if (typeof cb === "function") {
                  cb('socket closed');
                }
              }
              delete x.callbacks;
            }
            delete _this._hub_client_sockets[socket.id];
            dbg("number of active sockets now equals " + (misc.len(_this._hub_client_sockets)));
            if (misc.len(_this._hub_client_sockets) === 0) {
              _this._connected = false;
              dbg("lost all active sockets");
              return _this.emit('disconnected');
            }
          };
        })(this));
        if (misc.len(this._hub_client_sockets) >= 1) {
          dbg("CONNECTED!");
          this._connected = true;
          return this.emit('connected');
        }
      } else {
        return x.activity = new Date();
      }
    };

    Client.prototype.handle_mesg = function(mesg, socket) {
      var dbg, f;
      dbg = this.dbg("handle_mesg(" + (json(mesg)) + ")");
      f = this._hub_callbacks[mesg.id];
      if (f != null) {
        dbg("calling callback");
        if (!mesg.multi_response) {
          delete this._hub_callbacks[mesg.id];
          delete this._hub_client_sockets[socket.id].callbacks[mesg.id];
        }
        f(mesg);
        return true;
      } else {
        dbg("no callback");
        return false;
      }
    };

    Client.prototype.get_hub_socket = function() {
      var v;
      v = misc.values(this._hub_client_sockets);
      if (v.length === 0) {
        return;
      }
      v.sort(function(a, b) {
        var ref, ref1;
        return misc.cmp((ref = a.activity) != null ? ref : 0, (ref1 = b.activity) != null ? ref1 : 0);
      });
      return v[v.length - 1].socket;
    };

    get_all_hub_sockets = function() {
      var x;
      return (function() {
        var i, len, ref, results;
        ref = misc.values(this._hub_client_sockets);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          x = ref[i];
          results.push(x.socket);
        }
        return results;
      }).call(Client);
    };

    Client.prototype.call = function(opts) {
      var base, cb, dbg, fail, socket, timer;
      opts = defaults(opts, {
        message: required,
        timeout: void 0,
        socket: void 0,
        cb: void 0
      });
      dbg = this.dbg("call(message=" + (json(opts.message)) + ")");
      dbg();
      socket = opts.socket != null ? opts.socket : opts.socket = this.get_hub_socket();
      if (socket == null) {
        dbg("no sockets");
        if (typeof opts.cb === "function") {
          opts.cb("no hubs currently connected to this project");
        }
        return;
      }
      if (opts.cb != null) {
        if (opts.timeout) {
          dbg("configure timeout");
          fail = (function(_this) {
            return function() {
              dbg("failed");
              delete _this._hub_callbacks[opts.message.id];
              if (typeof opts.cb === "function") {
                opts.cb("timeout after " + opts.timeout + "s");
              }
              return delete opts.cb;
            };
          })(this);
          timer = setTimeout(fail, opts.timeout * 1000);
        }
        if ((base = opts.message).id == null) {
          base.id = misc.uuid();
        }
        cb = this._hub_callbacks[opts.message.id] = (function(_this) {
          return function(resp) {
            if (timer != null) {
              clearTimeout(timer);
              timer = void 0;
            }
            if (resp.event === 'error') {
              return typeof opts.cb === "function" ? opts.cb(resp.error ? resp.error : 'error') : void 0;
            } else {
              return typeof opts.cb === "function" ? opts.cb(void 0, resp) : void 0;
            }
          };
        })(this);
        this._hub_client_sockets[socket.id].callbacks[opts.message.id] = cb;
      }
      return socket.write_mesg('json', opts.message);
    };

    Client.prototype.query = function(opts) {
      var mesg, socket;
      opts = defaults(opts, {
        query: required,
        changes: void 0,
        options: void 0,
        timeout: 30,
        cb: required
      });
      if ((opts.options != null) && !misc.is_array(opts.options)) {
        throw Error("options must be an array");
        return;
      }
      mesg = message.query({
        id: misc.uuid(),
        query: opts.query,
        options: opts.options,
        changes: opts.changes,
        multi_response: opts.changes
      });
      socket = this.get_hub_socket();
      if (socket == null) {
        opts.cb("no hub socket available");
        return;
      }
      if (opts.changes) {
        this._changefeed_sockets[mesg.id] = socket;
        socket.on('error', (function(_this) {
          return function() {
            return opts.cb('socket-end');
          };
        })(this));
        socket.on('end', (function(_this) {
          return function() {
            return opts.cb('socket-end');
          };
        })(this));
      }
      return this.call({
        message: mesg,
        timeout: opts.timeout,
        socket: socket,
        cb: opts.cb
      });
    };

    Client.prototype.query_cancel = function(opts) {
      var socket;
      opts = defaults(opts, {
        id: required,
        cb: void 0
      });
      socket = this._changefeed_sockets[opts.id];
      if (socket == null) {
        return typeof opts.cb === "function" ? opts.cb() : void 0;
      } else {
        return this.call({
          message: message.query_cancel({
            id: opts.id
          }),
          timeout: 30,
          socket: socket,
          cb: opts.cb
        });
      }
    };

    Client.prototype.query_get_changefeed_ids = function(opts) {
      var f, ids;
      opts = defaults(opts, {
        timeout: 30,
        cb: required
      });
      ids = [];
      f = (function(_this) {
        return function(socket, cb) {
          return _this.call({
            message: message.query_get_changefeed_ids(),
            timeout: opts.timeout,
            socket: socket,
            cb: function(err, resp) {
              if (!err) {
                ids = ids.concat(resp.changefeed_ids);
              }
              return cb();
            }
          });
        };
      })(this);
      return async.map(this.get_all_hub_sockets(), f, (function(_this) {
        return function() {
          return opts.cb(void 0, ids);
        };
      })(this));
    };

    Client.prototype.sync_table = function(query, options, debounce_interval, throttle_changes) {
      if (debounce_interval == null) {
        debounce_interval = 2000;
      }
      if (throttle_changes == null) {
        throttle_changes = void 0;
      }
      return synctable.sync_table(query, options, this, debounce_interval, throttle_changes);
    };

    Client.prototype.sync_string = function(opts) {
      opts = defaults(opts, {
        path: required,
        save_interval: 500,
        patch_interval: 500
      });
      opts.client = this;
      opts.project_id = this.project_id;
      this.dbg("sync_string(path='" + opts.path + "')")();
      return new syncstring.SyncString(opts);
    };

    Client.prototype.sync_db = function(opts) {
      opts = defaults(opts, {
        path: required,
        primary_keys: required,
        string_cols: [],
        change_throttle: 0,
        save_interval: 500,
        patch_interval: 500
      });
      opts.client = this;
      opts.project_id = this.project_id;
      this.dbg("sync_db(path='" + opts.path + "')")();
      return new db_doc.SyncDB(opts);
    };

    Client.prototype.write_file = function(opts) {
      var dbg, now, path, ref;
      opts = defaults(opts, {
        path: required,
        data: required,
        cb: required
      });
      path = join(process.env.HOME, opts.path);
      if (this._file_io_lock == null) {
        this._file_io_lock = {};
      }
      dbg = this.dbg("write_file(path='" + opts.path + "')");
      dbg();
      now = new Date();
      if (now - ((ref = this._file_io_lock[path]) != null ? ref : 0) < 15000) {
        dbg("LOCK");
        setTimeout(((function(_this) {
          return function() {
            return _this.write_file(opts);
          };
        })(this)), 500 + 500 * Math.random());
        return;
      }
      this._file_io_lock[path] = now;
      dbg("@_file_io_lock = " + (misc.to_json(this._file_io_lock)));
      return async.series([
        (function(_this) {
          return function(cb) {
            return misc_node.ensure_containing_directory_exists(path, cb);
          };
        })(this), (function(_this) {
          return function(cb) {
            return fs.writeFile(path, opts.data, cb);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          delete _this._file_io_lock[path];
          if (err) {
            dbg("error -- " + err);
          } else {
            dbg("success");
          }
          return opts.cb(err);
        };
      })(this));
    };

    Client.prototype.path_read = function(opts) {
      var content, dbg, now, path, ref;
      opts = defaults(opts, {
        path: required,
        maxsize_MB: void 0,
        cb: required
      });
      content = void 0;
      path = join(process.env.HOME, opts.path);
      dbg = this.dbg("path_read(path='" + opts.path + "', maxsize_MB=" + opts.maxsize_MB + ")");
      dbg();
      if (this._file_io_lock == null) {
        this._file_io_lock = {};
      }
      now = new Date();
      if (now - ((ref = this._file_io_lock[path]) != null ? ref : 0) < 15000) {
        dbg("LOCK");
        setTimeout(((function(_this) {
          return function() {
            return _this.path_read(opts);
          };
        })(this)), 500 + 500 * Math.random());
        return;
      }
      this._file_io_lock[path] = now;
      dbg("@_file_io_lock = " + (misc.to_json(this._file_io_lock)));
      return async.series([
        (function(_this) {
          return function(cb) {
            if (opts.maxsize_MB != null) {
              dbg("check if file too big");
              return _this.file_size({
                filename: opts.path,
                cb: function(err, size) {
                  if (err) {
                    dbg("error checking -- " + err);
                    return cb(err);
                  } else if (size > opts.maxsize_MB * 1000000) {
                    dbg("file is too big!");
                    return cb("file '" + opts.path + "' size (=" + (size / 1000000) + "MB) too large (must be at most " + opts.maxsize_MB + "MB); try opening it in a Terminal with vim instead or write to help@sagemath.com");
                  } else {
                    dbg("file is fine");
                    return cb();
                  }
                }
              });
            } else {
              return cb();
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            return fs.readFile(path, function(err, data) {
              if (err) {
                dbg("error reading file -- " + err);
                return cb(err);
              } else {
                dbg('read file');
                content = data.toString();
                return cb();
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          delete _this._file_io_lock[path];
          return opts.cb(err, content);
        };
      })(this));
    };

    Client.prototype.path_access = function(opts) {
      var access, i, len, ref, s;
      opts = defaults(opts, {
        path: required,
        mode: required,
        cb: required
      });
      access = 0;
      ref = opts.mode;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        access |= fs[s.toUpperCase() + '_OK'];
      }
      return fs.access(opts.path, access, opts.cb);
    };

    Client.prototype.path_exists = function(opts) {
      var dbg;
      opts = defaults(opts, {
        path: required,
        cb: required
      });
      dbg = this.dbg("checking if path (='" + opts.path + "') exists");
      dbg();
      return fs.exists(opts.path, (function(_this) {
        return function(exists) {
          dbg("returned " + exists);
          return opts.cb(void 0, exists);
        };
      })(this));
    };

    Client.prototype.path_stat = function(opts) {
      opts = defaults(opts, {
        path: required,
        cb: required
      });
      return fs.stat(opts.path, opts.cb);
    };

    Client.prototype.file_size = function(opts) {
      opts = defaults(opts, {
        filename: required,
        cb: required
      });
      return this.path_stat({
        path: opts.filename,
        cb: (function(_this) {
          return function(err, stat) {
            return opts.cb(err, stat != null ? stat.size : void 0);
          };
        })(this)
      });
    };

    Client.prototype.shell = function(opts) {
      return misc_node.execute_code(opts);
    };

    Client.prototype.sage_session = function(opts) {
      opts = defaults(opts, {
        path: required
      });
      return sage_session.sage_session({
        path: opts.path,
        client: this
      });
    };

    Client.prototype.jupyter_kernel = function(opts) {
      opts.client = this;
      return jupyter.kernel(opts);
    };

    Client.prototype.jupyter_kernel_info = function(opts) {
      opts = defaults(opts, {
        cb: required
      });
      return jupyter.get_kernel_data(opts.cb);
    };

    Client.prototype.watch_file = function(opts) {
      var dbg, path;
      opts = defaults(opts, {
        path: required,
        interval: 3000,
        debounce: 1000
      });
      path = require('path').join(process.env.HOME, opts.path);
      dbg = this.dbg("watch_file(path='" + path + "')");
      dbg("watching file '" + path + "'");
      return new Watcher(path, opts.interval, opts.debounce);
    };

    return Client;

  })(EventEmitter);

}).call(this);
