
/*
Start the Sage server and also get a new socket connection to it.
 */

(function() {
  var SAGE_SERVER_MAX_STARTUP_TIME_S, SageSession, _get_sage_socket, _restarted_sage_server, _restarting_sage_server, async, blobs, cache, common, defaults, message, misc, misc_node, port_manager, required, restart_sage_server, winston,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  winston = require('winston');

  misc = require('smc-util/misc');

  misc_node = require('smc-util-node/misc_node');

  message = require('smc-util/message');

  port_manager = require('./port_manager');

  common = require('./common');

  blobs = require('./blobs');

  required = misc.required, defaults = misc.defaults;

  SAGE_SERVER_MAX_STARTUP_TIME_S = 30;

  _restarting_sage_server = false;

  _restarted_sage_server = 0;

  restart_sage_server = function(cb) {
    var dbg, err, t;
    dbg = function(m) {
      return winston.debug("restart_sage_server: " + (misc.to_json(m)));
    };
    if (_restarting_sage_server) {
      dbg("hit lock");
      cb("already restarting sage server");
      return;
    }
    t = new Date() - _restarted_sage_server;
    if (t <= SAGE_SERVER_MAX_STARTUP_TIME_S * 1000) {
      err = "restarted sage server " + t + "ms ago -- still waiting for it to start";
      dbg(err);
      cb(err);
      return;
    }
    _restarting_sage_server = true;
    dbg("restarting the daemon");
    return misc_node.execute_code({
      command: "smc-sage-server restart",
      timeout: 45,
      ulimit_timeout: false,
      err_on_exit: true,
      bash: true,
      cb: function(err, output) {
        if (err) {
          dbg("failed to restart sage server daemon -- " + err);
        } else {
          dbg("successfully restarted sage server daemon -- '" + (JSON.stringify(output)) + "'");
        }
        _restarting_sage_server = false;
        _restarted_sage_server = new Date();
        return cb(err);
      }
    });
  };

  exports.get_sage_socket = function(cb) {
    var socket, try_to_connect;
    socket = void 0;
    try_to_connect = function(cb) {
      return _get_sage_socket(function(err, _socket) {
        if (!err) {
          socket = _socket;
          return cb();
        } else {
          return restart_sage_server(function(err) {
            if (err) {
              cb(err);
              return;
            }
            return _get_sage_socket(function(err, _socket) {
              socket = _socket;
              return cb(err);
            });
          });
        }
      });
    };
    return misc.retry_until_success({
      f: try_to_connect,
      start_delay: 50,
      max_delay: 5000,
      factor: 1.5,
      max_time: SAGE_SERVER_MAX_STARTUP_TIME_S * 1000,
      log: function(m) {
        return winston.debug("get_sage_socket: " + m);
      },
      cb: function(err) {
        return cb(err, socket);
      }
    });
  };

  _get_sage_socket = function(cb) {
    var port, sage_socket;
    sage_socket = void 0;
    port = void 0;
    return async.series([
      (function(_this) {
        return function(cb) {
          winston.debug("get sage server port");
          return port_manager.get_port('sage', function(err, _port) {
            if (err) {
              cb(err);
            } else {
              port = _port;
              return cb();
            }
          });
        };
      })(this), (function(_this) {
        return function(cb) {
          winston.debug("get and unlock socket");
          return misc_node.connect_to_locked_socket({
            port: port,
            token: common.secret_token(),
            cb: function(err, _socket) {
              if (err) {
                port_manager.forget_port('sage');
                winston.debug("unlock socket: _new_session: sage session denied connection: " + err);
                cb("_new_session: sage session denied connection: " + err);
                return;
              }
              sage_socket = _socket;
              winston.debug("Successfully unlocked a sage session connection.");
              return cb();
            }
          });
        };
      })(this), (function(_this) {
        return function(cb) {
          winston.debug("request sage session from server.");
          misc_node.enable_mesg(sage_socket);
          sage_socket.write_mesg('json', message.start_session({
            type: 'sage'
          }));
          winston.debug("Waiting to read one JSON message back, which will describe the session....");
          return sage_socket.once('mesg', function(type, desc) {
            winston.debug("Got message back from Sage server: " + (common.json(desc)));
            sage_socket.pid = desc.pid;
            return cb();
          });
        };
      })(this)
    ], function(err) {
      return cb(err, sage_socket);
    });
  };

  cache = {};

  exports.sage_session = function(opts) {
    var name;
    opts = defaults(opts, {
      client: required,
      path: required
    });
    return cache[name = opts.path] != null ? cache[name] : cache[name] = new SageSession(opts);
  };


  /*
  Sage Session object
  
  Until you actually try to call it no socket need
   */

  SageSession = (function() {
    function SageSession(opts) {
      this._handle_mesg_json = bind(this._handle_mesg_json, this);
      this._handle_mesg_blob = bind(this._handle_mesg_blob, this);
      this.call = bind(this.call, this);
      this._init_path = bind(this._init_path, this);
      this._init_socket = bind(this._init_socket, this);
      this.is_running = bind(this.is_running, this);
      this.close = bind(this.close, this);
      this.dbg = bind(this.dbg, this);
      opts = defaults(opts, {
        client: required,
        path: required
      });
      this._path = opts.path;
      this._client = opts.client;
      this._output_cb = {};
    }

    SageSession.prototype.dbg = function(f) {
      return (function(_this) {
        return function(m) {
          return winston.debug("SageSession(path='" + _this._path + "')." + f + ": " + m);
        };
      })(this);
    };

    SageSession.prototype.close = function() {
      var cb, id, ref, ref1;
      if (this._socket != null) {
        misc_node.process_kill(this._socket.pid, 9);
      }
      if ((ref = this._socket) != null) {
        ref.end();
      }
      delete this._socket;
      ref1 = this._output_cb;
      for (id in ref1) {
        cb = ref1[id];
        cb({
          done: true,
          error: "killed"
        });
      }
      this._output_cb = {};
      return delete cache[this._path];
    };

    SageSession.prototype.is_running = function() {
      return this._socket != null;
    };

    SageSession.prototype._init_socket = function(cb) {
      var dbg;
      dbg = this.dbg('_init_socket()');
      dbg();
      return exports.get_sage_socket((function(_this) {
        return function(err, socket) {
          if (err) {
            dbg("fail -- " + err + ".");
            cb(err);
            return;
          }
          dbg("successfully opened a sage session");
          _this._socket = socket;
          socket.on('end', function() {
            delete _this._socket;
            return dbg("codemirror session terminated");
          });
          socket.on('mesg', function(type, mesg) {
            var name;
            dbg("sage session: received message " + type);
            return typeof _this[name = "_handle_mesg_" + type] === "function" ? _this[name](mesg) : void 0;
          });
          return _this._init_path(cb);
        };
      })(this));
    };

    SageSession.prototype._init_path = function(cb) {
      var dbg, err;
      dbg = this.dbg("_init_path()");
      dbg();
      err = void 0;
      return this.call({
        input: {
          event: 'execute_code',
          code: "os.chdir(salvus.data['path']);__file__=salvus.data['file']",
          data: {
            path: misc_node.abspath(misc.path_split(this._path).head),
            file: misc_node.abspath(this._path)
          },
          preparse: false
        },
        cb: (function(_this) {
          return function(resp) {
            if (resp.stderr) {
              err = resp.stderr;
              dbg("error '" + err + "'");
            }
            if (resp.done) {
              return typeof cb === "function" ? cb(err) : void 0;
            }
          };
        })(this)
      });
    };

    SageSession.prototype.call = function(opts) {
      var dbg, ref;
      opts = defaults(opts, {
        input: required,
        cb: void 0
      });
      dbg = this.dbg("call");
      dbg("input='" + (misc.trunc(misc.to_json(opts.input), 300)) + "'");
      switch (opts.input.event) {
        case 'ping':
          return typeof opts.cb === "function" ? opts.cb({
            pong: true
          }) : void 0;
        case 'status':
          return typeof opts.cb === "function" ? opts.cb({
            running: this.is_running()
          }) : void 0;
        case 'signal':
          if (this._socket != null) {
            dbg("sending signal " + opts.input.signal + " to process " + this._socket.pid);
            misc_node.process_kill(this._socket.pid, opts.input.signal);
          }
          return typeof opts.cb === "function" ? opts.cb({}) : void 0;
        case 'restart':
          dbg("restarting sage session");
          if (this._socket != null) {
            this.close();
          }
          return this._init_socket((function(_this) {
            return function(err) {
              if (err) {
                return typeof opts.cb === "function" ? opts.cb({
                  error: err
                }) : void 0;
              } else {
                return typeof opts.cb === "function" ? opts.cb({}) : void 0;
              }
            };
          })(this));
        case 'raw_input':
          dbg("sending sage_raw_input event");
          return (ref = this._socket) != null ? ref.write_mesg('json', {
            event: 'sage_raw_input',
            value: opts.input.value
          }) : void 0;
        default:
          return async.series([
            (function(_this) {
              return function(cb) {
                if (_this._socket != null) {
                  return cb();
                } else {
                  return _this._init_socket(cb);
                }
              };
            })(this), (function(_this) {
              return function(cb) {
                if (opts.input.id == null) {
                  opts.input.id = misc.uuid();
                  dbg("generated new random uuid for input: '" + opts.input.id + "' ");
                }
                _this._socket.write_mesg('json', opts.input);
                if (opts.cb != null) {
                  _this._output_cb[opts.input.id] = opts.cb;
                }
                return cb();
              };
            })(this)
          ], (function(_this) {
            return function(err) {
              if (err) {
                return typeof opts.cb === "function" ? opts.cb({
                  done: true,
                  error: err
                }) : void 0;
              }
            };
          })(this));
      }
    };

    SageSession.prototype._handle_mesg_blob = function(mesg) {
      var dbg, error, hub, ref, resp, sha1;
      sha1 = mesg.uuid;
      dbg = this.dbg("_handle_mesg_blob(sha1='" + sha1 + "')");
      dbg();
      hub = this._client.get_hub_socket();
      if (hub == null) {
        error = 'no global hubs are connected to the local hub, so nowhere to send file';
        dbg(error);
        resp = message.save_blob({
          error: error,
          sha1: sha1
        });
        if ((ref = this._socket) != null) {
          ref.write_mesg('json', resp);
        }
        return;
      }
      dbg("forwarding blob to hub");
      hub.write_mesg('blob', mesg);
      return blobs.receive_save_blob_message({
        sha1: sha1,
        cb: (function(_this) {
          return function(resp) {
            var ref1;
            return (ref1 = _this._socket) != null ? ref1.write_mesg('json', resp) : void 0;
          };
        })(this)
      });
    };

    SageSession.prototype._handle_mesg_json = function(mesg) {
      var c, dbg;
      dbg = this.dbg('_handle_mesg_json');
      dbg("mesg='" + (misc.trunc_middle(misc.to_json(mesg), 400)) + "'");
      c = this._output_cb[mesg != null ? mesg.id : void 0];
      if (c != null) {
        if (mesg.done || (mesg.done == null)) {
          delete this._output_cb[mesg.id];
          mesg.done = true;
        }
        if ((mesg.done != null) && !mesg.done) {
          delete mesg.done;
        }
        return c(mesg);
      }
    };

    return SageSession;

  })();

}).call(this);
