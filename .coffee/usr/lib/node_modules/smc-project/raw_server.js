
/*
Express HTTP server
 */

(function() {
  var async, body_parser, defaults, express, express_index, fs, jupyter_router, misc_node, ref, required, upload_endpoint;

  fs = require('fs');

  async = require('async');

  express = require('express');

  express_index = require('serve-index');

  body_parser = require('body-parser');

  misc_node = require('smc-util-node/misc_node');

  ref = require('smc-util/misc'), defaults = ref.defaults, required = ref.required;

  jupyter_router = require('./jupyter/jupyter').jupyter_router;

  upload_endpoint = require('./upload').upload_endpoint;

  exports.start_raw_server = function(opts) {
    var base_url, cb, data_path, home, host, port, project_id, raw_port_file, raw_server, ref1;
    opts = defaults(opts, {
      project_id: required,
      base_url: required,
      host: required,
      data_path: required,
      home: required,
      port: void 0,
      logger: void 0,
      cb: cb
    });
    project_id = opts.project_id, base_url = opts.base_url, host = opts.host, data_path = opts.data_path, home = opts.home, cb = opts.cb;
    if ((ref1 = opts.logger) != null) {
      ref1.info("starting express http server...");
    }
    raw_port_file = misc_node.abspath(data_path + "/raw.port");
    raw_server = express();
    raw_server.use(body_parser.urlencoded({
      extended: true
    }));
    port = opts.port;
    return async.series([
      function(cb) {
        var target;
        target = process.env.SMC + '/root';
        return fs.exists(target, function(exists) {
          if (exists) {
            return cb();
          } else {
            return fs.symlink('/', target, function(err) {
              var ref2;
              if (err) {
                if ((ref2 = opts.logger) != null) {
                  ref2.debug("WARNING: error creating root symlink -- " + err);
                }
              }
              return cb();
            });
          }
        });
      }, function(cb) {
        if (port) {
          return cb();
        } else {
          return misc_node.free_port(function(err, _port) {
            port = _port;
            return cb(err);
          });
        }
      }, function(cb) {
        return fs.writeFile(raw_port_file, port, cb);
      }, function(cb) {
        var base, ref2;
        base = base_url + "/" + project_id + "/raw/";
        if ((ref2 = opts.logger) != null) {
          ref2.info("raw server: port=" + port + ", host='" + host + "', base='" + base + "'");
        }
        raw_server.use(base, jupyter_router(express));
        raw_server.use(base, upload_endpoint(express, opts.logger));
        raw_server.use(base, function(req, res, next) {
          if (req.query.download != null) {
            res.setHeader('Content-Type', 'application/octet-stream');
          }
          res.setHeader('Cache-Control', 'private, no-cache, must-revalidate');
          return next();
        });
        raw_server.use(base, express_index(home, {
          hidden: true,
          icons: true
        }));
        raw_server.use(base, express["static"](home, {
          hidden: true
        }));
        return raw_server.listen(port, host, cb);
      }
    ], function(err) {
      var ref2;
      if (err) {
        if ((ref2 = opts.logger) != null) {
          ref2.debug("error starting raw_server: err = " + (misc.to_json(err)));
        }
      }
      return cb(err);
    });
  };

}).call(this);
