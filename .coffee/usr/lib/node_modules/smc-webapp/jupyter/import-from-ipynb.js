
/*
Importing from an ipynb object (in-memory version of .ipynb file)
 */

(function() {
  var DEFAULT_IPYNB, JUPYTER_MIMETYPES, defaults, misc, remove_redundant_reps, required, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  misc = require('smc-util/misc');

  defaults = misc.defaults, required = misc.required;

  util = require('./util');

  JUPYTER_MIMETYPES = util.JUPYTER_MIMETYPES;

  DEFAULT_IPYNB = {
    "cells": [
      {
        "cell_type": "code",
        "execution_count": null,
        "metadata": {},
        "outputs": [],
        "source": []
      }
    ],
    "metadata": {
      "kernelspec": {
        "display_name": "Python 2",
        "language": "python",
        "name": "python2"
      },
      "language_info": {
        "codemirror_mode": {
          "name": "ipython",
          "version": 2
        },
        "file_extension": ".py",
        "mimetype": "text/x-python",
        "name": "python",
        "nbconvert_exporter": "python",
        "pygments_lexer": "ipython2",
        "version": "2.7.13"
      }
    },
    "nbformat": 4,
    "nbformat_minor": 0
  };

  exports.IPynbImporter = (function() {
    function IPynbImporter() {
      this._import_cell = bind(this._import_cell, this);
      this._get_cell_input = bind(this._get_cell_input, this);
      this._get_cell_output = bind(this._get_cell_output, this);
      this._get_cell_type = bind(this._get_cell_type, this);
      this._get_exec_count = bind(this._get_exec_count, this);
      this._get_new_id = bind(this._get_new_id, this);
      this._id_is_available = bind(this._id_is_available, this);
      this._import_cell_output_content = bind(this._import_cell_output_content, this);
      this._join_array_strings_obj = bind(this._join_array_strings_obj, this);
      this._update_output_format = bind(this._update_output_format, this);
      this._read_in_cells = bind(this._read_in_cells, this);
      this._import_metadata = bind(this._import_metadata, this);
      this._import_settings = bind(this._import_settings, this);
      this._handle_old_versions = bind(this._handle_old_versions, this);
      this._sanity_improvements = bind(this._sanity_improvements, this);
      this.close = bind(this.close, this);
      this.metadata = bind(this.metadata, this);
      this.kernel = bind(this.kernel, this);
      this.cells = bind(this.cells, this);
      this["import"] = bind(this["import"], this);
    }

    IPynbImporter.prototype["import"] = function(opts) {
      opts = defaults(opts, {
        ipynb: {},
        new_id: void 0,
        existing_ids: [],
        output_handler: void 0,
        process_attachment: void 0
      });
      this._ipynb = misc.deep_copy(opts.ipynb);
      this._new_id = opts.new_id;
      this._output_handler = opts.output_handler;
      this._process_attachment = opts.process_attachment;
      this._existing_ids = opts.existing_ids;
      this._handle_old_versions();
      this._sanity_improvements();
      this._import_settings();
      this._import_metadata();
      this._read_in_cells();
    };

    IPynbImporter.prototype.cells = function() {
      return this._cells;
    };

    IPynbImporter.prototype.kernel = function() {
      return this._kernel;
    };

    IPynbImporter.prototype.metadata = function() {
      return this._metadata;
    };

    IPynbImporter.prototype.close = function() {
      delete this._cells;
      delete this._kernel;
      delete this._metadata;
      delete this._language_info;
      delete this._ipynb;
      delete this._existing_ids;
      delete this._new_id;
      delete this._output_handler;
      return delete this._process_attachment;
    };


    /*
    Everything below is the internal private implementation.
     */

    IPynbImporter.prototype._sanity_improvements = function() {
      var ipynb;
      ipynb = this._ipynb;
      if ((ipynb.cells == null) || ipynb.cells.length === 0) {
        ipynb.cells = misc.deep_copy(DEFAULT_IPYNB.cells);
      }
      if (ipynb.metadata == null) {
        ipynb.metadata = misc.deep_copy(DEFAULT_IPYNB.metadata);
      }
      if (ipynb.nbformat == null) {
        ipynb.nbformat = DEFAULT_IPYNB.nbformat;
      }
      return ipynb.nbformat_minor != null ? ipynb.nbformat_minor : ipynb.nbformat_minor = DEFAULT_IPYNB.nbformat_minor;
    };

    IPynbImporter.prototype._handle_old_versions = function() {
      var a, b, cell, data, i, ipynb, k, len, mesg, ref, ref1, results, type, v, worksheet;
      ipynb = this._ipynb;
      if (ipynb.nbformat >= 4) {
        return;
      }
      if (ipynb.cells == null) {
        ipynb.cells = [];
      }
      ref1 = (ref = ipynb.worksheets) != null ? ref : [];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        worksheet = ref1[i];
        results.push((function() {
          var j, l, len1, len2, len3, o, obj1, ref2, ref3, ref4, ref5, results1;
          ref3 = (ref2 = worksheet.cells) != null ? ref2 : [];
          results1 = [];
          for (j = 0, len1 = ref3.length; j < len1; j++) {
            cell = ref3[j];
            if (cell.input != null) {
              cell.source = cell.input;
              delete cell.input;
            }
            if (cell.cell_type === 'heading') {
              cell.cell_type = 'markdown';
              if (misc.is_array(cell.source)) {
                cell.source = cell.source.join('');
              }
              cell.source = '# ' + ("" + cell.source);
            }
            if (cell.outputs) {
              ref4 = cell.outputs;
              for (l = 0, len2 = ref4.length; l < len2; l++) {
                mesg = ref4[l];
                if (mesg.output_type === 'pyout') {
                  for (o = 0, len3 = JUPYTER_MIMETYPES.length; o < len3; o++) {
                    type = JUPYTER_MIMETYPES[o];
                    ref5 = type.split('/'), a = ref5[0], b = ref5[1];
                    if (mesg[b] != null) {
                      data = (
                        obj1 = {},
                        obj1["" + type] = mesg[b],
                        obj1
                      );
                      for (k in mesg) {
                        v = mesg[k];
                        delete mesg[k];
                      }
                      mesg.data = data;
                      break;
                    }
                  }
                  if (mesg.text != null) {
                    data = {
                      "text/plain": mesg.text.join('')
                    };
                    for (k in mesg) {
                      v = mesg[k];
                      delete mesg[k];
                    }
                    mesg.data = data;
                  }
                }
              }
            }
            results1.push(ipynb.cells.push(cell));
          }
          return results1;
        })());
      }
      return results;
    };

    IPynbImporter.prototype._import_settings = function() {
      var ref, ref1, ref2;
      return this._kernel = (ref = this._ipynb) != null ? (ref1 = ref.metadata) != null ? (ref2 = ref1.kernelspec) != null ? ref2.name : void 0 : void 0 : void 0;
    };

    IPynbImporter.prototype._import_metadata = function() {
      var k, m, metadata, ref, v;
      m = (ref = this._ipynb) != null ? ref.metadata : void 0;
      if (m == null) {
        return;
      }
      metadata = {};
      for (k in m) {
        v = m[k];
        if (k === 'kernelspec') {
          continue;
        }
        metadata[k] = v;
      }
      if (misc.len(metadata) > 0) {
        return this._metadata = metadata;
      }
    };

    IPynbImporter.prototype._read_in_cells = function() {
      var cell, cells, i, ipynb, len, n, ref, results;
      ipynb = this._ipynb;
      cells = this._cells = {};
      if ((ipynb != null ? ipynb.cells : void 0) == null) {
        return;
      }
      n = 0;
      ref = ipynb.cells;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        cell = ref[i];
        cell = this._import_cell(cell, n);
        this._cells[cell.id] = cell;
        results.push(n += 1);
      }
      return results;
    };

    IPynbImporter.prototype._update_output_format = function(content) {
      var a, b, i, len, obj1, ref, ref1, t;
      if (((ref = this._ipynb) != null ? ref.nbformat : void 0) >= 4) {
        return content;
      }
      if (content.output_type === 'stream') {
        if (misc.is_array(content.text)) {
          content.text = content.text.join('');
        }
        content.name = content.stream;
      } else {
        for (i = 0, len = JUPYTER_MIMETYPES.length; i < len; i++) {
          t = JUPYTER_MIMETYPES[i];
          ref1 = t.split('/'), a = ref1[0], b = ref1[1];
          if (content[b] != null) {
            content = {
              data: (
                obj1 = {},
                obj1["" + t] = content[b],
                obj1
              )
            };
            break;
          }
        }
        if (content.text != null) {
          content = {
            data: {
              'text/plain': content.text
            },
            output_type: 'stream'
          };
        }
      }
      return content;
    };

    IPynbImporter.prototype._join_array_strings_obj = function(obj) {
      var key, val;
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          if (misc.is_array(val)) {
            obj[key] = val.join('');
          }
        }
      }
      return obj;
    };

    IPynbImporter.prototype._import_cell_output_content = function(content) {
      content = this._update_output_format(content);
      this._join_array_strings_obj(content.data);
      if (misc.is_array(content.text)) {
        content.text = content.text.join('');
      }
      remove_redundant_reps(content.data);
      delete content.prompt_number;
      return content;
    };

    IPynbImporter.prototype._id_is_available = function(id) {
      var ref, ref1;
      return !(((ref = this._cells) != null ? ref[id] : void 0) || indexOf.call((ref1 = this._existing_ids) != null ? ref1 : [], id) >= 0);
    };

    IPynbImporter.prototype._get_new_id = function() {
      var id, s;
      if (this._new_id != null) {
        return this._new_id(this._id_is_available);
      } else {
        id = 0;
        while (true) {
          s = "" + id;
          if (this._id_is_available(s)) {
            return s;
          }
          id += 1;
        }
      }
    };

    IPynbImporter.prototype._get_exec_count = function(execution_count, prompt_number) {
      if (execution_count != null) {
        return execution_count;
      } else if (prompt_number != null) {
        return prompt_number;
      } else {
        return null;
      }
    };

    IPynbImporter.prototype._get_cell_type = function(cell_type) {
      return cell_type != null ? cell_type : 'code';
    };

    IPynbImporter.prototype._get_cell_output = function(outputs, alt_outputs, id) {
      var cell, cocalc_alt, content, handler, k;
      if ((outputs != null ? outputs.length : void 0) > 0) {
        cell = {
          id: id,
          output: {}
        };
        if (this._output_handler != null) {
          handler = this._output_handler(cell);
        }
        for (k in outputs) {
          content = outputs[k];
          cocalc_alt = alt_outputs != null ? alt_outputs[k] : void 0;
          if (cocalc_alt != null) {
            content = cocalc_alt;
          }
          this._import_cell_output_content(content);
          if (handler != null) {
            handler.message(content);
          } else {
            cell.output[k] = content;
          }
        }
        if (handler != null) {
          if (typeof handler.done === "function") {
            handler.done();
          }
        }
        return cell.output;
      } else {
        return null;
      }
    };

    IPynbImporter.prototype._get_cell_input = function(source) {
      var input;
      if (source != null) {
        if (misc.is_array(source)) {
          return input = source.join('');
        } else {
          return input = source;
        }
      } else {
        return input = null;
      }
    };

    IPynbImporter.prototype._import_cell = function(cell, n) {
      var base64, i, id, k, len, mime, name, obj, other, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, sha1, tag, val;
      id = (ref = (ref1 = this._existing_ids) != null ? ref1[n] : void 0) != null ? ref : this._get_new_id();
      obj = {
        type: 'cell',
        id: id,
        pos: n,
        input: this._get_cell_input(cell.source, n),
        output: this._get_cell_output(cell.outputs, (ref2 = cell.metadata) != null ? (ref3 = ref2.cocalc) != null ? ref3.outputs : void 0 : void 0, id),
        cell_type: this._get_cell_type(cell.cell_type),
        exec_count: this._get_exec_count(cell.execution_count, cell.prompt_number)
      };
      if (cell.metadata != null) {
        ref4 = ['collapsed', 'scrolled'];
        for (i = 0, len = ref4.length; i < len; i++) {
          k = ref4[i];
          if ((ref5 = cell.metadata) != null ? ref5[k] : void 0) {
            obj[k] = !!((ref6 = cell.metadata) != null ? ref6[k] : void 0);
          }
        }
        if (((ref7 = cell.metadata) != null ? ref7.slideshow : void 0) != null) {
          obj.slide = cell.metadata.slideshow.slide_type;
        }
        if (((ref8 = cell.metadata) != null ? ref8.tags : void 0) != null) {
          obj.tags = misc.dict((function() {
            var j, len1, ref9, results;
            ref9 = cell.metadata.tags;
            results = [];
            for (j = 0, len1 = ref9.length; j < len1; j++) {
              tag = ref9[j];
              results.push([tag, true]);
            }
            return results;
          })());
        }
        other = misc.copy_without(cell.metadata, ['collapsed', 'scrolled', 'slideshow', 'tags']);
        if (misc.len(other) > 0) {
          obj.metadata = other;
        }
      }
      if (cell.attachments != null) {
        obj.attachments = {};
        ref9 = cell.attachments;
        for (name in ref9) {
          val = ref9[name];
          for (mime in val) {
            base64 = val[mime];
            if (this._process_attachment != null) {
              sha1 = this._process_attachment(base64, mime);
              obj.attachments[name] = {
                type: 'sha1',
                value: sha1
              };
            } else {
              obj.attachments[name] = {
                type: 'base64',
                value: base64
              };
            }
          }
        }
      }
      return obj;
    };

    return IPynbImporter;

  })();

  exports.remove_redundant_reps = remove_redundant_reps = function(data) {
    var _, i, keep, len, type;
    if (data == null) {
      return;
    }
    for (i = 0, len = JUPYTER_MIMETYPES.length; i < len; i++) {
      type = JUPYTER_MIMETYPES[i];
      if (data[type] != null) {
        keep = type;
        break;
      }
    }
    if (keep != null) {
      for (type in data) {
        _ = data[type];
        if (type !== keep) {
          delete data[type];
        }
      }
    }
    return data;
  };

}).call(this);
