(function() {
  var ActivityLog, ELLIPSES, ISO_to_Date, RetryUntilSuccess, SOCKET_DATE_KEY, _, _done, apply_function_to_map_values, date_parser, defaults, env, escapeRegExp, filename_extension_re, fix_json_dates, has_null_leaf, is_array, is_date, is_object, l, len1, len2, map_without_undefined, mathjax_delim, mathjax_environments, reISO, reValidEmail, ref, required, round1, round2, s, seconds2hms, sha1, smc_logger_timestamp, smc_logger_timestamp_last, smc_start_time, smiley, smileys, smileys_definition, socket_date_parser, socket_date_replacer, timestamp_cmp0, types, u, underscore, zipcode,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = underscore = require('underscore');

  exports.RUNNING_IN_NODE = (typeof process !== "undefined" && process !== null ? process.title : void 0) === 'node';

  ref = require('./opts'), required = ref.required, defaults = ref.defaults, types = ref.types;

  exports.required = required;

  exports.defaults = defaults;

  exports.types = types;

  exports.startswith = function(s, x) {
    var l, len1, v;
    if (typeof x === "string") {
      return (s != null ? s.indexOf(x) : void 0) === 0;
    } else {
      for (l = 0, len1 = x.length; l < len1; l++) {
        v = x[l];
        if ((s != null ? s.indexOf(v) : void 0) === 0) {
          return true;
        }
      }
      return false;
    }
  };

  exports.endswith = function(s, t) {
    if ((s == null) || (t == null)) {
      return false;
    }
    return s.slice(s.length - t.length) === t;
  };

  exports.merge = function() {
    var dest, k, l, len1, obj, objs, v;
    dest = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (l = 0, len1 = objs.length; l < len1; l++) {
      obj = objs[l];
      for (k in obj) {
        v = obj[k];
        dest[k] = v;
      }
    }
    return dest;
  };

  exports.merge_copy = function() {
    var objs;
    objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return exports.merge.apply(exports, [{}].concat(slice.call(objs)));
  };

  exports.random_choice = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  exports.random_choice_from_obj = function(obj) {
    var k;
    k = exports.random_choice(exports.keys(obj));
    return [k, obj[k]];
  };

  exports.randint = function(lower, upper) {
    if (lower > upper) {
      throw new Error("randint: lower is larger than upper");
    }
    return Math.floor(Math.random() * (upper - lower + 1)) + lower;
  };

  exports.split = function(s) {
    var r;
    r = s.match(/\S+/g);
    if (r) {
      return r;
    } else {
      return [];
    }
  };

  exports.search_split = function(search) {
    var element, i, l, len1, length, terms;
    terms = [];
    search = search.split('"');
    length = search.length;
    for (i = l = 0, len1 = search.length; l < len1; i = ++l) {
      element = search[i];
      element = element.trim();
      if (element.length !== 0) {
        if (i % 2 === 0 || (i === length - 1 && length % 2 === 0)) {
          terms.push.apply(terms, element.split(" "));
        } else {
          terms.push(element);
        }
      }
    }
    return terms;
  };

  exports.search_match = function(s, v) {
    var l, len1, x;
    for (l = 0, len1 = v.length; l < len1; l++) {
      x = v[l];
      if (s.indexOf(x) === -1) {
        return false;
      }
    }
    return true;
  };

  exports.contains = function(word, sub) {
    return word.indexOf(sub) !== -1;
  };

  exports.count = function(str, strsearch) {
    var count, index;
    index = -1;
    count = -1;
    while (true) {
      index = str.indexOf(strsearch, index + 1);
      count++;
      if (index === -1) {
        break;
      }
    }
    return count;
  };

  exports.min_object = function(target, upper_bounds) {
    var prop, results, val;
    if (target == null) {
      target = {};
    }
    results = [];
    for (prop in upper_bounds) {
      val = upper_bounds[prop];
      results.push(target[prop] = target.hasOwnProperty(prop) ? target[prop] = Math.min(target[prop], upper_bounds[prop]) : upper_bounds[prop]);
    }
    return results;
  };

  exports.mswalltime = function(t) {
    if (t != null) {
      return (new Date()).getTime() - t;
    } else {
      return (new Date()).getTime();
    }
  };

  exports.walltime = function(t) {
    if (t != null) {
      return exports.mswalltime() / 1000.0 - t;
    } else {
      return exports.mswalltime() / 1000.0;
    }
  };

  exports.uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  exports.is_valid_uuid_string = function(uuid) {
    return typeof uuid === "string" && uuid.length === 36 && /[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}/i.test(uuid);
  };

  exports.is_valid_sha1_string = function(s) {
    return typeof s === 'string' && s.length === 40 && /[a-fA-F0-9]{40}/i.test(s);
  };

  sha1 = require('sha1');

  exports.uuidsha1 = function(data) {
    var i, s;
    s = sha1(data);
    i = -1;
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      i += 1;
      switch (c) {
        case 'x':
          return s[i];
        case 'y':
          return ((parseInt('0x' + s[i], 16) & 0x3) | 0x8).toString(16);
      }
    });
  };

  zipcode = new RegExp("^\\d{5}(-\\d{4})?$");

  exports.is_valid_zipcode = function(zip) {
    return zipcode.test(zip);
  };

  exports.times_per_second = function(f, max_time, max_loops) {
    var i, t, tm;
    if (max_time == null) {
      max_time = 5;
    }
    if (max_loops == null) {
      max_loops = 1000;
    }
    t = exports.walltime();
    i = 0;
    tm = 0;
    while (true) {
      f();
      tm = exports.walltime() - t;
      i += 1;
      if (tm >= max_time || i >= max_loops) {
        break;
      }
    }
    return Math.ceil(i / tm);
  };

  exports.to_json = JSON.stringify;


  /*
  The functions to_json_socket and from_json_socket are for sending JSON data back
  and forth in serialized form over a socket connection.   They replace Date objects by the
  object {DateEpochMS:ms_since_epoch} *only* during transit.   This is much better than
  converting to ISO, then using a regexp, since then all kinds of strings will get
  converted that were never meant to be date objects at all, e.g., a filename that is
  a ISO time string.  Also, ms since epoch is less ambiguous regarding old/different
  browsers, and more compact.
  
  If you change SOCKET_DATE_KEY, then all clients and servers and projects must be
  simultaneously restarted.
   */

  SOCKET_DATE_KEY = 'DateEpochMS';

  socket_date_replacer = function(key, value) {
    var date, obj1;
    if (this[key] instanceof Date) {
      date = this[key];
      return (
        obj1 = {},
        obj1["" + SOCKET_DATE_KEY] = date - 0,
        obj1
      );
    } else {
      return value;
    }
  };

  exports.to_json_socket = function(x) {
    return JSON.stringify(x, socket_date_replacer);
  };

  socket_date_parser = function(key, value) {
    if ((value != null ? value[SOCKET_DATE_KEY] : void 0) != null) {
      return new Date(value[SOCKET_DATE_KEY]);
    } else {
      return value;
    }
  };

  exports.from_json_socket = function(x) {
    var err;
    try {
      return JSON.parse(x, socket_date_parser);
    } catch (error) {
      err = error;
      console.debug("from_json: error parsing " + x + " (=" + (exports.to_json(x)) + ") from JSON");
      throw err;
    }
  };

  exports.to_safe_str = function(x) {
    var key, obj, sanitize, value;
    obj = {};
    for (key in x) {
      value = x[key];
      sanitize = false;
      if (key.indexOf("pass") !== -1) {
        sanitize = true;
      } else if (typeof value === 'string' && value.slice(0, 7) === "sha512$") {
        sanitize = true;
      }
      if (sanitize) {
        obj[key] = '(unsafe)';
      } else {
        if (typeof value === "object") {
          value = "[object]";
        } else if (typeof value === "string") {
          value = exports.trunc(value, 250);
        }
        obj[key] = value;
      }
    }
    return x = exports.to_json(obj);
  };

  reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;

  exports.date_parser = date_parser = function(k, v) {
    if (typeof v === 'string' && v.length >= 20 && reISO.exec(v)) {
      return ISO_to_Date(v);
    } else {
      return v;
    }
  };

  exports.ISO_to_Date = ISO_to_Date = function(s) {
    if (s.indexOf('Z') === -1) {
      s += 'Z';
    }
    return new Date(s);
  };

  exports.from_json = function(x) {
    var err;
    try {
      return JSON.parse(x, date_parser);
    } catch (error) {
      err = error;
      console.debug("from_json: error parsing " + x + " (=" + (exports.to_json(x)) + ") from JSON");
      throw err;
    }
  };

  exports.fix_json_dates = fix_json_dates = function(obj, date_keys) {
    var i, k, v, x;
    if (date_keys == null) {
      return obj;
    }
    if (exports.is_object(obj)) {
      for (k in obj) {
        v = obj[k];
        if (typeof v === 'object') {
          fix_json_dates(v, date_keys);
        } else if (typeof v === 'string' && v.length >= 20 && reISO.exec(v) && (date_keys === 'all' || indexOf.call(date_keys, k) >= 0)) {
          obj[k] = new Date(v);
        }
      }
    } else if (exports.is_array(obj)) {
      for (i in obj) {
        x = obj[i];
        obj[i] = fix_json_dates(x, date_keys);
      }
    } else if (typeof obj === 'string' && obj.length >= 20 && reISO.exec(obj) && date_keys === 'all') {
      return new Date(obj);
    }
    return obj;
  };

  exports.to_iso = function(d) {
    return (new Date(d - d.getTimezoneOffset() * 60 * 1000)).toISOString().slice(0, -5);
  };

  exports.to_iso_path = function(d) {
    return exports.to_iso(d).replace('T', '-').replace(/:/g, '');
  };

  exports.is_empty_object = function(obj) {
    return Object.keys(obj).length === 0;
  };

  exports.len = function(obj) {
    var a;
    if (obj == null) {
      return 0;
    }
    a = obj.length;
    if (a != null) {
      return a;
    }
    return underscore.keys(obj).length;
  };

  exports.keys = underscore.keys;

  exports.values = underscore.values;

  exports.dict = function(obj) {
    var a, l, len1, x;
    x = {};
    for (l = 0, len1 = obj.length; l < len1; l++) {
      a = obj[l];
      if (a.length !== 2) {
        throw new Error("ValueError: unexpected length of tuple");
      }
      x[a[0]] = a[1];
    }
    return x;
  };

  exports.remove = function(obj, val) {
    var i, l, ref1;
    for (i = l = 0, ref1 = obj.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      if (obj[i] === val) {
        obj.splice(i, 1);
        return;
      }
    }
    throw new Error("ValueError -- item not in array");
  };

  exports.pairs_to_obj = function(v) {
    var l, len1, o, x;
    o = {};
    for (l = 0, len1 = v.length; l < len1; l++) {
      x = v[l];
      o[x[0]] = x[1];
    }
    return o;
  };

  exports.obj_to_pairs = function(obj) {
    var results, x, y;
    results = [];
    for (x in obj) {
      y = obj[x];
      results.push([x, y]);
    }
    return results;
  };

  exports.substring_count = function(string, subString, allowOverlapping) {
    var n, pos, step;
    string += "";
    subString += "";
    if (subString.length <= 0) {
      return string.length + 1;
    }
    n = 0;
    pos = 0;
    step = (allowOverlapping ? 1 : subString.length);
    while (true) {
      pos = string.indexOf(subString, pos);
      if (pos >= 0) {
        n++;
        pos += step;
      } else {
        break;
      }
    }
    return n;
  };

  exports.max = function(array) {
    return array.reduce(function(a, b) {
      return Math.max(a, b);
    });
  };

  exports.min = function(array) {
    return array.reduce(function(a, b) {
      return Math.min(a, b);
    });
  };

  filename_extension_re = /(?:\.([^.]+))?$/;

  exports.filename_extension = function(filename) {
    var ref1;
    filename = exports.path_split(filename).tail;
    return (ref1 = filename_extension_re.exec(filename)[1]) != null ? ref1 : '';
  };

  exports.filename_extension_notilde = function(filename) {
    var ext;
    ext = exports.filename_extension(filename);
    while (ext && ext[ext.length - 1] === '~') {
      ext = ext.slice(0, ext.length - 1);
    }
    return ext;
  };

  exports.separate_file_extension = function(name) {
    var ext;
    ext = exports.filename_extension(name);
    if (ext !== '') {
      name = name.slice(0, name.length - ext.length - 1);
    }
    return {
      name: name,
      ext: ext
    };
  };

  exports.change_filename_extension = function(name, new_ext) {
    var ext, ref1;
    ref1 = exports.separate_file_extension(name), name = ref1.name, ext = ref1.ext;
    return name + "." + new_ext;
  };

  exports.copy = function(obj) {
    var r, x, y;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (exports.is_array(obj)) {
      return obj.slice(0);
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      r[x] = y;
    }
    return r;
  };

  exports.copy_without = function(obj, without) {
    var r, x, y;
    if (typeof without === 'string') {
      without = [without];
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      if (indexOf.call(without, x) < 0) {
        r[x] = y;
      }
    }
    return r;
  };

  exports.copy_with = function(obj, w) {
    var r, x, y;
    if (typeof w === 'string') {
      w = [w];
    }
    r = {};
    for (x in obj) {
      y = obj[x];
      if (indexOf.call(w, x) >= 0) {
        r[x] = y;
      }
    }
    return r;
  };

  exports.deep_copy = function(obj) {
    var flags, key, newInstance, val;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    try {
      newInstance = new obj.constructor();
    } catch (error) {
      newInstance = {};
    }
    for (key in obj) {
      val = obj[key];
      newInstance[key] = exports.deep_copy(val);
    }
    return newInstance;
  };

  exports.path_split = function(path) {
    var v;
    v = path.split('/');
    return {
      head: v.slice(0, -1).join('/'),
      tail: v[v.length - 1]
    };
  };

  exports.path_join = function() {
    var parts, replace, s, sep, x;
    parts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    sep = '/';
    replace = new RegExp(sep + '{1,}', 'g');
    s = ((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = parts.length; l < len1; l++) {
        x = parts[l];
        results.push("" + x);
      }
      return results;
    })()).join(sep).replace(replace, sep);
    return s;
  };

  exports.path_to_file = function(path, file) {
    if (path === '') {
      return file;
    }
    return path + '/' + file;
  };

  exports.meta_file = function(path, ext) {
    var p;
    if (path == null) {
      return;
    }
    p = exports.path_split(path);
    path = p.head;
    if (p.head !== '') {
      path += '/';
    }
    return path + "." + p.tail + ".sage-" + ext;
  };

  exports.original_path = function(path) {
    var ext, s, x;
    s = exports.path_split(path);
    if (s.tail[0] !== '.' || s.tail.indexOf('.sage-') === -1) {
      return path;
    }
    ext = exports.filename_extension(s.tail);
    x = s.tail.slice((s.tail[0] === '.' ? 1 : 0), s.tail.length - (ext.length + 1));
    if (s.head !== '') {
      x = s.head + '/' + x;
    }
    return x;
  };

  ELLIPSES = "…";

  exports.trunc = function(s, max_length) {
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (typeof s !== 'string') {
      s = "" + s;
    }
    if (s.length > max_length) {
      if (max_length < 1) {
        throw new Error("ValueError: max_length must be >= 1");
      }
      return s.slice(0, max_length - 1) + ELLIPSES;
    } else {
      return s;
    }
  };

  exports.trunc_middle = function(s, max_length) {
    var n;
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (typeof s !== 'string') {
      s = "" + s;
    }
    if (s.length <= max_length) {
      return s;
    }
    if (max_length < 1) {
      throw new Error("ValueError: max_length must be >= 1");
    }
    n = Math.floor(max_length / 2);
    return s.slice(0, n - 1 + (max_length % 2 ? 1 : 0)) + ELLIPSES + s.slice(s.length - n);
  };

  exports.trunc_left = function(s, max_length) {
    if (max_length == null) {
      max_length = 1024;
    }
    if (s == null) {
      return s;
    }
    if (typeof s !== 'string') {
      s = "" + s;
    }
    if (s.length > max_length) {
      if (max_length < 1) {
        throw new Error("ValueError: max_length must be >= 1");
      }
      return ELLIPSES + s.slice(s.length - max_length + 1);
    } else {
      return s;
    }
  };

  exports.pad_left = function(s, n) {
    var i, l, ref1, ref2;
    if (!typeof s === 'string') {
      s = "" + s;
    }
    for (i = l = ref1 = s.length, ref2 = n; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
      s = ' ' + s;
    }
    return s;
  };

  exports.pad_right = function(s, n) {
    var i, l, ref1, ref2;
    if (!typeof s === 'string') {
      s = "" + s;
    }
    for (i = l = ref1 = s.length, ref2 = n; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
      s += ' ';
    }
    return s;
  };

  exports.plural = function(number, singular, plural) {
    if (plural == null) {
      plural = singular + "s";
    }
    if (singular === 'GB' || singular === 'MB') {
      return singular;
    }
    if (number === 1) {
      return singular;
    } else {
      return plural;
    }
  };

  exports.git_author = function(first_name, last_name, email_address) {
    return first_name + " " + last_name + " <" + email_address + ">";
  };

  reValidEmail = (function() {
    var sAddrSpec, sAtom, sDomain, sDomainLiteral, sDomain_ref, sDtext, sLocalPart, sQtext, sQuotedPair, sQuotedString, sSubDomain, sValidEmail, sWord;
    sQtext = "[^\\x0d\\x22\\x5c\\x80-\\xff]";
    sDtext = "[^\\x0d\\x5b-\\x5d\\x80-\\xff]";
    sAtom = "[^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+";
    sQuotedPair = "\\x5c[\\x00-\\x7f]";
    sDomainLiteral = "\\x5b(" + sDtext + "|" + sQuotedPair + ")*\\x5d";
    sQuotedString = "\\x22(" + sQtext + "|" + sQuotedPair + ")*\\x22";
    sDomain_ref = sAtom;
    sSubDomain = "(" + sDomain_ref + "|" + sDomainLiteral + ")";
    sWord = "(" + sAtom + "|" + sQuotedString + ")";
    sDomain = sSubDomain + "(\\x2e" + sSubDomain + ")*";
    sLocalPart = sWord + "(\\x2e" + sWord + ")*";
    sAddrSpec = sLocalPart + "\\x40" + sDomain;
    sValidEmail = "^" + sAddrSpec + "$";
    return new RegExp(sValidEmail);
  })();

  exports.is_valid_email_address = function(email) {
    if (reValidEmail.test(email)) {
      return true;
    } else {
      return false;
    }
  };

  exports.canonicalize_email_address = function(email_address) {
    var i, j;
    if (typeof email_address !== 'string') {
      email_address = JSON.stringify(email_address);
    }
    i = email_address.indexOf('+');
    if (i !== -1) {
      j = email_address.indexOf('@');
      if (j !== -1) {
        email_address = email_address.slice(0, i) + email_address.slice(j);
      }
    }
    return email_address.toLowerCase();
  };

  exports.lower_email_address = function(email_address) {
    if (email_address == null) {
      return;
    }
    if (typeof email_address !== 'string') {
      email_address = JSON.stringify(email_address);
    }
    return email_address.toLowerCase();
  };

  exports.parse_user_search = function(query) {
    var a, email_re, l, len1, len2, match, q, queries, r, ref1, ref2, u, x;
    queries = (function() {
      var l, len1, ref1, results;
      ref1 = query.split(/,|;/);
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        q = ref1[l];
        results.push(q.trim().toLowerCase());
      }
      return results;
    })();
    r = {
      string_queries: [],
      email_queries: []
    };
    email_re = /<(.*)>/;
    for (l = 0, len1 = queries.length; l < len1; l++) {
      x = queries[l];
      if (x) {
        if (x.indexOf('@') === -1) {
          r.string_queries.push(x.split(/\s+/g));
        } else {
          ref1 = exports.split(x);
          for (u = 0, len2 = ref1.length; u < len2; u++) {
            a = ref1[u];
            if (a[0] === '<') {
              match = email_re.exec(a);
              a = (ref2 = match != null ? match[1] : void 0) != null ? ref2 : a;
            }
            if (exports.is_valid_email_address(a)) {
              r.email_queries.push(a);
            }
          }
        }
      }
    }
    return r;
  };

  exports.delete_trailing_whitespace = function(s) {
    return s.replace(/[^\S\n]+$/gm, "");
  };

  exports.assert = function(condition, mesg) {
    if (!condition) {
      if (typeof mesg === 'string') {
        throw new Error(mesg);
      }
      throw mesg;
    }
  };

  exports.retry_until_success = function(opts) {
    var delta, g, start_time, tries;
    opts = exports.defaults(opts, {
      f: exports.required,
      start_delay: 100,
      max_delay: 20000,
      factor: 1.4,
      max_tries: void 0,
      max_time: void 0,
      log: void 0,
      warn: void 0,
      name: '',
      cb: void 0
    });
    delta = opts.start_delay;
    tries = 0;
    if (opts.max_time != null) {
      start_time = new Date();
    }
    g = function() {
      tries += 1;
      if (opts.log != null) {
        if (opts.max_tries != null) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries + "/" + opts.max_tries);
        }
        if (opts.max_time != null) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries + " (started " + (new Date() - start_time) + "ms ago; will stop before " + opts.max_time + "ms max time)");
        }
        if ((opts.max_tries == null) && (opts.max_time == null)) {
          opts.log("retry_until_success(" + opts.name + ") -- try " + tries);
        }
      }
      return opts.f(function(err) {
        if (err) {
          if (err === "not_public") {
            if (typeof opts.cb === "function") {
              opts.cb("not_public");
            }
            return;
          }
          if (err && (opts.warn != null)) {
            opts.warn("retry_until_success(" + opts.name + ") -- err=" + err);
          }
          if (opts.log != null) {
            opts.log("retry_until_success(" + opts.name + ") -- err=" + err);
          }
          if ((opts.max_tries != null) && opts.max_tries <= tries) {
            if (typeof opts.cb === "function") {
              opts.cb("maximum tries (=" + opts.max_tries + ") exceeded - last error " + err);
            }
            return;
          }
          delta = Math.min(opts.max_delay, opts.factor * delta);
          if ((opts.max_time != null) && (new Date() - start_time) + delta > opts.max_time) {
            if (typeof opts.cb === "function") {
              opts.cb("maximum time (=" + opts.max_time + "ms) exceeded - last error " + err);
            }
            return;
          }
          return setTimeout(g, delta);
        } else {
          if (opts.log != null) {
            opts.log("retry_until_success(" + opts.name + ") -- success");
          }
          return typeof opts.cb === "function" ? opts.cb() : void 0;
        }
      });
    };
    return g();
  };

  exports.retry_until_success_wrapper = function(opts) {
    var _X;
    _X = new RetryUntilSuccess(opts);
    return function(cb) {
      return _X.call(cb);
    };
  };

  RetryUntilSuccess = (function() {
    function RetryUntilSuccess(opts) {
      this.call = bind(this.call, this);
      this.opts = exports.defaults(opts, {
        f: exports.defaults.required,
        start_delay: 100,
        max_delay: 20000,
        exp_factor: 1.4,
        max_tries: void 0,
        max_time: void 0,
        min_interval: 100,
        logname: void 0,
        verbose: false
      });
      if (this.opts.min_interval != null) {
        if (this.opts.start_delay < this.opts.min_interval) {
          this.opts.start_delay = this.opts.min_interval;
        }
      }
      this.f = this.opts.f;
    }

    RetryUntilSuccess.prototype.call = function(cb, retry_delay) {
      var g, start_time, w;
      if (this.opts.logname != null) {
        console.debug(this.opts.logname + "(... " + retry_delay + ")");
      }
      if (this._cb_stack == null) {
        this._cb_stack = [];
      }
      if (cb != null) {
        this._cb_stack.push(cb);
      }
      if (this._calling) {
        return;
      }
      this._calling = true;
      if (retry_delay == null) {
        this.attempts = 0;
      }
      if (this.opts.logname != null) {
        console.debug("actually calling -- " + this.opts.logname + "(... " + retry_delay + ")");
      }
      if (this.opts.max_time != null) {
        start_time = new Date();
      }
      g = (function(_this) {
        return function() {
          if (_this.opts.min_interval != null) {
            _this._last_call_time = exports.mswalltime();
          }
          return _this.f(function(err) {
            var f, results;
            _this.attempts += 1;
            _this._calling = false;
            if (err) {
              if (_this.opts.verbose) {
                console.debug(_this.opts.logname + ": error=" + err);
              }
              if ((_this.opts.max_tries != null) && _this.attempts >= _this.opts.max_tries) {
                while (_this._cb_stack.length > 0) {
                  _this._cb_stack.pop()(err);
                }
                return;
              }
              if (retry_delay == null) {
                retry_delay = _this.opts.start_delay;
              } else {
                retry_delay = Math.min(_this.opts.max_delay, _this.opts.exp_factor * retry_delay);
              }
              if ((_this.opts.max_time != null) && (new Date() - start_time) + retry_delay > _this.opts.max_time) {
                err = "maximum time (=" + _this.opts.max_time + "ms) exceeded - last error " + err;
                while (_this._cb_stack.length > 0) {
                  _this._cb_stack.pop()(err);
                }
                return;
              }
              f = function() {
                return _this.call(void 0, retry_delay);
              };
              return setTimeout(f, retry_delay);
            } else {
              results = [];
              while (_this._cb_stack.length > 0) {
                results.push(_this._cb_stack.pop()());
              }
              return results;
            }
          });
        };
      })(this);
      if ((this._last_call_time == null) || (this.opts.min_interval == null)) {
        return g();
      } else {
        w = exports.mswalltime(this._last_call_time);
        if (w < this.opts.min_interval) {
          return setTimeout(g, this.opts.min_interval - w);
        } else {
          return g();
        }
      }
    };

    return RetryUntilSuccess;

  })();

  exports.eval_until_defined = function(opts) {
    var delay, f, total;
    opts = exports.defaults(opts, {
      code: exports.required,
      start_delay: 100,
      max_time: 10000,
      exp_factor: 1.4,
      cb: exports.required
    });
    delay = void 0;
    total = 0;
    f = function() {
      var result;
      result = eval(opts.code);
      if (result != null) {
        return opts.cb(false, result);
      } else {
        if (delay == null) {
          delay = opts.start_delay;
        } else {
          delay *= opts.exp_factor;
        }
        total += delay;
        if (total > opts.max_time) {
          return opts.cb("failed to eval code within " + opts.max_time);
        } else {
          return setTimeout(f, delay);
        }
      }
    };
    return f();
  };

  exports.async_debounce = function(opts) {
    var call_again, callbacks, cb, f, interval, ref1, state;
    opts = defaults(opts, {
      f: required,
      interval: 1500,
      state: required,
      cb: void 0
    });
    f = opts.f, interval = opts.interval, state = opts.state, cb = opts.cb;
    call_again = function() {
      var n;
      n = interval + 1 - (new Date() - state.last);
      return state.timer = setTimeout(((function(_this) {
        return function() {
          delete state.timer;
          return exports.async_debounce({
            f: f,
            interval: interval,
            state: state
          });
        };
      })(this)), n);
    };
    if ((state.last != null) && (new Date() - state.last) <= interval) {
      if (state.next_callbacks == null) {
        state.next_callbacks = [];
      }
      if (cb != null) {
        state.next_callbacks.push(cb);
      }
      if (state.timer == null) {
        call_again();
      }
      return;
    }
    state.last = new Date();
    callbacks = exports.copy((ref1 = state.next_callbacks) != null ? ref1 : []);
    if (cb != null) {
      callbacks.push(cb);
    }
    delete state.next_callbacks;
    return f((function(_this) {
      return function(err) {
        var l, len1;
        for (l = 0, len1 = callbacks.length; l < len1; l++) {
          cb = callbacks[l];
          if (typeof cb === "function") {
            cb(err);
          }
        }
        callbacks = [];
        if ((state.next_callbacks != null) && (state.timer == null)) {
          return call_again();
        }
      };
    })(this));
  };

  exports.StringCharMapping = (function() {
    function StringCharMapping(opts) {
      var ch, ref1, ref2, st;
      if (opts == null) {
        opts = {};
      }
      this.to_array = bind(this.to_array, this);
      this.to_string = bind(this.to_string, this);
      this._find_next_char = bind(this._find_next_char, this);
      opts = exports.defaults(opts, {
        to_char: void 0,
        to_string: void 0
      });
      this._to_char = {};
      this._to_string = {};
      this._next_char = 'A';
      if (opts.to_string != null) {
        ref1 = opts.to_string;
        for (ch in ref1) {
          st = ref1[ch];
          this._to_string[ch] = st;
          this._to_char[st] = ch;
        }
      }
      if (opts.to_char != null) {
        ref2 = opts.to_char;
        for (st in ref2) {
          ch = ref2[st];
          this._to_string[ch] = st;
          this._to_char[st] = ch;
        }
      }
      this._find_next_char();
    }

    StringCharMapping.prototype._find_next_char = function() {
      var results;
      results = [];
      while (true) {
        this._next_char = String.fromCharCode(this._next_char.charCodeAt(0) + 1);
        if (this._to_string[this._next_char] == null) {
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    StringCharMapping.prototype.to_string = function(strings) {
      var a, l, len1, s, t;
      t = '';
      for (l = 0, len1 = strings.length; l < len1; l++) {
        s = strings[l];
        a = this._to_char[s];
        if (a != null) {
          t += a;
        } else {
          t += this._next_char;
          this._to_char[s] = this._next_char;
          this._to_string[this._next_char] = s;
          this._find_next_char();
        }
      }
      return t;
    };

    StringCharMapping.prototype.to_array = function(string) {
      var s;
      return (function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = string.length; l < len1; l++) {
          s = string[l];
          results.push(this._to_string[s]);
        }
        return results;
      }).call(this);
    };

    return StringCharMapping;

  })();

  exports.uniquify_string = function(s) {
    var c, l, len1, seen_already, t;
    seen_already = {};
    t = '';
    for (l = 0, len1 = s.length; l < len1; l++) {
      c = s[l];
      if (seen_already[c] == null) {
        t += c;
        seen_already[c] = true;
      }
    }
    return t;
  };


  /* -- not used
  exports.ensure_string_ends_in_newlines = (s, n) ->
      j = s.length-1
      while j >= 0 and j >= s.length-n and s[j] == '\n'
          j -= 1
       * Now either j = -1 or s[j] is not a newline (and it is the first character not a newline from the right).
      console.debug(j)
      k = n - (s.length - (j + 1))
      console.debug(k)
      if k == 0
          return s
      else
          return s + Array(k+1).join('\n')   # see http://stackoverflow.com/questions/1877475/repeat-character-n-times
   */

  exports.PROJECT_GROUPS = ['owner', 'collaborator', 'viewer', 'invited_collaborator', 'invited_viewer'];

  exports.make_valid_name = function(s) {
    return s.replace(/\W/g, '_').toLowerCase();
  };

  exports.parse_bup_timestamp = function(s) {
    var v;
    v = [s.slice(0, 4), s.slice(5, 7), s.slice(8, 10), s.slice(11, 13), s.slice(13, 15), s.slice(15, 17), '0'];
    return new Date(v[1] + "/" + v[2] + "/" + v[0] + " " + v[3] + ":" + v[4] + ":" + v[5] + " UTC");
  };

  exports.matches = function(s, words) {
    var l, len1, word;
    for (l = 0, len1 = words.length; l < len1; l++) {
      word = words[l];
      if (s.indexOf(word) === -1) {
        return false;
      }
    }
    return true;
  };

  exports.hash_string = function(s) {
    var chr, hash, i, len;
    hash = 0;
    i = void 0;
    chr = void 0;
    len = void 0;
    if (s.length === 0) {
      return hash;
    }
    i = 0;
    len = s.length;
    while (i < len) {
      chr = s.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0;
      i++;
    }
    return hash;
  };

  exports.parse_hashtags = function(t) {
    var base, i, v;
    v = [];
    if (t == null) {
      return v;
    }
    base = 0;
    while (true) {
      i = t.indexOf('#');
      if (i === -1 || i === t.length - 1) {
        return v;
      }
      base += i + 1;
      if (t[i + 1] === '#' || !(i === 0 || t[i - 1].match(/\s/))) {
        t = t.slice(i + 1);
        continue;
      }
      t = t.slice(i + 1);
      i = t.match(/\s|[^A-Za-z0-9_\-]/);
      if (i) {
        i = i.index;
      } else {
        i = -1;
      }
      if (i === 0) {
        base += i + 1;
        t = t.slice(i + 1);
      } else {
        if (i === -1) {
          v.push([base - 1, base + t.length]);
          return v;
        } else {
          v.push([base - 1, base + i]);
          base += i + 1;
          t = t.slice(i + 1);
        }
      }
    }
  };

  mathjax_environments = ['align', 'align*', 'alignat', 'alignat*', 'aligned', 'alignedat', 'array', 'Bmatrix', 'bmatrix', 'cases', 'CD', 'eqnarray', 'eqnarray*', 'equation', 'equation*', 'gather', 'gather*', 'gathered', 'matrix', 'multline', 'multline*', 'pmatrix', 'smallmatrix', 'split', 'subarray', 'Vmatrix', 'vmatrix'];

  mathjax_delim = [['$$', '$$'], ['\\(', '\\)'], ['\\[', '\\]']];

  for (l = 0, len1 = mathjax_environments.length; l < len1; l++) {
    env = mathjax_environments[l];
    mathjax_delim.push(["\\begin{" + env + "}", "\\end{" + env + "}"]);
  }

  mathjax_delim.push(['$', '$']);

  exports.parse_mathjax = function(t) {
    var at_end_of_string, contains_linebreak, d, i, j, len2, next_char, prev_char, u, v;
    v = [];
    if (t == null) {
      return v;
    }
    i = 0;
    while (i < t.length) {
      if (t.slice(i, i + 2) === '\\$') {
        i += 2;
        continue;
      }
      for (u = 0, len2 = mathjax_delim.length; u < len2; u++) {
        d = mathjax_delim[u];
        contains_linebreak = false;
        if (t.slice(i, i + d[0].length) === d[0]) {
          j = i + 1;
          while (j < t.length && t.slice(j, j + d[1].length) !== d[1]) {
            next_char = t.slice(j, j + 1);
            if (next_char === "\n") {
              contains_linebreak = true;
              if (d[0] === "$") {
                break;
              }
            }
            prev_char = t.slice(j - 1, j);
            if (next_char === "`" && prev_char !== '\\') {
              j -= 1;
              break;
            }
            j += 1;
          }
          j += d[1].length;
          at_end_of_string = j > t.length;
          if (!(d[0] === "$" && (contains_linebreak || at_end_of_string))) {
            v.push([i, j]);
          }
          i = j;
          break;
        }
      }
      i += 1;
    }
    return v;
  };

  exports.mathjax_escape = function(html) {
    return html.replace(/&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  };

  exports.path_is_in_public_paths = function(path, paths) {
    return exports.containing_public_path(path, paths) != null;
  };

  exports.containing_public_path = function(path, paths) {
    var len2, p, u;
    if (paths.length === 0) {
      return;
    }
    if (path == null) {
      return;
    }
    if (path.indexOf('../') !== -1) {
      return;
    }
    for (u = 0, len2 = paths.length; u < len2; u++) {
      p = paths[u];
      if (p === "") {
        return "";
      }
      if (path === p) {
        return p;
      }
      if (path.slice(0, p.length + 1) === p + '/') {
        return p;
      }
    }
    if (exports.filename_extension(path) === "zip") {
      return exports.containing_public_path(path.slice(0, path.length - 4), paths);
    }
    return void 0;
  };

  exports.encode_path = function(path) {
    path = encodeURI(path);
    return path.replace(/#/g, '%23').replace(/\?/g, '%3F');
  };

  exports.call_lock = function(opts) {
    var obj;
    opts = exports.defaults(opts, {
      obj: exports.required,
      timeout_s: 30
    });
    obj = opts.obj;
    obj._call_lock = function() {
      obj.__call_lock = true;
      obj.__call_lock_timeout = function() {
        obj.__call_lock = false;
        return delete obj.__call_lock_timeout;
      };
      return setTimeout(obj.__call_lock_timeout, opts.timeout_s * 1000);
    };
    obj._call_unlock = function() {
      if (obj.__call_lock_timeout != null) {
        clearTimeout(obj.__call_lock_timeout);
        delete obj.__call_lock_timeout;
      }
      return obj.__call_lock = false;
    };
    return obj._call_with_lock = function(f, cb) {
      if (obj.__call_lock) {
        if (typeof cb === "function") {
          cb("error -- hit call_lock");
        }
        return;
      }
      obj._call_lock();
      return f(function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        obj._call_unlock();
        return typeof cb === "function" ? cb.apply(null, args) : void 0;
      });
    };
  };

  exports.cmp = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    }
    return 0;
  };

  exports.cmp_array = function(a, b) {
    var c, i, ref1, u;
    for (i = u = 0, ref1 = Math.max(a.length, b.length); 0 <= ref1 ? u < ref1 : u > ref1; i = 0 <= ref1 ? ++u : --u) {
      c = exports.cmp(a[i], b[i]);
      if (c) {
        return c;
      }
    }
    return 0;
  };

  exports.cmp_Date = function(a, b) {
    if (a == null) {
      return -1;
    }
    if (b == null) {
      return 1;
    }
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    }
    return 0;
  };

  exports.timestamp_cmp = function(a, b, field) {
    if (field == null) {
      field = 'timestamp';
    }
    return -exports.cmp_Date(a[field], b[field]);
  };

  timestamp_cmp0 = function(a, b, field) {
    if (field == null) {
      field = 'timestamp';
    }
    return exports.cmp_Date(a[field], b[field]);
  };

  exports.field_cmp = function(field) {
    return function(a, b) {
      return exports.cmp(a[field], b[field]);
    };
  };

  ActivityLog = (function() {
    function ActivityLog(opts) {
      this._process_event = bind(this._process_event, this);
      this.process = bind(this.process, this);
      this.path = bind(this.path, this);
      this.obj = bind(this.obj, this);
      opts = exports.defaults(opts, {
        events: void 0,
        account_id: exports.required,
        notifications: {}
      });
      this.notifications = opts.notifications;
      this.account_id = opts.account_id;
      if (opts.events != null) {
        this.process(opts.events);
      }
    }

    ActivityLog.prototype.obj = function() {
      return {
        notifications: this.notifications,
        account_id: this.account_id
      };
    };

    ActivityLog.prototype.path = function(e) {
      return e.project_id + "/" + e.path;
    };

    ActivityLog.prototype.process = function(events) {
      var by_path, e, event, events_with_path, key, len2, path, results, u;
      by_path = {};
      for (u = 0, len2 = events.length; u < len2; u++) {
        e = events[u];
        key = this.path(e);
        events_with_path = by_path[key];
        if (events_with_path == null) {
          events_with_path = by_path[key] = [e];
        } else {
          events_with_path.push(e);
        }
      }
      results = [];
      for (path in by_path) {
        events_with_path = by_path[path];
        events_with_path.sort(timestamp_cmp0);
        results.push((function() {
          var len3, results1, z;
          results1 = [];
          for (z = 0, len3 = events_with_path.length; z < len3; z++) {
            event = events_with_path[z];
            results1.push(this._process_event(event, path));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    ActivityLog.prototype._process_event = function(event, path) {
      var a, who;
      if (path == null) {
        path = this.path(event);
      }
      a = this.notifications[path];
      if (a == null) {
        this.notifications[path] = a = {};
      }
      a.timestamp = event.timestamp;
      a.id = event.id;
      if ((event.seen_by != null) && event.seen_by.indexOf(this.account_id) !== -1) {
        a.seen = event.timestamp;
      }
      if ((event.read_by != null) && event.read_by.indexOf(this.account_id) !== -1) {
        a.read = event.timestamp;
      }
      if (event.action != null) {
        who = a[event.action];
        if (who == null) {
          who = a[event.action] = {};
        }
        return who[event.account_id] = event.timestamp;
      }
    };

    return ActivityLog;

  })();

  exports.activity_log = function(opts) {
    return new ActivityLog(opts);
  };

  exports.replace_all = function(string, search, replace) {
    return string.split(search).join(replace);
  };

  exports.remove_c_comments = function(s) {
    var i, j;
    while (true) {
      i = s.indexOf('/*');
      if (i === -1) {
        return s;
      }
      j = s.indexOf('*/');
      if (i >= j) {
        return s;
      }
      s = s.slice(0, i) + s.slice(j + 2);
    }
  };

  exports.date_to_snapshot_format = function(d) {
    var i, s;
    if (d == null) {
      d = 0;
    }
    if (typeof d === "number") {
      d = new Date(d);
    }
    s = d.toJSON();
    s = s.replace('T', '-').replace(/:/g, '');
    i = s.lastIndexOf('.');
    return s.slice(0, i);
  };

  exports.stripe_date = function(d) {
    return new Date(d * 1000).toLocaleDateString('lookup', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  exports.to_money = function(n) {
    return n.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
  };

  exports.stripe_amount = function(units, currency) {
    var s;
    if (currency !== 'usd') {
      throw Error("not-implemented currency " + currency);
    }
    s = "$" + (exports.to_money(units / 100));
    if (s.slice(s.length - 3) === '.00') {
      s = s.slice(0, s.length - 3);
    }
    return s;
  };

  exports.capitalize = function(s) {
    if (s != null) {
      return s.charAt(0).toUpperCase() + s.slice(1);
    }
  };

  exports.is_array = is_array = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  exports.is_integer = Number.isInteger;

  if (exports.is_integer == null) {
    exports.is_integer = function(n) {
      return typeof n === 'number' && (n % 1) === 0;
    };
  }

  exports.is_string = function(obj) {
    return typeof obj === 'string';
  };

  exports.is_object = is_object = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
  };

  exports.is_date = is_date = function(obj) {
    return obj instanceof Date;
  };

  exports.get_array_range = function(arr, value1, value2) {
    var index1, index2, ref1;
    index1 = arr.indexOf(value1);
    index2 = arr.indexOf(value2);
    if (index1 > index2) {
      ref1 = [index2, index1], index1 = ref1[0], index2 = ref1[1];
    }
    return arr.slice(index1, +index2 + 1 || 9e9);
  };

  exports.milliseconds_ago = function(ms) {
    return new Date(new Date() - ms);
  };

  exports.seconds_ago = function(s) {
    return exports.milliseconds_ago(1000 * s);
  };

  exports.minutes_ago = function(m) {
    return exports.seconds_ago(60 * m);
  };

  exports.hours_ago = function(h) {
    return exports.minutes_ago(60 * h);
  };

  exports.days_ago = function(d) {
    return exports.hours_ago(24 * d);
  };

  exports.weeks_ago = function(w) {
    return exports.days_ago(7 * w);
  };

  exports.months_ago = function(m) {
    return exports.days_ago(30.5 * m);
  };

  if (typeof window !== "undefined" && window !== null) {
    exports.server_time = function() {
      var ref1;
      return new Date(new Date() - parseFloat((ref1 = exports.get_local_storage('clock_skew')) != null ? ref1 : 0));
    };
    exports.server_milliseconds_ago = function(ms) {
      var ref1;
      return new Date(new Date() - ms - parseFloat((ref1 = exports.get_local_storage('clock_skew')) != null ? ref1 : 0));
    };
    exports.server_seconds_ago = function(s) {
      return exports.server_milliseconds_ago(1000 * s);
    };
    exports.server_minutes_ago = function(m) {
      return exports.server_seconds_ago(60 * m);
    };
    exports.server_hours_ago = function(h) {
      return exports.server_minutes_ago(60 * h);
    };
    exports.server_days_ago = function(d) {
      return exports.server_hours_ago(24 * d);
    };
    exports.server_weeks_ago = function(w) {
      return exports.server_days_ago(7 * w);
    };
    exports.server_months_ago = function(m) {
      return exports.server_days_ago(30.5 * m);
    };
  } else {
    exports.server_time = function() {
      return new Date();
    };
    exports.server_milliseconds_ago = exports.milliseconds_ago;
    exports.server_seconds_ago = exports.seconds_ago;
    exports.server_minutes_ago = exports.minutes_ago;
    exports.server_hours_ago = exports.hours_ago;
    exports.server_days_ago = exports.days_ago;
    exports.server_weeks_ago = exports.weeks_ago;
    exports.server_months_ago = exports.months_ago;
  }

  exports.milliseconds_before = function(ms, tm) {
    return new Date((tm != null ? tm : new Date()) - ms);
  };

  exports.seconds_before = function(s, tm) {
    return exports.milliseconds_before(1000 * s, tm);
  };

  exports.minutes_before = function(m, tm) {
    return exports.seconds_before(60 * m, tm);
  };

  exports.hours_before = function(h, tm) {
    return exports.minutes_before(60 * h, tm);
  };

  exports.days_before = function(d, tm) {
    return exports.hours_before(24 * d, tm);
  };

  exports.weeks_before = function(d, tm) {
    return exports.days_before(7 * d, tm);
  };

  exports.months_before = function(d, tm) {
    return exports.days_before(30.5 * d, tm);
  };

  exports.expire_time = function(s) {
    if (s) {
      return new Date((new Date() - 0) + s * 1000);
    }
  };

  exports.YEAR = new Date().getFullYear();

  exports.round1 = round1 = function(num) {
    return Math.round(num * 10) / 10;
  };

  exports.round2 = round2 = function(num) {
    return Math.round((num + 0.00001) * 100) / 100;
  };

  exports.seconds2hms = seconds2hms = function(secs) {
    var h, m, s;
    s = round2(secs % 60);
    m = Math.floor(secs / 60) % 60;
    h = Math.floor(secs / 60 / 60);
    if (h === 0 && m === 0) {
      return s + "s";
    }
    if (h > 0) {
      return h + "h" + m + "m" + s + "s";
    }
    if (m > 0) {
      return m + "m" + s + "s";
    }
  };

  exports.parse_number_input = function(input, round_number, allow_negative) {
    var val;
    if (round_number == null) {
      round_number = true;
    }
    if (allow_negative == null) {
      allow_negative = false;
    }
    input = (input + "").split('/');
    if (input.length !== 1 && input.length !== 2) {
      return void 0;
    }
    if (input.length === 2) {
      val = parseFloat(input[0]) / parseFloat(input[1]);
    }
    if (input.length === 1) {
      if (isNaN(input) || ("" + input).trim() === '') {
        return void 0;
      }
      val = parseFloat(input);
    }
    if (round_number) {
      val = round2(val);
    }
    if (isNaN(val) || val === 2e308 || (val < 0 && !allow_negative)) {
      return void 0;
    }
    return val;
  };

  exports.range = function(n, m) {
    var results, results1, u, z;
    if (m == null) {
      return (function() {
        results = [];
        for (var u = 0; 0 <= n ? u < n : u > n; 0 <= n ? u++ : u--){ results.push(u); }
        return results;
      }).apply(this);
    } else {
      return (function() {
        results1 = [];
        for (var z = n; n <= m ? z < m : z > m; n <= m ? z++ : z--){ results1.push(z); }
        return results1;
      }).apply(this);
    }
  };

  exports.map_sum = function(a, b) {
    var c, k, ref1, v;
    if (a == null) {
      return b;
    }
    if (b == null) {
      return a;
    }
    c = {};
    for (k in a) {
      v = a[k];
      c[k] = v + ((ref1 = b[k]) != null ? ref1 : 0);
    }
    for (k in b) {
      v = b[k];
      if (c[k] == null) {
        c[k] = v;
      }
    }
    return c;
  };

  exports.map_diff = function(a, b) {
    var c, k, ref1, v;
    if (b == null) {
      return a;
    }
    if (a == null) {
      c = {};
      for (k in b) {
        v = b[k];
        c[k] = -v;
      }
      return c;
    }
    c = {};
    for (k in a) {
      v = a[k];
      c[k] = v - ((ref1 = b[k]) != null ? ref1 : 0);
    }
    for (k in b) {
      v = b[k];
      if (c[k] == null) {
        c[k] = -v;
      }
    }
    return c;
  };

  exports.map_limit = function(a, b) {
    var c, k, ref1, v;
    c = {};
    if (typeof b === 'number') {
      for (k in a) {
        v = a[k];
        c[k] = Math.min(v, b);
      }
    } else {
      for (k in a) {
        v = a[k];
        c[k] = Math.min(v, (ref1 = b[k]) != null ? ref1 : Number.MAX_VALUE);
      }
    }
    return c;
  };

  exports.sum = function(arr, start) {
    if (start == null) {
      start = 0;
    }
    return underscore.reduce(arr, (function(a, b) {
      return a + b;
    }), start);
  };

  exports.apply_function_to_map_values = apply_function_to_map_values = function(map, f) {
    var k, v;
    for (k in map) {
      v = map[k];
      map[k] = f(v);
    }
    return map;
  };

  exports.coerce_codomain_to_numbers = function(map) {
    return apply_function_to_map_values(map, function(x) {
      if (typeof x === 'boolean') {
        if (x) {
          return 1;
        } else {
          return 0;
        }
      } else {
        return parseFloat(x);
      }
    });
  };

  exports.is_zero_map = function(map) {
    var k, v;
    if (map == null) {
      return true;
    }
    for (k in map) {
      v = map[k];
      if (v) {
        return false;
      }
    }
    return true;
  };

  exports.map_without_undefined = map_without_undefined = function(map) {
    var k, new_map, v;
    if (is_array(map)) {
      return map;
    }
    if (map == null) {
      return;
    }
    new_map = {};
    for (k in map) {
      v = map[k];
      if (v == null) {
        continue;
      } else {
        new_map[k] = is_object(v) ? map_without_undefined(v) : v;
      }
    }
    return new_map;
  };

  exports.map_mutate_out_undefined = function(map) {
    var k, results, v;
    results = [];
    for (k in map) {
      v = map[k];
      if (v == null) {
        results.push(delete map[k]);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  exports.should_open_in_foreground = function(e) {
    if (e.constructor.name === 'SyntheticMouseEvent') {
      e = e.nativeEvent;
    }
    return !(e.which === 2 || e.metaKey || e.altKey || e.ctrlKey);
  };

  exports.enumerate = function(v) {
    var i, len2, u, w, x;
    i = 0;
    w = [];
    for (u = 0, len2 = v.length; u < len2; u++) {
      x = v[u];
      w.push([i, x]);
      i += 1;
    }
    return w;
  };

  exports.escapeRegExp = escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  smileys_definition = [[':-)', "😁"], [':-(', "😞"], ['<3', "♡", null, '\\b'], [':shrug:', "¯\\\\_(ツ)_/¯"], ['o_o', "סּ_\סּ", '\\b', '\\b'], [':-p', "😛", null, '\\b'], ['>_<', "😆"], ['^^', "😄", '^', '\S'], ['^^ ', "😄 "], [' ^^', " 😄"], [';-)', "😉"], ['-_-', "😔"], [':-\\', "😏"], [':omg:', "😱"]];

  smileys = [];

  for (u = 0, len2 = smileys_definition.length; u < len2; u++) {
    smiley = smileys_definition[u];
    s = escapeRegExp(smiley[0]);
    if (smiley[2] != null) {
      s = smiley[2] + s;
    }
    if (smiley[3] != null) {
      s = s + smiley[3];
    }
    smileys.push([RegExp(s, 'g'), smiley[1]]);
  }

  exports.smiley = function(opts) {
    var len3, repl, subs, z;
    opts = exports.defaults(opts, {
      s: exports.required,
      wrap: void 0
    });
    s = opts.s.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
    for (z = 0, len3 = smileys.length; z < len3; z++) {
      subs = smileys[z];
      repl = subs[1];
      if (opts.wrap) {
        repl = opts.wrap[0] + repl + opts.wrap[1];
      }
      s = s.replace(subs[0], repl);
    }
    return s;
  };

  _ = underscore;

  exports.smiley_strings = function() {
    return _.filter(_.map(smileys_definition, _.first), function(x) {
      return !_.contains(['^^ ', ' ^^'], x);
    });
  };

  exports.to_human_list = function(arr) {
    arr = _.map(arr, function(x) {
      return x.toString();
    });
    if (arr.length > 1) {
      return arr.slice(0, -1).join(", ") + " and " + arr.slice(-1);
    } else if (arr.length === 1) {
      return arr[0].toString();
    } else {
      return "";
    }
  };

  exports.emoticons = exports.to_human_list(exports.smiley_strings());

  exports.history_path = function(path) {
    var p;
    p = exports.path_split(path);
    if (p.head) {
      return p.head + "/." + p.tail + ".sage-history";
    } else {
      return "." + p.tail + ".sage-history";
    }
  };

  _done = function() {
    var args, f, n, start_time;
    n = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    start_time = new Date();
    f = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (n !== 1) {
        try {
          args = [JSON.stringify(args, null, n)];
        } catch (error) {

        }
      }
      return console.log.apply(console, ["*** TOTALLY DONE! (" + ((new Date() - start_time) / 1000) + "s since start) "].concat(slice.call(args)));
    };
    if (args.length > 0) {
      return f.apply(null, args);
    } else {
      return f;
    }
  };

  exports.done = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _done.apply(null, [0].concat(slice.call(args)));
  };

  exports.done1 = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _done.apply(null, [1].concat(slice.call(args)));
  };

  exports.done2 = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return _done.apply(null, [2].concat(slice.call(args)));
  };

  smc_logger_timestamp = smc_logger_timestamp_last = smc_start_time = new Date().getTime() / 1000.0;

  exports.get_start_time_ts = function() {
    return new Date(smc_start_time * 1000);
  };

  exports.get_uptime = function() {
    return seconds2hms((new Date().getTime() / 1000.0) - smc_start_time);
  };

  exports.log = function() {
    var args, dt, msg, prompt, ref1, t;
    smc_logger_timestamp = new Date().getTime() / 1000.0;
    t = seconds2hms(smc_logger_timestamp - smc_start_time);
    dt = seconds2hms(smc_logger_timestamp - smc_logger_timestamp_last);
    ref1 = Array.prototype.slice.call(arguments), msg = ref1[0], args = 2 <= ref1.length ? slice.call(ref1, 1) : [];
    prompt = "[" + t + " Δ " + dt + "]";
    if (_.isString(msg)) {
      prompt = prompt + " " + msg;
      console.log_original.apply(console, [prompt].concat(slice.call(args)));
    } else {
      console.log_original.apply(console, [prompt, msg].concat(slice.call(args)));
    }
    return smc_logger_timestamp_last = smc_logger_timestamp;
  };

  exports.wrap_log = function() {
    if (!exports.RUNNING_IN_NODE && (typeof window !== "undefined" && window !== null)) {
      window.console.log_original = window.console.log;
      return window.console.log = exports.log;
    }
  };

  exports.this_fails = function() {
    return exports.op_to_function('noop');
  };

  exports.console_init_filename = function(fn) {
    var x;
    x = exports.path_split(fn);
    x.tail = "." + x.tail + ".init";
    if (x.head === '') {
      return x.tail;
    }
    return [x.head, x.tail].join("/");
  };

  exports.has_null_leaf = has_null_leaf = function(obj) {
    var k, v;
    for (k in obj) {
      v = obj[k];
      if (v === null || (typeof v === 'object' && has_null_leaf(v))) {
        return true;
      }
    }
    return false;
  };

  exports.peer_grading = function(students, N) {
    var L, asmnt, i, idx, k, ref1, s_random, v, z;
    if (N == null) {
      N = 2;
    }
    if (N <= 0) {
      throw "Number of peer assigments must be at least 1";
    }
    if (students.length <= N) {
      throw "You need at least " + (N + 1) + " students";
    }
    asmnt = {};
    students.forEach(function(s) {
      return asmnt[s] = [];
    });
    s_random = underscore.shuffle(students);
    L = students.length;
    for (i = z = 0, ref1 = L; 0 <= ref1 ? z < ref1 : z > ref1; i = 0 <= ref1 ? ++z : --z) {
      asmnt[s_random[i]] = (function() {
        var i1, ref2, results;
        results = [];
        for (idx = i1 = 1, ref2 = N; 1 <= ref2 ? i1 <= ref2 : i1 >= ref2; idx = 1 <= ref2 ? ++i1 : --i1) {
          results.push(s_random[(i + idx) % L]);
        }
        return results;
      })();
    }
    for (k in asmnt) {
      v = asmnt[k];
      asmnt[k] = underscore.sortBy(v, function(s) {
        return students.indexOf(s);
      });
    }
    return asmnt;
  };

  exports.peer_grading_demo = function(S, N) {
    var k, peer_grading, result, results, students, v, z;
    if (S == null) {
      S = 10;
    }
    if (N == null) {
      N = 2;
    }
    peer_grading = exports.peer_grading;
    students = (function() {
      results = [];
      for (var z = 0; 0 <= S ? z < S : z > S; 0 <= S ? z++ : z--){ results.push(z); }
      return results;
    }).apply(this);
    students = (function() {
      var i1, len3, results1;
      results1 = [];
      for (i1 = 0, len3 = students.length; i1 < len3; i1++) {
        s = students[i1];
        results1.push("S-" + s);
      }
      return results1;
    })();
    result = peer_grading(students, N = N);
    console.log(S + " students graded by " + N + " peers");
    for (k in result) {
      v = result[k];
      console.log(k + " ←→ " + v);
    }
    return result;
  };

  exports.ticket_id_to_ticket_url = function(tid) {
    return "https://sagemathcloud.zendesk.com/requests/" + tid;
  };

  exports.transform_get_url = function(url) {
    var URL_TRANSFORMS, a, args, b, command, ref1;
    URL_TRANSFORMS = {
      'http://trac.sagemath.org/attachment/ticket/': 'http://trac.sagemath.org/raw-attachment/ticket/',
      'http://nbviewer.jupyter.org/url/': 'http://',
      'http://nbviewer.jupyter.org/urls/': 'https://'
    };
    if (exports.startswith(url, "https://github.com/")) {
      if (url.indexOf('/blob/') !== -1) {
        url = url.replace("https://github.com", "https://raw.githubusercontent.com").replace("/blob/", "/");
      } else if (((ref1 = url.split('://')[1]) != null ? ref1.split('/').length : void 0) === 3) {
        url += '.git';
      }
    }
    if (exports.startswith(url, 'git@github.com:')) {
      command = 'git';
      args = ['clone', url];
    } else if (url.slice(url.length - 4) === ".git") {
      command = 'git';
      args = ['clone', url];
    } else {
      for (a in URL_TRANSFORMS) {
        b = URL_TRANSFORMS[a];
        url = url.replace(a, b);
      }
      if (exports.startswith(url, 'http://nbviewer.jupyter.org/github/')) {
        url = url.replace('http://nbviewer.jupyter.org/github/', 'https://raw.githubusercontent.com/');
        url = url.replace("/blob/", "/");
      }
      command = 'wget';
      args = [url];
    }
    return {
      command: command,
      args: args
    };
  };

  exports.ensure_bound = function(x, min, max) {
    if (x < min) {
      return min;
    }
    if (x > max) {
      return max;
    }
    return x;
  };

  exports.path_to_tab = function(name) {
    return "editor-" + name;
  };

  exports.tab_to_path = function(name) {
    if ((name != null) && name.substring(0, 7) === "editor-") {
      return name.substring(7);
    }
  };

  exports.suggest_duplicate_filename = function(name) {
    var ending, ext, idx, idx_dash, idx_under, new_name, num, prfx, ref1, ref2;
    ref1 = exports.separate_file_extension(name), name = ref1.name, ext = ref1.ext;
    idx_dash = name.lastIndexOf('-');
    idx_under = name.lastIndexOf('_');
    idx = exports.max([idx_dash, idx_under]);
    new_name = null;
    if (idx > 0) {
      ref2 = [name.slice(0, idx + 1), name.slice(idx + 1)], prfx = ref2[0], ending = ref2[1];
      num = parseInt(ending);
      if (!Number.isNaN(num)) {
        new_name = "" + prfx + (num + 1);
      }
    }
    if (new_name == null) {
      new_name = name + "-1";
    }
    if ((ext != null ? ext.length : void 0) > 0) {
      new_name += "." + ext;
    }
    return new_name;
  };

  exports.set_local_storage = function(key, val) {
    var e;
    try {
      return localStorage[key] = val;
    } catch (error) {
      e = error;
      return console.warn("localStorage set error -- " + e);
    }
  };

  exports.get_local_storage = function(key) {
    var e;
    try {
      return localStorage[key];
    } catch (error) {
      e = error;
      return console.warn("localStorage get error -- " + e);
    }
  };

  exports.delete_local_storage = function(key) {
    var e;
    try {
      return delete localStorage[key];
    } catch (error) {
      e = error;
      return console.warn("localStorage delete error -- " + e);
    }
  };

  exports.has_local_storage = function() {
    var TEST, e;
    try {
      TEST = '__smc_test__';
      localStorage[TEST] = 'x';
      delete localStorage[TEST];
      return true;
    } catch (error) {
      e = error;
      return false;
    }
  };

  exports.local_storage_length = function() {
    var e;
    try {
      return localStorage.length;
    } catch (error) {
      e = error;
      return 0;
    }
  };

  exports.top_sort = function(DAG, opts) {
    var base1, child, curr_name, data, i1, len3, len4, name, node, num_edges, num_sources, omit_sources, parent_name, parents, path, ref1, source_names, z;
    if (opts == null) {
      opts = {
        omit_sources: false
      };
    }
    omit_sources = opts.omit_sources;
    source_names = [];
    num_edges = 0;
    data = {};
    for (name in DAG) {
      parents = DAG[name];
      if (data[name] == null) {
        data[name] = {};
      }
      node = data[name];
      node.name = name;
      if (node.children == null) {
        node.children = [];
      }
      node.parent_set = {};
      for (z = 0, len3 = parents.length; z < len3; z++) {
        parent_name = parents[z];
        node.parent_set[parent_name] = true;
        if (data[parent_name] == null) {
          data[parent_name] = {};
        }
        if ((base1 = data[parent_name]).children == null) {
          base1.children = [];
        }
        data[parent_name].children.push(node);
      }
      if (parents.length === 0) {
        source_names.push(name);
      } else {
        num_edges += parents.length;
      }
    }
    path = [];
    num_sources = source_names.length;
    while (source_names.length > 0) {
      curr_name = source_names.shift();
      path.push(curr_name);
      ref1 = data[curr_name].children;
      for (i1 = 0, len4 = ref1.length; i1 < len4; i1++) {
        child = ref1[i1];
        delete child.parent_set[curr_name];
        num_edges -= 1;
        if (exports.len(child.parent_set) === 0) {
          source_names.push(child.name);
        }
      }
    }
    if (num_sources === 0) {
      throw new Error("No sources were detected");
    }
    if (num_edges !== 0) {
      if (typeof window !== "undefined" && window !== null) {
        window._DAG = DAG;
      }
      throw new Error("Store has a cycle in its computed values");
    }
    if (omit_sources) {
      return path.slice(num_sources);
    } else {
      return path;
    }
  };

  exports.create_dependency_graph = (function(_this) {
    return function(object) {
      var DAG, name, ref1, written_func;
      DAG = {};
      for (name in object) {
        written_func = object[name];
        DAG[name] = (ref1 = written_func.dependency_names) != null ? ref1 : [];
      }
      return DAG;
    };
  })(this);

  exports.bind_objects = function(scope, arr_objects) {
    return underscore.map(arr_objects, (function(_this) {
      return function(object) {
        return underscore.mapObject(object, function(val) {
          var bound_func, original_toString;
          if (typeof val === 'function') {
            original_toString = val.toString();
            bound_func = val.bind(scope);
            bound_func.toString = function() {
              return original_toString;
            };
            Object.assign(bound_func, val);
            return bound_func;
          } else {
            return val;
          }
        });
      };
    })(this));
  };

  exports.remove_whitespace = function(s) {
    return s != null ? s.replace(/\s/g, '') : void 0;
  };

  exports.is_whitespace = function(s) {
    return (s != null ? s.trim().length : void 0) === 0;
  };

  exports.lstrip = function(s) {
    return s != null ? s.replace(/^\s*/g, "") : void 0;
  };

  exports.rstrip = function(s) {
    return s != null ? s.replace(/\s*$/g, "") : void 0;
  };

  exports.operators = ['!=', '<>', '<=', '>=', '==', '<', '>', '='];

  exports.op_to_function = function(op) {
    switch (op) {
      case '=':
      case '==':
        return function(a, b) {
          return a === b;
        };
      case '!=':
      case '<>':
        return function(a, b) {
          return a !== b;
        };
      case '<=':
        return function(a, b) {
          return a <= b;
        };
      case '>=':
        return function(a, b) {
          return a >= b;
        };
      case '<':
        return function(a, b) {
          return a < b;
        };
      case '>':
        return function(a, b) {
          return a > b;
        };
      default:
        throw Error("operator must be one of '" + (JSON.stringify(exports.operators)) + "'");
    }
  };

  exports.obj_key_subs = function(obj, subs) {
    var k, results, v;
    results = [];
    for (k in obj) {
      v = obj[k];
      s = subs[k];
      if (s != null) {
        delete obj[k];
        obj[s] = v;
      }
      if (typeof v === 'object') {
        results.push(exports.obj_key_subs(v, subs));
      } else if (typeof v === 'string') {
        s = subs[v];
        if (s != null) {
          results.push(obj[k] = s);
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  exports.sanitize_html_attributes = function($, node) {
    return $.each(node.attributes, function() {
      var attrName, attrValue;
      attrName = this.name;
      attrValue = this.value;
      if ((attrName != null ? attrName.indexOf('on') : void 0) === 0 || (attrValue != null ? attrValue.indexOf('javascript:') : void 0) === 0) {
        return $(node).removeAttr(attrName);
      }
    });
  };

}).call(this);
