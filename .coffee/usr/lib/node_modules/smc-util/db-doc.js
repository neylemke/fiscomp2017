
/*
Efficient local document-oriented database with complete history
recording backed by a backend database.

   - set(obj)    -- creates or modifies an object
   - delete(obj) -- delets all objects matching the spec
   - get(where)  -- get immutable list of 0 or more matching objects
   - get_one(where) -- get one matching object or undefined

This is the foundation for a distributed synchronized database.

DO **NOT** store anything that can't be converted from/to pure JSON.
In particular, do *NOT* store Date objects -- they will come back as
ISO strings and not be parsed.  See https://github.com/sagemathinc/cocalc/issues/1771
Instead use ms since epoch (or .toISOString()) for dates.  Please!!
 */

(function() {
  var DBDoc, Doc, EventEmitter, SyncDoc, defaults, immutable, json_stable, map_merge_patch, merge_set, misc, nonnull_cols, required, syncstring, to_key, underscore,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  immutable = require('immutable');

  underscore = require('underscore');

  syncstring = require('./syncstring');

  misc = require('./misc');

  required = misc.required, defaults = misc.defaults;

  EventEmitter = require('events').EventEmitter;

  json_stable = require('json-stable-stringify');

  to_key = function(s) {
    if (immutable.Map.isMap(s)) {
      s = s.toJS();
    }
    return json_stable(s);
  };

  exports.db_doc = function(opts) {
    opts = defaults(opts, {
      primary_keys: required,
      string_cols: []
    });
    if (!misc.is_array(opts.primary_keys)) {
      throw Error("primary_keys must be an array");
    }
    if (!misc.is_array(opts.string_cols)) {
      throw Error("_string_cols must be an array");
    }
    return new DBDoc(opts.primary_keys, opts.string_cols);
  };

  exports.from_obj = function(opts) {
    var records;
    opts = defaults(opts, {
      obj: required,
      primary_keys: required,
      string_cols: []
    });
    if (!misc.is_array(opts.obj)) {
      throw Error("obj must be an array");
    }
    records = immutable.fromJS(opts.obj);
    return new DBDoc(opts.primary_keys, opts.string_cols, records);
  };

  exports.from_str = function(opts) {
    var e, j, len1, line, obj, ref;
    opts = defaults(opts, {
      str: required,
      primary_keys: required,
      string_cols: []
    });
    if (!misc.is_string(opts.str)) {
      throw Error("obj must be a string");
    }
    obj = [];
    ref = opts.str.split('\n');
    for (j = 0, len1 = ref.length; j < len1; j++) {
      line = ref[j];
      if (line.length > 0) {
        try {
          obj.push(misc.from_json(line));
        } catch (error) {
          e = error;
          console.warn("CORRUPT db-doc string: " + e + " -- skipping '" + line + "'");
        }
      }
    }
    return exports.from_obj({
      obj: obj,
      primary_keys: opts.primary_keys,
      string_cols: opts.string_cols
    });
  };

  merge_set = function(obj, change) {
    change.map(function(v, k) {
      if (v === null || (v == null)) {
        obj = obj["delete"](k);
      } else {
        obj = obj.set(k, v);
      }
    });
    return obj;
  };

  map_merge_patch = function(obj1, obj2) {
    var change, key, val1, val2;
    change = {};
    for (key in obj1) {
      val1 = obj1[key];
      val2 = obj2[key];
      if (underscore.isEqual(val1, val2)) {

      } else if (val2 == null) {
        change[key] = null;
      } else {
        change[key] = val2;
      }
    }
    for (key in obj2) {
      val2 = obj2[key];
      if (obj1[key] != null) {
        continue;
      }
      change[key] = val2;
    }
    return change;
  };

  nonnull_cols = function(f) {
    return f.filter((function(_this) {
      return function(v, k) {
        return v !== null;
      };
    })(this));
  };

  DBDoc = (function() {
    function DBDoc(_primary_keys, _string_cols, _records, _everything, _indexes, _changes) {
      var field, n;
      this._primary_keys = _primary_keys;
      this._string_cols = _string_cols;
      this._records = _records;
      this._everything = _everything;
      this._indexes = _indexes;
      this._changes = _changes;
      this.changed_keys = bind(this.changed_keys, this);
      this.apply_patch = bind(this.apply_patch, this);
      this.make_patch = bind(this.make_patch, this);
      this._primary_key_part = bind(this._primary_key_part, this);
      this.to_str = bind(this.to_str, this);
      this.to_obj = bind(this.to_obj, this);
      this.equals = bind(this.equals, this);
      this.get_one = bind(this.get_one, this);
      this.get = bind(this.get, this);
      this["delete"] = bind(this["delete"], this);
      this.set = bind(this.set, this);
      this._parse = bind(this._parse, this);
      this._select = bind(this._select, this);
      this._process_cols = bind(this._process_cols, this);
      this._primary_key_cols = bind(this._primary_key_cols, this);
      this.changes = bind(this.changes, this);
      this.reset_changes = bind(this.reset_changes, this);
      this._primary_keys = this._process_cols(this._primary_keys);
      this._string_cols = this._process_cols(this._string_cols);
      if (this._records == null) {
        this._records = immutable.List();
      }
      if (this._everything == null) {
        this._everything = immutable.Set((function() {
          var j, ref, results;
          results = [];
          for (n = j = 0, ref = this._records.size; 0 <= ref ? j < ref : j > ref; n = 0 <= ref ? ++j : --j) {
            if (this._records.get(n) != null) {
              results.push(n);
            }
          }
          return results;
        }).call(this)).sort();
      }
      if (this._indexes == null) {
        this._indexes = immutable.Map();
        for (field in this._primary_keys) {
          this._indexes = this._indexes.set(field, immutable.Map());
        }
        n = 0;
        this._records.map((function(_this) {
          return function(record, n) {
            _this._indexes.map(function(index, field) {
              var k, matches, val;
              val = record.get(field);
              if (val != null) {
                k = to_key(val);
                matches = index.get(k);
                if (matches != null) {
                  matches = matches.add(n).sort();
                } else {
                  matches = immutable.Set([n]);
                }
                _this._indexes = _this._indexes.set(field, index.set(k, matches));
              }
            });
          };
        })(this));
      }
      this.size = this._everything.size;
      if (this._changes == null) {
        this.reset_changes();
      }
    }

    DBDoc.prototype.reset_changes = function() {
      return this._changes = {
        changes: immutable.Set(),
        from_db: this
      };
    };

    DBDoc.prototype.changes = function() {
      return this._changes;
    };

    DBDoc.prototype._primary_key_cols = function(f) {
      return f.filter((function(_this) {
        return function(v, k) {
          return _this._primary_keys[k];
        };
      })(this));
    };

    DBDoc.prototype._process_cols = function(v) {
      var field, j, len1, p;
      if (misc.is_array(v)) {
        p = {};
        for (j = 0, len1 = v.length; j < len1; j++) {
          field = v[j];
          p[field] = true;
        }
        return p;
      } else if (!misc.is_object(v)) {
        throw Error("primary_keys must be a map or array");
      }
      return v;
    };

    DBDoc.prototype._select = function(where) {
      var field, index, len, result, v, value;
      if (immutable.Map.isMap(where)) {
        where = where.toJS();
      }
      len = misc.len(where);
      result = void 0;
      for (field in where) {
        value = where[field];
        index = this._indexes.get(field);
        if (index == null) {
          throw Error("field '" + field + "' must be a primary key");
        }
        v = index.get(to_key(value));
        if (v == null) {
          return immutable.Set();
        }
        if (len === 1) {
          return v;
        }
        if (result != null) {
          result = result.intersect(v);
        } else {
          result = v;
        }
      }
      if (result == null) {
        return this._everything;
      } else {
        return result;
      }
    };

    DBDoc.prototype._parse = function(obj) {
      var field, set, val, where;
      if (immutable.Map.isMap(obj)) {
        obj = obj.toJS();
      }
      if (!misc.is_object(obj)) {
        throw Error("obj must be a Javascript object");
      }
      where = {};
      set = {};
      for (field in obj) {
        val = obj[field];
        if (this._primary_keys[field] != null) {
          if (val != null) {
            where[field] = val;
          }
        } else {
          set[field] = val;
        }
      }
      return {
        where: where,
        set: set,
        obj: obj
      };
    };

    DBDoc.prototype.set = function(obj) {
      var before, change, changes, cur, everything, field, index, indexes, j, k, len1, matches, n, new_val, record, records, ref, ref1, ref2, set, val, value, where, x, z;
      if (misc.is_array(obj)) {
        z = this;
        for (j = 0, len1 = obj.length; j < len1; j++) {
          x = obj[j];
          z = z.set(x);
        }
        return z;
      }
      ref = this._parse(obj), where = ref.where, set = ref.set, obj = ref.obj;
      matches = this._select(where);
      changes = this._changes.changes;
      n = matches != null ? matches.first() : void 0;
      if (n != null) {
        before = record = this._records.get(n);
        for (field in set) {
          value = set[field];
          if (value === null) {
            record = record["delete"](field);
          } else {
            if (this._string_cols[field] && misc.is_array(value)) {
              record = record.set(field, syncstring.apply_patch(value, (ref1 = before.get(field)) != null ? ref1 : '')[0]);
            } else {
              cur = record.get(field);
              change = immutable.fromJS(value);
              if (immutable.Map.isMap(cur) && immutable.Map.isMap(change)) {
                new_val = merge_set(cur, change);
              } else {
                new_val = change;
              }
              record = record.set(field, new_val);
            }
          }
        }
        if (!before.equals(record)) {
          changes = changes.add(this._primary_key_cols(record));
          return new DBDoc(this._primary_keys, this._string_cols, this._records.set(n, record), this._everything, this._indexes, {
            changes: changes,
            from_db: this._changes.from_db
          });
        } else {
          return this;
        }
      } else {
        for (field in this._string_cols) {
          if ((obj[field] != null) && misc.is_array(obj[field])) {
            obj = misc.copy_without(obj, field);
          }
        }
        record = nonnull_cols(immutable.fromJS(obj));
        changes = changes.add(this._primary_key_cols(record));
        records = this._records.push(record);
        n = records.size - 1;
        everything = this._everything.add(n);
        indexes = this._indexes;
        for (field in this._primary_keys) {
          val = obj[field];
          if ((val != null) && val !== null) {
            index = (ref2 = indexes.get(field)) != null ? ref2 : immutable.Map();
            k = to_key(val);
            matches = index.get(k);
            if (matches != null) {
              matches = matches.add(n).sort();
            } else {
              matches = immutable.Set([n]);
            }
            indexes = indexes.set(field, index.set(k, matches));
          }
        }
        return new DBDoc(this._primary_keys, this._string_cols, records, everything, indexes, {
          changes: changes,
          from_db: this._changes.from_db
        });
      }
    };

    DBDoc.prototype["delete"] = function(where) {
      var changes, everything, field, index, indexes, j, len1, records, remove, x, z;
      if (misc.is_array(where)) {
        z = this;
        for (j = 0, len1 = where.length; j < len1; j++) {
          x = where[j];
          z = z["delete"](x);
        }
        return z;
      }
      if (this._everything.size === 0) {
        return this;
      }
      changes = this._changes.changes;
      remove = this._select(where);
      if (remove.size === this._everything.size) {
        changes = changes.union(this._records.filter((function(_this) {
          return function(record) {
            return record != null;
          };
        })(this)).map(this._primary_key_cols));
        return new DBDoc(this._primary_keys, this._string_cols, void 0, void 0, void 0, {
          changes: changes,
          from_db: this._changes.from_db
        });
      }
      indexes = this._indexes;
      for (field in this._primary_keys) {
        index = indexes.get(field);
        if (index == null) {
          continue;
        }
        remove.map((function(_this) {
          return function(n) {
            var k, matches, record, val;
            record = _this._records.get(n);
            val = record.get(field);
            if (val != null) {
              k = to_key(val);
              matches = index.get(k)["delete"](n);
              if (matches.size === 0) {
                index = index["delete"](k);
              } else {
                index = index.set(k, matches);
              }
              indexes = indexes.set(field, index);
            }
          };
        })(this));
      }
      records = this._records;
      remove.map((function(_this) {
        return function(n) {
          changes = changes.add(_this._primary_key_cols(records.get(n)));
          return records = records.set(n, void 0);
        };
      })(this));
      everything = this._everything.subtract(remove);
      return new DBDoc(this._primary_keys, this._string_cols, records, everything, indexes, {
        changes: changes,
        from_db: this._changes.from_db
      });
    };

    DBDoc.prototype.get = function(where) {
      var matches;
      matches = this._select(where);
      if (matches == null) {
        return immutable.List();
      }
      return this._records.filter(function(x, n) {
        return matches.includes(n);
      });
    };

    DBDoc.prototype.get_one = function(where) {
      var matches;
      matches = this._select(where);
      if (matches == null) {
        return;
      }
      return this._records.get(matches.first());
    };

    DBDoc.prototype.equals = function(other) {
      if (this._records === other._records) {
        return true;
      }
      if (this.size !== other.size) {
        return false;
      }
      return immutable.Set(this._records).add(void 0).equals(immutable.Set(other._records).add(void 0));
    };

    DBDoc.prototype.to_obj = function() {
      return this.get().toJS();
    };

    DBDoc.prototype.to_str = function() {
      var x;
      if (this._to_str_cache != null) {
        return this._to_str_cache;
      }
      return this._to_str_cache = ((function() {
        var j, len1, ref, results;
        ref = this.to_obj();
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          x = ref[j];
          results.push(misc.to_json(x));
        }
        return results;
      }).call(this)).join('\n');
    };

    DBDoc.prototype._primary_key_part = function(x) {
      var k, v, where;
      where = {};
      for (k in x) {
        v = x[k];
        if (this._primary_keys[k]) {
          where[k] = v;
        }
      }
      return where;
    };

    DBDoc.prototype.make_patch = function(other) {
      var add, changed, common, deletes, inserts, k0, k1, patch, remove, t0, t1, v;
      if (other.size === 0) {
        return [-1, [{}]];
      }
      t0 = immutable.Set(this._records);
      t1 = immutable.Set(other._records);
      common = t0.intersect(t1).add(void 0);
      t0 = t0.subtract(common);
      t1 = t1.subtract(common);
      if (t0.size === 0) {
        return [1, t1.toJS()];
      }
      if (t1.size === 0) {
        v = [];
        t0.map((function(_this) {
          return function(x) {
            v.push(_this._primary_key_part(x.toJS()));
          };
        })(this));
        return [-1, v];
      }
      k0 = t0.map(this._primary_key_cols);
      k1 = t1.map(this._primary_key_cols);
      add = [];
      remove = void 0;
      deletes = k0.subtract(k1);
      if (deletes.size > 0) {
        remove = deletes.toJS();
      }
      inserts = k1.subtract(k0);
      if (inserts.size > 0) {
        inserts.map((function(_this) {
          return function(k) {
            add.push(other.get_one(k.toJS()).toJS());
          };
        })(this));
      }
      changed = k1.intersect(k0);
      if (changed.size > 0) {
        changed.map((function(_this) {
          return function(k) {
            var from, obj, obj0, to;
            obj = k.toJS();
            obj0 = _this._primary_key_part(obj);
            from = _this.get_one(obj0).toJS();
            to = other.get_one(obj0).toJS();
            for (k in from) {
              if (to[k] == null) {
                obj[k] = null;
              }
            }
            for (k in to) {
              v = to[k];
              if (!underscore.isEqual(from[k], v)) {
                if (_this._string_cols[k] && (from[k] != null) && (v != null)) {
                  obj[k] = syncstring.make_patch(from[k], v);
                } else if (misc.is_object(from[k]) && misc.is_object(v)) {
                  obj[k] = map_merge_patch(from[k], v);
                } else {
                  obj[k] = v;
                }
              }
            }
            add.push(obj);
          };
        })(this));
      }
      patch = [];
      if (remove != null) {
        patch.push(-1);
        patch.push(remove);
      }
      if (add.length > 0) {
        patch.push(1);
        patch.push(add);
      }
      return patch;
    };

    DBDoc.prototype.apply_patch = function(patch) {
      var db, i;
      i = 0;
      db = this;
      while (i < patch.length) {
        if (patch[i] === -1) {
          db = db["delete"](patch[i + 1]);
        } else if (patch[i] === 1) {
          db = db.set(patch[i + 1]);
        }
        i += 2;
      }
      return db;
    };

    DBDoc.prototype.changed_keys = function(other) {
      var common, k0, k1, t0, t1;
      if (this._records === (other != null ? other._records : void 0)) {
        return immutable.Set();
      }
      t0 = immutable.Set(this._records).filter(function(x) {
        return x != null;
      });
      if (other == null) {
        return t0.map(this._primary_key_cols);
      }
      t1 = immutable.Set(other._records).filter(function(x) {
        return x != null;
      });
      common = t0.intersect(t1);
      t0 = t0.subtract(common);
      t1 = t1.subtract(common);
      k0 = t0.map(this._primary_key_cols);
      k1 = t1.map(this._primary_key_cols);
      return k0.union(k1);
    };

    return DBDoc;

  })();

  Doc = (function() {
    function Doc(_db) {
      this._db = _db;
      this.get_one = bind(this.get_one, this);
      this.get = bind(this.get, this);
      this.reset_changes = bind(this.reset_changes, this);
      this.changes = bind(this.changes, this);
      this.make_patch = bind(this.make_patch, this);
      this.apply_patch = bind(this.apply_patch, this);
      this.is_equal = bind(this.is_equal, this);
      this.to_str = bind(this.to_str, this);
      if (this._db == null) {
        throw Error("@_db must be defined");
      }
    }

    Doc.prototype.to_str = function() {
      return this._db.to_str();
    };

    Doc.prototype.is_equal = function(other) {
      return this._db.equals(other._db);
    };

    Doc.prototype.apply_patch = function(patch) {
      return new Doc(this._db.apply_patch(patch));
    };

    Doc.prototype.make_patch = function(other) {
      if ((this._db == null) || ((other != null ? other._db : void 0) == null)) {
        return;
      }
      return this._db.make_patch(other._db);
    };

    Doc.prototype.changes = function() {
      return this._db.changes();
    };

    Doc.prototype.reset_changes = function() {
      this._db.reset_changes();
    };

    Doc.prototype.get = function(where) {
      var ref;
      return (ref = this._db) != null ? ref.get(where) : void 0;
    };

    Doc.prototype.get_one = function(where) {
      var ref;
      return (ref = this._db) != null ? ref.get_one(where) : void 0;
    };

    return Doc;

  })();

  SyncDoc = (function(superClass) {
    extend(SyncDoc, superClass);

    function SyncDoc(opts) {
      var from_str;
      opts = defaults(opts, {
        client: required,
        project_id: void 0,
        path: void 0,
        save_interval: void 0,
        patch_interval: void 0,
        file_use_interval: void 0,
        cursors: false,
        primary_keys: required,
        string_cols: []
      });
      from_str = function(str) {
        var db;
        db = exports.from_str({
          str: str,
          primary_keys: opts.primary_keys,
          string_cols: opts.string_cols
        });
        return new Doc(db);
      };
      SyncDoc.__super__.constructor.call(this, {
        string_id: opts.id,
        client: opts.client,
        project_id: opts.project_id,
        path: opts.path,
        save_interval: opts.save_interval,
        patch_interval: opts.patch_interval,
        file_use_interval: opts.file_use_interval,
        cursors: opts.cursors,
        from_str: from_str,
        doctype: {
          type: 'db',
          patch_format: 1,
          opts: {
            primary_keys: opts.primary_keys,
            string_cols: opts.string_cols
          }
        }
      });
    }

    return SyncDoc;

  })(syncstring.SyncDoc);

  exports.SyncDB = (function(superClass) {
    extend(SyncDB, superClass);

    function SyncDB(opts) {
      this.get_cursors = bind(this.get_cursors, this);
      this.set_cursor_locs = bind(this.set_cursor_locs, this);
      this.revert = bind(this.revert, this);
      this.in_undo_mode = bind(this.in_undo_mode, this);
      this.exit_undo_mode = bind(this.exit_undo_mode, this);
      this.redo = bind(this.redo, this);
      this.undo = bind(this.undo, this);
      this.count = bind(this.count, this);
      this.get_read_only = bind(this.get_read_only, this);
      this.wait_until_read_only_known = bind(this.wait_until_read_only_known, this);
      this.load_full_history = bind(this.load_full_history, this);
      this.has_full_history = bind(this.has_full_history, this);
      this.show_history = bind(this.show_history, this);
      this.time_sent = bind(this.time_sent, this);
      this.account_id = bind(this.account_id, this);
      this.version = bind(this.version, this);
      this.all_versions = bind(this.all_versions, this);
      this.last_changed = bind(this.last_changed, this);
      this.versions = bind(this.versions, this);
      this["delete"] = bind(this["delete"], this);
      this.get_one = bind(this.get_one, this);
      this.get = bind(this.get, this);
      this.set = bind(this.set, this);
      this.get_project_id = bind(this.get_project_id, this);
      this.get_path = bind(this.get_path, this);
      this.get_doc = bind(this.get_doc, this);
      this.set_doc = bind(this.set_doc, this);
      this.save_asap = bind(this.save_asap, this);
      this.save = bind(this.save, this);
      this.sync = bind(this.sync, this);
      this.is_closed = bind(this.is_closed, this);
      this.close = bind(this.close, this);
      this._on_change = bind(this._on_change, this);
      this.is_read_only = bind(this.is_read_only, this);
      this.has_uncommitted_changes = bind(this.has_uncommitted_changes, this);
      this.has_unsaved_changes = bind(this.has_unsaved_changes, this);
      this._check = bind(this._check, this);
      this._path = opts.path;
      if (opts.change_throttle) {
        this._on_change = underscore.throttle(this._on_change, opts.change_throttle);
      }
      delete opts.change_throttle;
      this._doc = new SyncDoc(opts);
      this._first_change_event = true;
      this._doc.on('change', this._on_change);
      this._doc.on('metadata-change', (function(_this) {
        return function() {
          return _this.emit('metadata-change');
        };
      })(this));
      this._doc.on('before-change', (function(_this) {
        return function() {
          return _this.emit('before-change');
        };
      })(this));
      this._doc.on('sync', (function(_this) {
        return function() {
          return _this.emit('sync');
        };
      })(this));
      if (opts.cursors) {
        this._doc.on('cursor_activity', (function(_this) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return _this.emit.apply(_this, ['cursor_activity'].concat(slice.call(args)));
          };
        })(this));
      }
      this._doc.on('connected', (function(_this) {
        return function() {
          return _this.emit('connected');
        };
      })(this));
      this._doc.on('init', (function(_this) {
        return function(err) {
          return _this.emit('init', err);
        };
      })(this));
      this._doc.on('save_to_disk_project', (function(_this) {
        return function(err) {
          return _this.emit('save_to_disk_project', err);
        };
      })(this));
      this.setMaxListeners(100);
    }

    SyncDB.prototype._check = function() {
      if (this._doc == null) {
        throw Error("SyncDB('" + this._path + "') is closed");
      }
    };

    SyncDB.prototype.has_unsaved_changes = function() {
      this._check();
      return this._doc.has_unsaved_changes();
    };

    SyncDB.prototype.has_uncommitted_changes = function() {
      this._check();
      return this._doc.has_uncommitted_changes();
    };

    SyncDB.prototype.is_read_only = function() {
      this._check();
      return this._doc.get_read_only();
    };

    SyncDB.prototype._on_change = function() {
      var changes, db, from_db, ref;
      if (this._doc == null) {
        return;
      }
      db = this._doc.get_doc()._db;
      if (this._last_db == null) {
        changes = db.changed_keys();
      } else {
        ref = this._doc.get_doc().changes(), changes = ref.changes, from_db = ref.from_db;
        this._doc.get_doc().reset_changes();
        if (from_db !== this._last_db) {
          changes = db.changed_keys(this._last_db);
        }
      }
      if (changes.size > 0 || this._first_change_event) {
        this.emit('change', changes);
      }
      this._last_db = db;
      return delete this._first_change_event;
    };

    SyncDB.prototype.close = function() {
      var ref;
      if (this._doc == null) {
        return;
      }
      this.removeAllListeners();
      if ((ref = this._doc) != null) {
        ref.close();
      }
      return delete this._doc;
    };

    SyncDB.prototype.is_closed = function() {
      return this._doc == null;
    };

    SyncDB.prototype.sync = function(cb) {
      this._check();
      this._doc.save(cb);
    };

    SyncDB.prototype.save = function(cb) {
      this._check();
      this._doc.save_to_disk(cb);
    };

    SyncDB.prototype.save_asap = function(cb) {
      this._check();
      this._doc.save_asap(cb);
    };

    SyncDB.prototype.set_doc = function(value) {
      this._check();
      this._doc.set_doc(value);
    };

    SyncDB.prototype.get_doc = function() {
      this._check();
      return this._doc.get_doc();
    };

    SyncDB.prototype.get_path = function() {
      this._check();
      return this._doc.get_path();
    };

    SyncDB.prototype.get_project_id = function() {
      return this._doc.get_project_id();
    };

    SyncDB.prototype.set = function(obj, save) {
      if (save == null) {
        save = true;
      }
      if (this._doc == null) {
        return;
      }
      this._doc.set_doc(new Doc(this._doc.get_doc()._db.set(obj)));
      if (save) {
        this._doc.save();
      }
      this._on_change();
    };

    SyncDB.prototype.get = function(where, time) {
      var d;
      if (this._doc == null) {
        return immutable.List();
      }
      if (time != null) {
        d = this._doc.version(time);
      } else {
        d = this._doc.get_doc();
      }
      if (d == null) {
        return;
      }
      return d._db.get(where);
    };

    SyncDB.prototype.get_one = function(where, time) {
      var d;
      if (this._doc == null) {
        return;
      }
      if (time != null) {
        d = this._doc.version(time);
      } else {
        d = this._doc.get_doc();
      }
      if (d == null) {
        return;
      }
      return d._db.get_one(where);
    };

    SyncDB.prototype["delete"] = function(where, save) {
      var d;
      if (save == null) {
        save = true;
      }
      if (this._doc == null) {
        return;
      }
      d = this._doc.get_doc();
      if (d == null) {
        return;
      }
      this._doc.set_doc(new Doc(d._db["delete"](where)));
      if (save) {
        this._doc.save();
      }
      this._on_change();
    };

    SyncDB.prototype.versions = function() {
      this._check();
      return this._doc.versions();
    };

    SyncDB.prototype.last_changed = function() {
      this._check();
      return this._doc.last_changed();
    };

    SyncDB.prototype.all_versions = function() {
      this._check();
      return this._doc.all_versions();
    };

    SyncDB.prototype.version = function(t) {
      this._check();
      return this._doc.version(t);
    };

    SyncDB.prototype.account_id = function(t) {
      this._check();
      return this._doc.account_id(t);
    };

    SyncDB.prototype.time_sent = function(t) {
      this._check();
      return this._doc.time_sent(t);
    };

    SyncDB.prototype.show_history = function(opts) {
      this._check();
      return this._doc.show_history(opts);
    };

    SyncDB.prototype.has_full_history = function() {
      this._check();
      return this._doc.has_full_history();
    };

    SyncDB.prototype.load_full_history = function(cb) {
      this._check();
      return this._doc.load_full_history(cb);
    };

    SyncDB.prototype.wait_until_read_only_known = function(cb) {
      this._check();
      return this._doc.wait_until_read_only_known(cb);
    };

    SyncDB.prototype.get_read_only = function() {
      this._check();
      return this._doc.get_read_only();
    };

    SyncDB.prototype.count = function() {
      this._check();
      return this._doc.get_doc()._db.size;
    };

    SyncDB.prototype.undo = function() {
      this._check();
      this._doc.set_doc(this._doc.undo());
      this._doc.save();
      this._on_change();
    };

    SyncDB.prototype.redo = function() {
      this._check();
      this._doc.set_doc(this._doc.redo());
      this._doc.save();
      this._on_change();
    };

    SyncDB.prototype.exit_undo_mode = function() {
      this._check();
      return this._doc.exit_undo_mode();
    };

    SyncDB.prototype.in_undo_mode = function() {
      this._check();
      return this._doc.in_undo_mode();
    };

    SyncDB.prototype.revert = function(version) {
      this._check();
      this._doc.revert(version);
      this._doc.save();
    };

    SyncDB.prototype.set_cursor_locs = function(locs) {
      this._check();
      this._doc.set_cursor_locs(locs);
    };

    SyncDB.prototype.get_cursors = function() {
      var ref;
      return (ref = this._doc) != null ? ref.get_cursors() : void 0;
    };

    return SyncDB;

  })(EventEmitter);

  exports.open_existing_sync_document = function(opts) {
    opts = defaults(opts, {
      client: required,
      project_id: required,
      path: required,
      cb: required
    });
    return opts.client.query({
      query: {
        syncstrings: {
          project_id: opts.project_id,
          path: opts.path,
          doctype: null
        }
      },
      cb: function(err, resp) {
        var doc, doctype, opts2, ref, ref1;
        if (err) {
          opts.cb(err);
          return;
        }
        if (resp.event === 'error') {
          opts.cb(resp.error);
          return;
        }
        if (((ref = resp.query) != null ? ref.syncstrings : void 0) == null) {
          opts.cb("no document '" + opts.path + "' in project '" + opts.project_id + "'");
          return;
        }
        doctype = JSON.parse((ref1 = resp.query.syncstrings.doctype) != null ? ref1 : '{"type":"string"}');
        opts2 = {
          project_id: opts.project_id,
          path: opts.path
        };
        if (doctype.opts != null) {
          opts2 = misc.merge(opts2, doctype.opts);
        }
        doc = opts.client["sync_" + doctype.type](opts2);
        return opts.cb(void 0, doc);
      }
    });
  };

}).call(this);
