
/*
CoCalc, Copyright (C) 2016, Sagemath Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

---

SYNCHRONIZED TABLE -- defined by an object query

    - Do a query against a PostgreSQL table using our object query description.
    - Synchronization with the backend database is done automatically.

   Methods:
      - constructor(query): query = the name of a table (or a more complicated object)

      - set(map):  Set the given keys of map to their values; one key must be
                   the primary key for the table.  NOTE: Computed primary keys will
                   get automatically filled in; these are keys in schema.coffee,
                   where the set query looks like this say:
                      (obj, db) -> db.sha1(obj.project_id, obj.path)
      - get():     Current value of the query, as an immutable.js Map from
                   the primary key to the records, which are also immutable.js Maps.
      - get(key):  The record with given key, as an immutable Map.
      - get(keys): Immutable Map from given keys to the corresponding records.
      - get_one(): Returns one record as an immutable Map (useful if there
                   is only one record)

      - close():   Frees up resources, stops syncing, don't use object further

   Events:
      - 'before-change': fired right before (and in the same event loop) actually
                  applying remote incoming changes
      - 'change', [array of string primary keys] : fired any time the value of the query result
                 changes, *including* if changed by calling set on this object.
                 Also, called with empty list on first connection if there happens
                 to be nothing in this table.   If the primary key is not a string it is
                 converted to a JSON string.
      - 'disconnected': fired when table is disconnected from the server for some reason
      - 'connected': fired when table has successfully connected and finished initializing
                     and is ready to use
      - 'saved', [array of saved objects]: fired after confirmed successful save of objects to backend

STATES:

A SyncTable is a finite state machine as follows:

                          -------------------<------------------
                         \|/                                   |
    [connecting] --> [connected]  -->  [disconnected]  --> [reconnecting]

Also, there is a final state called 'closed', that the SyncTable moves to when
it will not be used further; this frees up all connections and used memory.
The table can't be used after it is closed.   The only way to get to the
closed state is to explicitly call close() on the table; otherwise, the
table will keep attempting to connect and work, until it works.

    (anything)  --> [closed]



- connecting   -- connecting to the backend, and have never connected before.

- connected    -- successfully connected to the backend, initialized, and receiving updates.

- disconnected -- table was successfully initialized, but the network connection
                  died. Can still takes writes, but they will never try to save to
                  the backend.  Waiting to reconnect when user connects back to the backend.

- reconnecting -- client just reconnected to the backend, so this table is now trying
                  to get the full current state of the table and initialize a changefeed.

- closed       -- table is closed, and memory/connections used by the table is freed.


WORRY: what if the user does a set and connecting (or reconnecting) takes a long time, e.g., suspend
a laptop, then resume?  The changes may get saved... a month later.  For some things, e.g., logs,
this could be fine.  However, on reconnect, the first thing is that complete upstream state of
table is set on server version of table, so reconnecting user only sends its changes if upstream
hasn't changed anything in that same record.
 */

(function() {
  var DEBUG, EventEmitter, Plug, SyncTable, async, defaults, global_cache_decref, immutable, json_stable_stringify, misc, required, schema, synctables, to_key, underscore,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  DEBUG = false;

  exports.set_debug = function(x) {
    return DEBUG = !!x;
  };

  EventEmitter = require('events').EventEmitter;

  immutable = require('immutable');

  async = require('async');

  underscore = require('underscore');

  misc = require('./misc');

  schema = require('./schema');

  defaults = misc.defaults, required = misc.required;

  json_stable_stringify = require('json-stable-stringify');

  to_key = function(x) {
    if (typeof x === 'object') {
      return json_stable_stringify(x);
    } else {
      return x;
    }
  };

  Plug = (function() {
    function Plug(opts) {
      this.__try_to_connect_once = bind(this.__try_to_connect_once, this);
      this.connect = bind(this.connect, this);
      this.dbg = bind(this.dbg, this);
      this._opts = defaults(opts, {
        name: 'plug',
        no_sign_in: required,
        client: required,
        connect: required
      });
      this.connect();
    }

    Plug.prototype.dbg = function(f) {
      return (function(_this) {
        return function() {};
      })(this);
    };

    Plug.prototype.connect = function(cb) {
      var dbg;
      dbg = this.dbg('connect');
      if (this._is_connecting) {
        dbg("already connecting");
        return;
      }
      this._is_connecting = true;
      dbg('');
      return misc.retry_until_success({
        f: this.__try_to_connect_once,
        log: dbg,
        start_delay: 4000,
        max_delay: 20000,
        cb: (function(_this) {
          return function() {
            delete _this._is_connecting;
            dbg("success!");
            return typeof cb === "function" ? cb() : void 0;
          };
        })(this)
      });
    };

    Plug.prototype.__try_to_connect_once = function(cb) {
      var do_connect, event, give_up, give_up_timer, timer;
      give_up_timer = void 0;
      do_connect = (function(_this) {
        return function() {
          if (give_up_timer) {
            clearInterval(give_up_timer);
          }
          return _this._opts.connect(cb);
        };
      })(this);
      if (this._opts.no_sign_in) {
        event = 'connected';
      } else {
        event = 'signed_in';
      }
      if (this._opts.client["is_" + event]()) {
        return do_connect();
      } else {
        this._opts.client.once(event, do_connect);
        give_up = (function(_this) {
          return function() {
            _this._opts.client.removeListener(event, do_connect);
            return cb("timeout");
          };
        })(this);
        return timer = setTimeout(give_up, 5000 + Math.random() * 10000);
      }
    };

    return Plug;

  })();

  SyncTable = (function(superClass) {
    extend(SyncTable, superClass);

    function SyncTable(_query, _options, _client, _debounce_interval, _throttle_changes, _cache_key) {
      var all_changed_keys, do_emit_changes, ref, ref1, ref2;
      this._query = _query;
      this._options = _options;
      this._client = _client;
      this._debounce_interval = _debounce_interval;
      this._throttle_changes = _throttle_changes;
      this._cache_key = _cache_key;
      this.wait = bind(this.wait, this);
      this.close = bind(this.close, this);
      this.set = bind(this.set, this);
      this._computed_primary_key = bind(this._computed_primary_key, this);
      this._handle_new_val = bind(this._handle_new_val, this);
      this._update_change = bind(this._update_change, this);
      this._update_all = bind(this._update_all, this);
      this.save = bind(this.save, this);
      this.__save = bind(this.__save, this);
      this._save = bind(this._save, this);
      this._changes = bind(this._changes, this);
      this._init_query = bind(this._init_query, this);
      this._parse_query = bind(this._parse_query, this);
      this.get_one = bind(this.get_one, this);
      this.get = bind(this.get, this);
      this.has_uncommitted_changes = bind(this.has_uncommitted_changes, this);
      this.key = bind(this.key, this);
      this._disconnected = bind(this._disconnected, this);
      this._reconnect = bind(this._reconnect, this);
      this._connect = bind(this._connect, this);
      this.dbg = bind(this.dbg, this);
      this._init_query();
      this._value_local = void 0;
      this._value_server = void 0;
      this._id = void 0;
      this._state = 'disconnected';
      this._created = new Date();
      this._plug = new Plug({
        name: this._table,
        client: this._client,
        connect: this._connect,
        no_sign_in: this._schema.anonymous || this._client.is_project()
      });
      this._client.on('disconnected', (function(_this) {
        return function() {
          _this._id = void 0;
          return _this._disconnected('client disconnect');
        };
      })(this));
      if (this._throttle_changes == null) {
        this._throttle_changes = (ref = schema.SCHEMA[this._table]) != null ? (ref1 = ref.user_query) != null ? (ref2 = ref1.get) != null ? ref2.throttle_changes : void 0 : void 0 : void 0;
      }
      if (!this._throttle_changes) {
        this.emit_change = (function(_this) {
          return function(changed_keys) {
            return _this.emit('change', changed_keys);
          };
        })(this);
      } else {
        all_changed_keys = {};
        do_emit_changes = (function(_this) {
          return function() {
            _this.emit('change', misc.keys(all_changed_keys));
            return all_changed_keys = {};
          };
        })(this);
        do_emit_changes = underscore.throttle(do_emit_changes, this._throttle_changes);
        this.emit_change = (function(_this) {
          return function(changed_keys) {
            var j, key, len;
            for (j = 0, len = changed_keys.length; j < len; j++) {
              key = changed_keys[j];
              all_changed_keys[key] = true;
            }
            return do_emit_changes();
          };
        })(this);
      }
    }

    SyncTable.prototype.dbg = function(f) {
      return (function(_this) {
        return function() {};
      })(this);
    };

    SyncTable.prototype._connect = function(cb) {
      var dbg;
      dbg = this.dbg("connect");
      dbg();
      if (this._state === 'closed') {
        if (typeof cb === "function") {
          cb('closed');
        }
        return;
      }
      if (this._state === 'connected') {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (this._id != null) {
        this._client.query_cancel({
          id: this._id
        });
        this._id = void 0;
      }
      return async.series([
        (function(_this) {
          return function(cb) {
            if ((_this._value_local != null) && (_this._value_server != null)) {
              return _this._save(cb);
            } else {
              return cb();
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this._reconnect(cb);
          };
        })(this)
      ], cb);
    };

    SyncTable.prototype._reconnect = function(cb) {
      var dbg, first_resp, this_query_id;
      dbg = this.dbg("_run");
      if (this._state === 'closed') {
        dbg("closed so don't do anything ever again");
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      first_resp = true;
      this_query_id = void 0;
      dbg("do the query");
      return this._client.query({
        query: this._query,
        changes: true,
        timeout: 30,
        options: this._options,
        cb: (function(_this) {
          return function(err, resp) {
            var j, len, ref, ref1, ref2;
            if (_this._state === 'closed') {
              return;
            }
            if (first_resp) {
              dbg("query got ", err, resp);
              first_resp = false;
              if (_this._state === 'closed') {
                return typeof cb === "function" ? cb("closed") : void 0;
              } else if ((resp != null ? resp.event : void 0) === 'query_cancel') {
                return typeof cb === "function" ? cb("query-cancel") : void 0;
              } else if (err) {
                return typeof cb === "function" ? cb(err) : void 0;
              } else if ((resp != null ? (ref = resp.query) != null ? ref[_this._table] : void 0 : void 0) == null) {
                return typeof cb === "function" ? cb("got no data") : void 0;
              } else {
                this_query_id = _this._id = resp.id;
                _this._state = 'connected';
                _this._update_all(resp.query[_this._table]);
                _this.emit("connected", resp.query[_this._table]);
                if (typeof cb === "function") {
                  cb();
                }
                ref2 = (ref1 = _this._connected_save_cbs) != null ? ref1 : [];
                for (j = 0, len = ref2.length; j < len; j++) {
                  cb = ref2[j];
                  _this.save(cb);
                }
                return delete _this._connected_save_cbs;
              }
            } else {
              if (_this._state !== 'connected') {
                dbg("nothing to do -- ignore these, and make sure they stop");
                if (this_query_id != null) {
                  _this._client.query_cancel({
                    id: this_query_id
                  });
                }
                return;
              }
              if (err || (resp != null ? resp.event : void 0) === 'query_cancel') {
                return _this._disconnected("err=" + err + ", resp?.event=" + (resp != null ? resp.event : void 0));
              } else {
                return _this._update_change(resp);
              }
            }
          };
        })(this)
      });
    };

    SyncTable.prototype._disconnected = function(why) {
      var dbg;
      dbg = this.dbg("_disconnected");
      dbg("why=" + why);
      if (this._state === 'disconnected') {
        dbg("already disconnected");
        return;
      }
      if (this._id) {
        this._client.query_cancel({
          id: this._id
        });
      }
      this._state = 'disconnected';
      return this._plug.connect();
    };

    SyncTable.prototype.key = function(obj) {
      return this._key(obj);
    };

    SyncTable.prototype.has_uncommitted_changes = function() {
      if ((this._value_server == null) && (this._value_local == null)) {
        return false;
      }
      if ((this._value_local != null) && (this._value_server == null)) {
        return true;
      }
      return !this._value_server.equals(this._value_local);
    };

    SyncTable.prototype.get = function(arg) {
      var j, k, len, x;
      if (this._value_local == null) {
        return;
      }
      if (arg != null) {
        if (misc.is_array(arg)) {
          x = {};
          for (j = 0, len = arg.length; j < len; j++) {
            k = arg[j];
            x[to_key(k)] = this._value_local.get(to_key(k));
          }
          return immutable.fromJS(x);
        } else {
          return this._value_local.get(to_key(arg));
        }
      } else {
        return this._value_local;
      }
    };

    SyncTable.prototype.get_one = function() {
      var ref;
      return (ref = this._value_local) != null ? ref.toSeq().first() : void 0;
    };

    SyncTable.prototype._parse_query = function(query) {
      var _, k, keys, obj1, obj2, obj3, table, v, x;
      if (typeof query === 'string') {
        v = misc.copy(schema.SCHEMA[query].user_query.get.fields);
        for (k in v) {
          _ = v[k];
          v[k] = null;
        }
        return (
          obj1 = {},
          obj1["" + query] = [v],
          obj1
        );
      } else {
        keys = misc.keys(query);
        if (keys.length !== 1) {
          throw Error("must specify exactly one table");
        }
        table = keys[0];
        x = {};
        if (!misc.is_array(query[table])) {
          return (
            obj2 = {},
            obj2["" + table] = [query[table]],
            obj2
          );
        } else {
          return (
            obj3 = {},
            obj3["" + table] = query[table],
            obj3
          );
        }
      }
    };

    SyncTable.prototype._init_query = function() {
      var field, j, l, len, len1, pk, primary_key, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, tables;
      this._query = this._parse_query(this._query);
      if (misc.is_array(this._query)) {
        throw Error("must be a single query");
      }
      tables = misc.keys(this._query);
      if (misc.len(tables) !== 1) {
        throw Error("must query only a single table");
      }
      this._table = tables[0];
      if (this._client.is_project()) {
        this._client_query = schema.SCHEMA[this._table].project_query;
      } else {
        this._client_query = schema.SCHEMA[this._table].user_query;
      }
      if (!misc.is_array(this._query[this._table])) {
        throw Error("must be a multi-document queries");
      }
      this._schema = schema.SCHEMA[this._table];
      if (this._schema == null) {
        throw Error("unknown schema for table " + this._table);
      }
      this._primary_keys = schema.client_db.primary_keys(this._table);
      ref = this._primary_keys;
      for (j = 0, len = ref.length; j < len; j++) {
        primary_key = ref[j];
        if (this._query[this._table][0][primary_key] == null) {
          this._query[this._table][0][primary_key] = null;
        }
      }
      if (this._primary_keys.length === 1) {
        pk = this._primary_keys[0];
        this._key = (function(_this) {
          return function(obj) {
            if (obj == null) {
              return;
            }
            if (immutable.Map.isMap(obj)) {
              return to_key(obj.get(pk));
            } else {
              return to_key(obj[pk]);
            }
          };
        })(this);
      } else {
        this._key = (function(_this) {
          return function(obj) {
            var a, l, len1, len2, m, ref1, ref2, v;
            if (obj == null) {
              return;
            }
            v = [];
            if (immutable.Map.isMap(obj)) {
              ref1 = _this._primary_keys;
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                pk = ref1[l];
                a = obj.get(pk);
                if (a == null) {
                  return;
                }
                v.push(a);
              }
            } else {
              ref2 = _this._primary_keys;
              for (m = 0, len2 = ref2.length; m < len2; m++) {
                pk = ref2[m];
                a = obj[pk];
                if (a == null) {
                  return;
                }
                v.push(a);
              }
            }
            return to_key(v);
          };
        })(this);
      }
      this._set_fields = [];
      this._required_set_fields = {};
      ref1 = misc.keys(this._query[this._table][0]);
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        field = ref1[l];
        if (((ref2 = this._client_query) != null ? (ref3 = ref2.set) != null ? (ref4 = ref3.fields) != null ? ref4[field] : void 0 : void 0 : void 0) != null) {
          this._set_fields.push(field);
        }
        if (((ref5 = this._client_query) != null ? (ref6 = ref5.set) != null ? (ref7 = ref6.required_fields) != null ? ref7[field] : void 0 : void 0 : void 0) != null) {
          this._required_set_fields[field] = true;
        }
      }
      return this._anonymous = !!this._schema.anonymous;
    };

    SyncTable.prototype._changes = function() {
      var changed;
      if ((this._value_server == null) || (this._value_local == null)) {
        return;
      }
      changed = {};
      this._value_local.map((function(_this) {
        return function(new_val, key) {
          var old_val;
          old_val = _this._value_server.get(key);
          if (!new_val.equals(old_val)) {
            return changed[key] = {
              new_val: new_val,
              old_val: old_val
            };
          }
        };
      })(this));
      return changed;
    };

    SyncTable.prototype._save = function(cb) {
      if (this.__is_saving) {
        return typeof cb === "function" ? cb("already saving") : void 0;
      } else {
        this.__is_saving = true;
        return this.__save((function(_this) {
          return function(err) {
            _this.__is_saving = false;
            return typeof cb === "function" ? cb(err) : void 0;
          };
        })(this));
      }
    };

    SyncTable.prototype.__save = function(cb) {
      var at_start, c, changed, i, j, k, key, l, len, len1, len2, m, obj, obj1, primary_key, query, ref, ref1, ref2, ref3, saved_objs, v;
      if (this._state === 'closed') {
        if (typeof cb === "function") {
          cb("closed");
        }
        return;
      }
      if (this._value_server == null) {
        if (typeof cb === "function") {
          cb("don't know server yet");
        }
        return;
      }
      if (this._value_local == null) {
        if (typeof cb === "function") {
          cb("don't know local yet");
        }
        return;
      }
      if (this._client_query.set == null) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      changed = this._changes();
      at_start = this._value_local;
      query = [];
      saved_objs = [];
      ref = misc.keys(changed).sort();
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        c = changed[key];
        obj = {};
        if (this._primary_keys.length === 1) {
          obj[this._primary_keys[0]] = key;
        } else {
          v = JSON.parse(key);
          i = 0;
          ref1 = this._primary_keys;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            primary_key = ref1[l];
            obj[primary_key] = v[i];
            i += 1;
          }
        }
        ref2 = this._set_fields;
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          k = ref2[m];
          v = c.new_val.get(k);
          if (v != null) {
            if (this._required_set_fields[k] || !immutable.is(v, (ref3 = c.old_val) != null ? ref3.get(k) : void 0)) {
              if (immutable.Iterable.isIterable(v)) {
                obj[k] = v.toJS();
              } else {
                obj[k] = v;
              }
            }
          }
        }
        query.push((
          obj1 = {},
          obj1["" + this._table] = obj,
          obj1
        ));
        saved_objs.push(obj);
      }
      if (query.length === 0) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      return this._client.query({
        query: query,
        options: [
          {
            set: true
          }
        ],
        timeout: 30,
        cb: (function(_this) {
          return function(err) {
            if (err) {
              console.warn("_save('" + _this._table + "') error:", err);
              if (err === 'clock') {
                _this._client.alert_message({
                  type: 'error',
                  timeout: 9999,
                  message: "Your computer's clock is or was off!  Fix it and **refresh your browser**."
                });
              }
              return typeof cb === "function" ? cb(err) : void 0;
            } else {
              if (_this._state === 'closed') {
                if (typeof cb === "function") {
                  cb("closed");
                }
                return;
              }
              if ((_this._value_server == null) || (_this._value_local == null)) {
                if (typeof cb === "function") {
                  cb("value_server and value_local must be set");
                }
                return;
              }
              _this.emit('saved', saved_objs);
              for (k in changed) {
                v = changed[k];
                if (immutable.is(_this._value_server.get(k), v.old_val)) {
                  _this._value_server = _this._value_server.set(k, v.new_val);
                }
              }
              if (!at_start.equals(_this._value_local)) {
                return _this._save(cb);
              } else {
                return typeof cb === "function" ? cb() : void 0;
              }
            }
          };
        })(this)
      });
    };

    SyncTable.prototype.save = function(cb) {
      if (this._state === 'closed') {
        if (typeof cb === "function") {
          cb("closed");
        }
        return;
      }
      if (this._state !== 'connected') {
        if (typeof cb === "function") {
          cb("not connected");
        }
        return;
      }
      if (this._save_debounce == null) {
        this._save_debounce = {};
      }
      if ((this._value_server == null) || (this._value_local == null)) {
        if (this._connected_save_cbs == null) {
          this._connected_save_cbs = [];
        }
        this._connected_save_cbs.push(cb);
        return;
      }
      return misc.async_debounce({
        f: (function(_this) {
          return function(cb) {
            return misc.retry_until_success({
              f: _this._save,
              max_delay: 5000,
              max_time: 30000,
              cb: cb
            });
          };
        })(this),
        interval: this._debounce_interval,
        state: this._save_debounce,
        cb: cb
      });
    };

    SyncTable.prototype._update_all = function(v) {
      var changed_keys, conflict, dbg, first_connect, j, key, len, val, x, y;
      dbg = this.dbg("_update_all");
      if (this._state === 'closed') {
        return;
      }
      if (v == null) {
        console.warn("_update_all('" + this._table + "') called with v=undefined");
        return;
      }
      this.emit('before-change');
      x = {};
      for (j = 0, len = v.length; j < len; j++) {
        y = v[j];
        x[this._key(y)] = y;
      }
      conflict = false;
      if ((this._value_local == null) || (this._value_server == null)) {
        dbg("easy case -- nothing has been initialized yet, so just set everything.");
        this._value_local = this._value_server = immutable.fromJS(x);
        first_connect = true;
        changed_keys = misc.keys(x);
      } else {
        dbg("harder case -- everything has already been initialized.");
        changed_keys = [];
        this._value_local.map((function(_this) {
          return function(local, key) {
            if (x[key] != null) {
              if (_this._handle_new_val(x[key], changed_keys)) {
                return conflict = true;
              }
            } else {
              if (_this._value_local.get(key).equals(_this._value_server.get(key))) {
                _this._value_local = _this._value_local["delete"](key);
                return changed_keys.push(key);
              } else {
                return conflict = true;
              }
            }
          };
        })(this));
        for (key in x) {
          val = x[key];
          if (this._value_local.get(key) == null) {
            this._value_local = this._value_local.set(key, immutable.fromJS(val));
            changed_keys.push(key);
          }
        }
      }
      if (changed_keys.length !== 0) {
        this._value_server = immutable.fromJS(x);
        this.emit_change(changed_keys);
      } else if (first_connect) {
        this.emit_change(changed_keys);
      }
      if (conflict) {
        return this.save();
      }
    };

    SyncTable.prototype._update_change = function(change) {
      var changed_keys, conflict, key;
      if (this._state === 'closed') {
        return;
      }
      if (this._value_local == null) {
        console.warn("_update_change(" + this._table + "): tried to call _update_change even though local not yet defined (ignoring)");
        return;
      }
      if (this._value_server == null) {
        console.warn("_update_change(" + this._table + "): tried to call _update_change even though set not yet defined (ignoring)");
        return;
      }
      if (DEBUG) {
        console.log("_update_change('" + this._table + "'): " + (misc.to_json(change)));
      }
      this.emit('before-change');
      changed_keys = [];
      conflict = false;
      if (change.new_val != null) {
        conflict = this._handle_new_val(change.new_val, changed_keys);
      }
      if ((change.old_val != null) && this._key(change.old_val) !== this._key(change.new_val)) {
        key = this._key(change.old_val);
        this._value_local = this._value_local["delete"](key);
        this._value_server = this._value_server["delete"](key);
        changed_keys.push(key);
      }
      if (changed_keys.length > 0) {
        this.emit_change(changed_keys);
        if (conflict) {
          return this.save();
        }
      }
    };

    SyncTable.prototype._handle_new_val = function(val, changed_keys) {
      var conflict, key, local_val, new_val, server;
      key = this._key(val);
      new_val = immutable.fromJS(val);
      local_val = this._value_local.get(key);
      conflict = false;
      if (!new_val.equals(local_val)) {
        if (local_val == null) {
          this._value_local = this._value_local.set(key, new_val);
          changed_keys.push(key);
        } else {
          server = this._value_server.get(key);
          new_val.map((function(_this) {
            return function(v, k) {
              if (!immutable.is(v, server != null ? server.get(k) : void 0)) {
                return local_val = local_val.set(k, v);
              }
            };
          })(this));
          if (server != null) {
            server.map((function(_this) {
              return function(v, k) {
                if (!new_val.has(k)) {
                  return local_val = local_val["delete"](k);
                }
              };
            })(this));
          }
          if (!local_val.equals(this._value_local.get(key))) {
            this._value_local = this._value_local.set(key, local_val);
            changed_keys.push(key);
          }
          if (!local_val.equals(new_val)) {
            this.emit('conflict', {
              new_val: new_val,
              old_val: local_val
            });
            conflict = true;
          }
        }
      }
      this._value_server = this._value_server.set(key, new_val);
      return conflict;
    };

    SyncTable.prototype._computed_primary_key = function(obj) {
      var f, j, len, pk, ref, v;
      if (this._primary_keys.length === 1) {
        f = this._client_query.set.fields[this._primary_keys[0]];
        if (typeof f === 'function') {
          return f(obj.toJS(), schema.client_db);
        } else {

        }
      } else {
        v = [];
        ref = this._primary_keys;
        for (j = 0, len = ref.length; j < len; j++) {
          pk = ref[j];
          f = this._client_query.set.fields[pk];
          if (typeof f === 'function') {
            v.push(f(obj.toJS(), schema.client_db));
          } else {
            return;
          }
        }
        return v;
      }
    };

    SyncTable.prototype.set = function(changes, merge, cb) {
      var _, can_set, cur, e, i, id, id0, j, k, len, new_val, pk, ref, ref1;
      if (this._state === 'closed') {
        console.warn("WARNING: attempt to do a set on a closed table: '" + this._table + "', " + (misc.to_json(this._query)));
        if (typeof cb === "function") {
          cb("closed");
        }
        return;
      }
      if (!immutable.Map.isMap(changes)) {
        changes = immutable.fromJS(changes);
      }
      if (this._value_local == null) {
        this._value_local = immutable.Map({});
      }
      if (merge == null) {
        merge = 'deep';
      } else if (typeof merge === 'function') {
        cb = merge;
        merge = 'deep';
      }
      if (!immutable.Map.isMap(changes)) {
        if (typeof cb === "function") {
          cb("type error -- changes must be an immutable.js Map or JS map");
        }
        return;
      }
      if (DEBUG) {
        console.log("set('" + this._table + "'): " + (misc.to_json(changes.toJS())));
      }
      if (this._client_query.set == null) {
        if (typeof cb === "function") {
          cb("users may not set " + this._table);
        }
        return;
      }
      can_set = this._client_query.set.fields;
      try {
        changes.map((function(_this) {
          return function(v, k) {
            if (can_set[k] === void 0) {
              throw Error("users may not set " + _this._table + "." + k);
            }
          };
        })(this));
      } catch (error) {
        e = error;
        if (typeof cb === "function") {
          cb(e);
        }
        return;
      }
      id = this._key(changes);
      if (id == null) {
        id0 = this._computed_primary_key(changes);
        id = to_key(id0);
        if ((id == null) && this._primary_keys.length === 1) {
          id0 = id = this._value_local.keySeq().first();
        }
        if (id == null) {
          if (typeof cb === "function") {
            cb("must specify primary key " + (this._primary_keys.join(',')) + ", have at least one record, or have a computed primary key");
          }
          return;
        }
        if (this._primary_keys.length === 1) {
          changes = changes.set(this._primary_keys[0], id0);
        } else {
          i = 0;
          ref = this._primary_keys;
          for (j = 0, len = ref.length; j < len; j++) {
            pk = ref[j];
            changes = changes.set(pk, id0[i]);
            i += 1;
          }
        }
      }
      cur = this._value_local.get(id);
      if (cur == null) {
        ref1 = this._required_set_fields;
        for (k in ref1) {
          _ = ref1[k];
          if (changes.get(k) == null) {
            if (typeof cb === "function") {
              cb("must specify field '" + k + "' for new records");
            }
            return;
          }
        }
        new_val = changes;
      } else {
        switch (merge) {
          case 'deep':
            new_val = cur.mergeDeep(changes);
            break;
          case 'shallow':
            new_val = cur.merge(changes);
            break;
          case 'none':
            new_val = changes;
            break;
          default:
            if (typeof cb === "function") {
              cb("merge must be one of 'deep', 'shallow', 'none'");
            }
            return;
        }
      }
      if (!immutable.is(new_val, cur)) {
        this._value_local = this._value_local.set(id, new_val);
        this.save(cb);
        this.emit_change([id]);
      } else {
        if (typeof cb === "function") {
          cb();
        }
      }
      return new_val;
    };

    SyncTable.prototype.close = function() {
      if (this._state === 'closed') {
        return;
      }
      if (global_cache_decref(this)) {
        return;
      }
      this._client.removeListener('disconnected', this._disconnected);
      this._save();
      this.removeAllListeners();
      if (this._id != null) {
        this._client.query_cancel({
          id: this._id
        });
        delete this._id;
      }
      this._state = 'closed';
      delete this._value_local;
      return delete this._value_server;
    };

    SyncTable.prototype.wait = function(opts) {
      var f, fail, fail_timer, x;
      opts = defaults(opts, {
        until: required,
        timeout: 30,
        cb: required
      });
      if (this._state === 'closed') {
        opts.cb("closed");
        return;
      }
      x = opts.until(this);
      if (x) {
        opts.cb(void 0, x);
        return;
      }
      fail_timer = void 0;
      f = (function(_this) {
        return function() {
          x = opts.until(_this);
          if (x) {
            _this.removeListener('change', f);
            if (fail_timer != null) {
              clearTimeout(fail_timer);
            }
            return opts.cb(void 0, x);
          }
        };
      })(this);
      this.on('change', f);
      if (opts.timeout) {
        fail = (function(_this) {
          return function() {
            _this.removeListener('change', f);
            return opts.cb('timeout');
          };
        })(this);
        fail_timer = setTimeout(fail, 1000 * opts.timeout);
      }
    };

    return SyncTable;

  })(EventEmitter);

  synctables = {};

  exports.sync_table = function(query, options, client, debounce_interval, throttle_changes, use_cache) {
    var S, cache_key;
    if (debounce_interval == null) {
      debounce_interval = 2000;
    }
    if (throttle_changes == null) {
      throttle_changes = void 0;
    }
    if (use_cache == null) {
      use_cache = true;
    }
    cache_key = json_stable_stringify({
      query: query,
      options: options,
      debounce_interval: debounce_interval,
      throttle_changes: throttle_changes
    });
    if (!use_cache) {
      return new SyncTable(query, options, client, debounce_interval, throttle_changes, cache_key);
    }
    S = synctables[cache_key];
    if (S != null) {
      if (S._state === 'connected') {
        async.nextTick(function() {
          if (S._state === 'connected') {
            return S.emit('connected');
          }
        });
      }
      S._reference_count += 1;
      return S;
    } else {
      S = synctables[cache_key] = new SyncTable(query, options, client, debounce_interval, throttle_changes, cache_key);
      S._reference_count = 1;
      return S;
    }
  };

  global_cache_decref = function(S) {
    if (S._reference_count != null) {
      S._reference_count -= 1;
      if (S._reference_count <= 0) {
        delete synctables[S._cache_key];
        return false;
      } else {
        return true;
      }
    }
  };


  /*
  Various mock clients for unit testing
  
  Events:
      - disconnected
      - connected
   */

  exports.TestBrowserClient1 = (function(superClass) {
    extend(TestBrowserClient1, superClass);

    function TestBrowserClient1() {
      this.query = bind(this.query, this);
      this.query_cancel = bind(this.query_cancel, this);
      this.dbg = bind(this.dbg, this);
      this.is_signed_in = bind(this.is_signed_in, this);
      this.is_connected = bind(this.is_connected, this);
      this.is_project = bind(this.is_project, this);
      return TestBrowserClient1.__super__.constructor.apply(this, arguments);
    }

    TestBrowserClient1.prototype.is_project = function() {
      return false;
    };

    TestBrowserClient1.prototype.is_connected = function() {
      return true;
    };

    TestBrowserClient1.prototype.is_signed_in = function() {
      return true;
    };

    TestBrowserClient1.prototype.dbg = function() {
      return (function(_this) {
        return function() {};
      })(this);
    };

    TestBrowserClient1.prototype.query_cancel = function() {};

    TestBrowserClient1.prototype.query = function(opts) {
      opts = defaults(opts, {
        query: required,
        changes: void 0,
        options: void 0,
        timeout: 30,
        cb: void 0
      });
      return this.emit('query', opts);
    };

    return TestBrowserClient1;

  })(EventEmitter);

}).call(this);
