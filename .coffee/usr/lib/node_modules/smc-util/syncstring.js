
/*






Database-backed time-log database-based synchronized editing

[TODO: High level description of algorithm here, or link to article.]
 */

(function() {
  var Evaluator, EventEmitter, LOCAL_HUB_AUTOSAVE_S, MAX_FILE_SIZE_MB, MAX_PATCHLIST_CACHE_SIZE, OFFLINE_THRESH_S, PatchValueCache, SortedPatchList, StringDocument, SyncDoc, TOUCH_INTERVAL_M, apply_patch, async, compress_patch, decompress_patch, defaults, diff_match_patch, dmp, immutable, make_patch, misc, node_uuid, patch_cmp, required, sagews, schema, synctable, time_cmp, underscore,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MAX_FILE_SIZE_MB = 2;

  TOUCH_INTERVAL_M = 10;

  LOCAL_HUB_AUTOSAVE_S = 120;

  OFFLINE_THRESH_S = 5 * 60;

  EventEmitter = require('events').EventEmitter;

  immutable = require('immutable');

  underscore = require('underscore');

  node_uuid = require('uuid');

  async = require('async');

  misc = require('./misc');

  sagews = require('./sagews').sagews;

  schema = require('./schema');

  Evaluator = require('./syncstring_evaluator').Evaluator;

  diff_match_patch = require('./dmp').diff_match_patch;

  dmp = new diff_match_patch();

  dmp.Diff_Timeout = 0.2;

  exports.dmp = dmp;

  defaults = misc.defaults, required = misc.required;

  compress_patch = function(patch) {
    var j, len, p, results;
    results = [];
    for (j = 0, len = patch.length; j < len; j++) {
      p = patch[j];
      results.push([p.diffs, p.start1, p.start2, p.length1, p.length2]);
    }
    return results;
  };

  decompress_patch = function(patch) {
    var j, len, p, results;
    results = [];
    for (j = 0, len = patch.length; j < len; j++) {
      p = patch[j];
      results.push({
        diffs: p[0],
        start1: p[1],
        start2: p[2],
        length1: p[3],
        length2: p[4]
      });
    }
    return results;
  };

  exports.make_patch = make_patch = function(s0, s1) {
    var p;
    p = compress_patch(dmp.patch_make(s0, s1));
    return p;
  };

  exports.apply_patch = apply_patch = function(patch, s) {
    var a, clean, err, j, len, ref, x;
    try {
      x = dmp.patch_apply(decompress_patch(patch), s);
    } catch (error1) {
      err = error1;
      console.warn("apply_patch -- " + err);
      return [s, false];
    }
    clean = true;
    ref = x[1];
    for (j = 0, len = ref.length; j < len; j++) {
      a = ref[j];
      if (!a) {
        clean = false;
        break;
      }
    }
    return [x[0], clean];
  };

  patch_cmp = function(a, b) {
    return misc.cmp_array([a.time - 0, a.user_id], [b.time - 0, b.user_id]);
  };

  time_cmp = function(a, b) {
    return a - b;
  };

  exports.three_way_merge = function(opts) {
    opts = defaults(opts, {
      base: required,
      local: required,
      remote: required
    });
    if (opts.base === opts.remote) {
      return opts.local;
    }
    return dmp.patch_apply(dmp.patch_make(opts.base, opts.remote), opts.local)[0];
  };


  /*
  The PatchValueCache is used to cache values returned
  by SortedPatchList.value.  Caching is critical, since otherwise
  the client may have to apply hundreds of patches after ever
  few keystrokes, which would make SMC unusable.  Also, the
  history browser is very painful to use without caching.
   */

  MAX_PATCHLIST_CACHE_SIZE = 20;

  PatchValueCache = (function() {
    function PatchValueCache() {
      this.size = bind(this.size, this);
      this.oldest_time = bind(this.oldest_time, this);
      this.get = bind(this.get, this);
      this.newest_value_at_most = bind(this.newest_value_at_most, this);
      this.include = bind(this.include, this);
      this.prune = bind(this.prune, this);
      this.invalidate = bind(this.invalidate, this);
      this.cache = {};
    }

    PatchValueCache.prototype.invalidate = function(time) {
      var _, ref, time0, tm;
      if (time == null) {
        this.cache = {};
        return;
      }
      time0 = time - 0;
      ref = this.cache;
      for (tm in ref) {
        _ = ref[tm];
        if (tm >= time0) {
          delete this.cache[tm];
        }
      }
    };

    PatchValueCache.prototype.prune = function(n) {
      var j, len, ref, ref1, time, v, x;
      v = [];
      ref = this.cache;
      for (time in ref) {
        x = ref[time];
        v.push({
          time: time,
          last_used: x.last_used
        });
      }
      if (v.length <= n) {
        return;
      }
      v.sort(function(a, b) {
        return misc.cmp_Date(a.last_used, b.last_used);
      });
      ref1 = v.slice(0, v.length - n);
      for (j = 0, len = ref1.length; j < len; j++) {
        x = ref1[j];
        delete this.cache[x.time];
      }
    };

    PatchValueCache.prototype.include = function(time, value, start) {
      this.cache[time - 0] = {
        time: time,
        value: value,
        start: start,
        last_used: new Date()
      };
    };

    PatchValueCache.prototype.newest_value_at_most = function(time, strict) {
      var j, len, t, time0, v;
      if (strict == null) {
        strict = false;
      }
      v = misc.keys(this.cache);
      if (v.length === 0) {
        return;
      }
      v.sort(misc.cmp);
      v.reverse();
      if (time == null) {
        return this.get(v[0]);
      }
      time0 = time - 0;
      for (j = 0, len = v.length; j < len; j++) {
        t = v[j];
        if ((!strict && t <= time0) || (strict && t < time0)) {
          return this.get(t);
        }
      }
    };

    PatchValueCache.prototype.get = function(time) {
      var x;
      if (typeof time !== 'number') {
        time = time - 0;
      }
      x = this.cache[time];
      if (x == null) {
        return;
      }
      x.last_used = new Date();
      return x;
    };

    PatchValueCache.prototype.oldest_time = function() {
      var v;
      v = misc.keys(this.cache);
      if (v.length === 0) {
        return;
      }
      v.sort(misc.cmp);
      return new Date(parseInt(v[0]));
    };

    PatchValueCache.prototype.size = function() {
      return misc.len(this.cache);
    };

    return PatchValueCache;

  })();

  SortedPatchList = (function(superClass) {
    extend(SortedPatchList, superClass);

    function SortedPatchList(_from_str) {
      this._from_str = _from_str;
      this.count = bind(this.count, this);
      this.newest_patch_time = bind(this.newest_patch_time, this);
      this.snapshot_times = bind(this.snapshot_times, this);
      this.time_of_unmade_periodic_snapshot = bind(this.time_of_unmade_periodic_snapshot, this);
      this.show_history = bind(this.show_history, this);
      this.versions = bind(this.versions, this);
      this.patch = bind(this.patch, this);
      this.time_sent = bind(this.time_sent, this);
      this.user_id = bind(this.user_id, this);
      this._validate_snapshots = bind(this._validate_snapshots, this);
      this._value_no_cache = bind(this._value_no_cache, this);
      this.value = bind(this.value, this);
      this.newest_snapshot_time = bind(this.newest_snapshot_time, this);
      this.add = bind(this.add, this);
      this.next_available_time = bind(this.next_available_time, this);
      this.close = bind(this.close, this);
      this._patches = [];
      this._times = {};
      this._cache = new PatchValueCache();
      this._snapshot_times = {};
    }

    SortedPatchList.prototype.close = function() {
      this.removeAllListeners();
      delete this._patches;
      delete this._times;
      delete this._cache;
      return delete this._snapshot_times;
    };

    SortedPatchList.prototype.next_available_time = function(time, m, n) {
      var a, t;
      if (m == null) {
        m = 0;
      }
      if (n == null) {
        n = 1;
      }
      if (misc.is_date(time)) {
        t = time - 0;
      } else {
        t = time;
      }
      if (n <= 0) {
        n = 1;
      }
      a = m - (t % n);
      if (a < 0) {
        a += n;
      }
      t += a;
      while (this._times[t] != null) {
        t += n;
      }
      return new Date(t);
    };

    SortedPatchList.prototype.add = function(patches) {
      var cur, err, j, len, oldest, t, v, x, y;
      if (patches.length === 0) {
        return;
      }
      v = [];
      oldest = void 0;
      for (j = 0, len = patches.length; j < len; j++) {
        x = patches[j];
        if (x != null) {
          if (!misc.is_date(x.time)) {
            try {
              x.time = misc.ISO_to_Date(x.time);
              if (isNaN(x.time)) {
                continue;
              }
            } catch (error1) {
              err = error1;
              continue;
            }
          }
          t = x.time - 0;
          cur = this._times[t];
          if (cur != null) {
            if (underscore.isEqual(cur.patch, x.patch) && cur.user_id === x.user_id && cur.snapshot === x.snapshot && +cur.prev === +x.prev) {
              continue;
            } else {
              this._patches = (function() {
                var l, len1, ref, results;
                ref = this._patches;
                results = [];
                for (l = 0, len1 = ref.length; l < len1; l++) {
                  y = ref[l];
                  if (y.time - 0 !== t) {
                    results.push(y);
                  }
                }
                return results;
              }).call(this);
              this.emit('overwrite', t);
            }
          }
          v.push(x);
          this._times[t] = x;
          if ((oldest == null) || oldest > x.time) {
            oldest = x.time;
          }
          if (x.snapshot != null) {
            this._snapshot_times[t] = true;
          }
        }
      }
      if (oldest != null) {
        this._cache.invalidate(oldest);
      }
      if (v.length > 0) {
        delete this._versions_cache;
        this._patches = this._patches.concat(v);
        return this._patches.sort(patch_cmp);
      }
    };

    SortedPatchList.prototype.newest_snapshot_time = function() {
      var t, t0;
      t0 = 0;
      for (t in this._snapshot_times) {
        t = parseInt(t);
        if (t > t0) {
          t0 = t;
        }
      }
      return new Date(t0);
    };


    /*
    value: Return the value of the string at the given (optional)
    point in time.  If the optional time is given, only include patches up
    to (and including) the given time; otherwise, return current value.
    
    If force is true, doesn't use snapshot at given input time, even if
    there is one; this is used to update snapshots in case of offline changes
    getting inserted into the changelog.
    
    If without is defined, it must be an array of Date objects; in that case
    the current value of the string is computed, but with all the patches
    at the given times in "without" ignored.  This is used elsewhere as a building
    block to implement undo.
     */

    SortedPatchList.prototype.value = function(time, force, without_times) {
      var cache, cache_start, cache_time, i, j, l, len, len1, len2, o, oldest_cached_time, prev_cutoff, q, ref, ref1, ref2, start, v, value, without, x;
      if (force == null) {
        force = false;
      }
      if (without_times == null) {
        without_times = void 0;
      }
      if ((time != null) && !misc.is_date(time)) {
        time = misc.ISO_to_Date(time);
      }
      if (without_times != null) {
        if (!misc.is_array(without_times)) {
          throw Error("without_times must be an array");
        }
        if (without_times.length > 0) {
          v = {};
          without = void 0;
          for (j = 0, len = without_times.length; j < len; j++) {
            x = without_times[j];
            if (!misc.is_date(x)) {
              throw Error("each without_times entry must be a date");
            }
            v[+x] = true;
            if ((without == null) || x < without) {
              without = x;
            }
          }
          if ((time != null) && +time < without) {
            without = void 0;
            without_times = void 0;
          } else {
            without_times = v;
          }
        }
      }
      prev_cutoff = this.newest_snapshot_time();
      oldest_cached_time = this._cache.oldest_time();
      if ((oldest_cached_time != null) && ((time == null) || +time >= +oldest_cached_time) && ((without == null) || +without > +oldest_cached_time)) {
        if (without != null) {
          cache = this._cache.newest_value_at_most(without, true);
        } else {
          cache = this._cache.newest_value_at_most(time);
        }
        value = cache.value;
        start = cache.start;
        cache_time = cache.time;
        ref = this._patches.slice(cache.start, this._patches.length);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          x = ref[l];
          if ((time != null) && x.time > time) {
            break;
          }
          if ((x.prev == null) || this._times[x.prev - 0] || +x.prev >= +prev_cutoff) {
            if ((without == null) || ((without != null) && !without_times[+x.time])) {
              value = value.apply_patch(x.patch);
            }
          }
          cache_time = x.time;
          start += 1;
        }
        if ((without == null) && ((time == null) || start - cache.start >= 10)) {
          this._cache.include(cache_time, value, start);
          this._cache.prune(Math.max(3, Math.min(Math.ceil(30000000 / value.length), MAX_PATCHLIST_CACHE_SIZE)));
        }
      } else {
        value = this._from_str('');
        start = 0;
        if (this._patches.length > 0) {
          for (i = o = ref1 = this._patches.length - 1; ref1 <= 0 ? o <= 0 : o >= 0; i = ref1 <= 0 ? ++o : --o) {
            if (((time == null) || +this._patches[i].time <= +time) && (this._patches[i].snapshot != null)) {
              if (force && +this._patches[i].time === +time) {
                continue;
              }
              value = this._from_str(this._patches[i].snapshot);
              start = i + 1;
              break;
            }
          }
        }
        cache_time = 0;
        cache_start = start;
        ref2 = this._patches.slice(start, this._patches.length);
        for (q = 0, len2 = ref2.length; q < len2; q++) {
          x = ref2[q];
          if ((time != null) && x.time > time) {
            break;
          }
          if ((x.prev == null) || this._times[x.prev - 0] || +x.prev >= +prev_cutoff) {
            if ((without == null) || ((without != null) && !without_times[+x.time])) {
              value = value.apply_patch(x.patch);
            }
          }
          cache_time = x.time;
          cache_start += 1;
        }
        if ((without == null) && ((time == null) || cache_time && cache_start - start >= 10)) {
          this._cache.include(cache_time, value, cache_start);
          this._cache.prune(Math.max(3, Math.min(Math.ceil(30000000 / value.length), MAX_PATCHLIST_CACHE_SIZE)));
        }
      }
      return value;
    };

    SortedPatchList.prototype._value_no_cache = function(time, snapshots) {
      var i, j, l, len, ref, ref1, start, value, x;
      if (snapshots == null) {
        snapshots = true;
      }
      value = this._from_str('');
      start = 0;
      if (snapshots && this._patches.length > 0) {
        for (i = j = ref = this._patches.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
          if (((time == null) || +this._patches[i].time <= +time) && (this._patches[i].snapshot != null)) {
            value = this._from_str(this._patches[i].snapshot);
            start = i + 1;
            break;
          }
        }
      }
      ref1 = this._patches.slice(start, this._patches.length);
      for (l = 0, len = ref1.length; l < len; l++) {
        x = ref1[l];
        if ((time != null) && x.time > time) {
          break;
        }
        value = value.apply_patch(x.patch);
      }
      return value;
    };

    SortedPatchList.prototype._validate_snapshots = function() {
      var i, j, len, ref, snapshot_value, value, x;
      if (this._patches.length === 0) {
        return;
      }
      i = 0;
      if (this._patches[0].snapshot != null) {
        i += 1;
        value = this._from_str(this._patches[0].snapshot);
      } else {
        value = this._from_str('');
      }
      ref = this._patches.slice(i);
      for (j = 0, len = ref.length; j < len; j++) {
        x = ref[j];
        value = value.apply_patch(x.patch);
        if (x.snapshot != null) {
          snapshot_value = this._from_str(x.snapshot);
          if (!value.is_equal(snapshot_value)) {
            console.log("FAIL (" + x.time + "): at " + i);
            console.log("diff(snapshot, correct)=");
            console.log(JSON.stringify(value.make_patch(snapshot_value)));
          } else {
            console.log("GOOD (" + x.time + "): snapshot at " + i + " by " + x.user_id);
          }
        }
        i += 1;
      }
    };

    SortedPatchList.prototype.user_id = function(time) {
      var ref;
      return (ref = this.patch(time)) != null ? ref.user_id : void 0;
    };

    SortedPatchList.prototype.time_sent = function(time) {
      var ref;
      return (ref = this.patch(time)) != null ? ref.sent : void 0;
    };

    SortedPatchList.prototype.patch = function(time) {
      var j, len, ref, x;
      ref = this._patches;
      for (j = 0, len = ref.length; j < len; j++) {
        x = ref[j];
        if (+x.time === +time) {
          return x;
        }
      }
    };

    SortedPatchList.prototype.versions = function() {
      var x;
      return this._versions_cache != null ? this._versions_cache : this._versions_cache = (function() {
        var j, len, ref, results;
        ref = this._patches;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          results.push(x.time);
        }
        return results;
      }).call(this);
    };

    SortedPatchList.prototype.show_history = function(opts) {
      var i, j, len, prev_cutoff, ref, ref1, s, t, tm, x;
      if (opts == null) {
        opts = {};
      }
      opts = defaults(opts, {
        milliseconds: false,
        trunc: 80,
        log: console.log
      });
      s = void 0;
      i = 0;
      prev_cutoff = this.newest_snapshot_time();
      ref = this._patches;
      for (j = 0, len = ref.length; j < len; j++) {
        x = ref[j];
        tm = x.time;
        tm = opts.milliseconds ? tm - 0 : tm.toLocaleString();
        opts.log("-----------------------------------------------------\n", i, x.user_id, tm, misc.trunc_middle(JSON.stringify(x.patch), opts.trunc));
        if (s == null) {
          s = this._from_str((ref1 = x.snapshot) != null ? ref1 : '');
        }
        if ((x.prev == null) || this._times[x.prev - 0] || +x.prev >= +prev_cutoff) {
          t = s.apply_patch(x.patch);
        } else {
          opts.log("prev=" + x.prev + " missing, so not applying");
        }
        s = t;
        opts.log((x.snapshot ? "(SNAPSHOT) " : "           "), s != null ? JSON.stringify(misc.trunc_middle(s.to_str(), opts.trunc).trim()) : void 0);
        i += 1;
      }
    };

    SortedPatchList.prototype.time_of_unmade_periodic_snapshot = function(interval) {
      var i, j, n, ref, ref1, ref2;
      n = this._patches.length - 1;
      if (n < 2 * interval) {
        return;
      }
      for (i = j = ref = n, ref1 = n - 2 * interval; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
        if (this._patches[i].snapshot != null) {
          if (i + interval + interval <= n) {
            return this._patches[i + interval].time;
          } else {
            return;
          }
        }
      }
      i = Math.floor((n - interval) / interval) * interval;
      return (ref2 = this._patches[i]) != null ? ref2.time : void 0;
    };

    SortedPatchList.prototype.snapshot_times = function() {
      var x;
      return (function() {
        var j, len, ref, results;
        ref = this._patches;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (x.snapshot != null) {
            results.push(x.time);
          }
        }
        return results;
      }).call(this);
    };

    SortedPatchList.prototype.newest_patch_time = function() {
      var ref;
      return (ref = this._patches[this._patches.length - 1]) != null ? ref.time : void 0;
    };

    SortedPatchList.prototype.count = function() {
      return this._patches.length;
    };

    return SortedPatchList;

  })(EventEmitter);

  exports.SortedPatchList = SortedPatchList;


  /*
  The SyncDoc class enables synchronized editing of a document that can be represented by a string.
  
  EVENTS:
  
   - 'change' event whenever the document is changed *remotely* (NOT locally), and also once
     when document is initialized.
  
   - 'user_change' when the string is definitely changed locally (so a new patch is recorded)
  
  STATES:
   */

  SyncDoc = (function(superClass) {
    extend(SyncDoc, superClass);

    function SyncDoc(opts) {
      this.has_uncommitted_changes = bind(this.has_uncommitted_changes, this);
      this._handle_patch_update = bind(this._handle_patch_update, this);
      this.__do_save_to_disk_project = bind(this.__do_save_to_disk_project, this);
      this.__save_to_disk_user = bind(this.__save_to_disk_user, this);
      this._save_to_disk = bind(this._save_to_disk, this);
      this.save_to_disk = bind(this.save_to_disk, this);
      this.hash_of_live_version = bind(this.hash_of_live_version, this);
      this.hash_of_saved_version = bind(this.hash_of_saved_version, this);
      this.has_unsaved_changes = bind(this.has_unsaved_changes, this);
      this.wait_until_read_only_known = bind(this.wait_until_read_only_known, this);
      this.get_read_only = bind(this.get_read_only, this);
      this._set_read_only = bind(this._set_read_only, this);
      this._set_save = bind(this._set_save, this);
      this._load_from_disk = bind(this._load_from_disk, this);
      this._update_watch_path = bind(this._update_watch_path, this);
      this._handle_syncstring_update = bind(this._handle_syncstring_update, this);
      this._handle_offline = bind(this._handle_offline, this);
      this.set_snapshot_interval = bind(this.set_snapshot_interval, this);
      this.get_project_id = bind(this.get_project_id, this);
      this.get_path = bind(this.get_path, this);
      this.show_history = bind(this.show_history, this);
      this.load_full_history = bind(this.load_full_history, this);
      this.has_full_history = bind(this.has_full_history, this);
      this._get_patches = bind(this._get_patches, this);
      this._process_patch = bind(this._process_patch, this);
      this.snapshot_if_necessary = bind(this.snapshot_if_necessary, this);
      this.snapshot = bind(this.snapshot, this);
      this.save = bind(this.save, this);
      this._save_patch = bind(this._save_patch, this);
      this._undelete = bind(this._undelete, this);
      this._save = bind(this._save, this);
      this.save_asap = bind(this.save_asap, this);
      this.get_cursors = bind(this.get_cursors, this);
      this.set_cursor_locs = bind(this.set_cursor_locs, this);
      this._init_cursors = bind(this._init_cursors, this);
      this._init_evaluator = bind(this._init_evaluator, this);
      this._init_patch_list = bind(this._init_patch_list, this);
      this._patch_table_query = bind(this._patch_table_query, this);
      this._load_from_disk_if_newer = bind(this._load_from_disk_if_newer, this);
      this._update_if_file_is_read_only = bind(this._update_if_file_is_read_only, this);
      this.delete_from_database = bind(this.delete_from_database, this);
      this.connect = bind(this.connect, this);
      this.reconnect = bind(this.reconnect, this);
      this.close = bind(this.close, this);
      this.last_changed = bind(this.last_changed, this);
      this.all_versions = bind(this.all_versions, this);
      this.versions = bind(this.versions, this);
      this._set_initialized = bind(this._set_initialized, this);
      this.touch = bind(this.touch, this);
      this.user_id = bind(this.user_id, this);
      this.time_sent = bind(this.time_sent, this);
      this.account_id = bind(this.account_id, this);
      this.init_project_autosave = bind(this.init_project_autosave, this);
      this._init_undo_state = bind(this._init_undo_state, this);
      this.exit_undo_mode = bind(this.exit_undo_mode, this);
      this.in_undo_mode = bind(this.in_undo_mode, this);
      this.redo = bind(this.redo, this);
      this.undo = bind(this.undo, this);
      this.revert = bind(this.revert, this);
      this.version_without = bind(this.version_without, this);
      this.version = bind(this.version, this);
      this.to_str = bind(this.to_str, this);
      this.from_str = bind(this.from_str, this);
      this.get_doc = bind(this.get_doc, this);
      this.set_doc = bind(this.set_doc, this);
      var action, file_use, is_chat, set_cursor_locs;
      this._opts = opts = defaults(opts, {
        save_interval: 1500,
        cursor_interval: 2000,
        patch_interval: 1000,
        file_use_interval: 'default',
        string_id: void 0,
        project_id: required,
        path: required,
        client: required,
        cursors: false,
        from_str: required,
        doctype: void 0,
        from_patch_str: JSON.parse
      });
      if (opts.string_id == null) {
        opts.string_id = schema.client_db.sha1(opts.project_id, opts.path);
      }
      this._closed = true;
      this._string_id = opts.string_id;
      this._project_id = opts.project_id;
      this._path = opts.path;
      this._client = opts.client;
      this._from_str = opts.from_str;
      this._from_patch_str = opts.from_patch_str;
      this._doctype = opts.doctype;
      this._patch_format = opts.doctype.patch_format;
      this._save_interval = opts.save_interval;
      this._patch_interval = opts.patch_interval;
      this._my_patches = {};

      /*
      if window?
          window.syncstrings ?= {}
          window.syncstrings[@_path] = @
       */
      this.connect((function(_this) {
        return function(err) {
          if (err) {
            console.warn("error creating SyncDoc: '" + err + "'");
            return _this.emit('error', err);
          } else {
            if (_this._client.is_project()) {
              return _this.init_project_autosave();
            } else {
              return _this._undelete();
            }
          }
        };
      })(this));
      if (opts.file_use_interval && this._client.is_user()) {
        is_chat = misc.filename_extension(this._path) === 'sage-chat';
        if (is_chat) {
          action = 'chat';
        } else {
          action = 'edit';
        }
        file_use = (function(_this) {
          return function() {
            return _this._client.mark_file({
              project_id: _this._project_id,
              path: _this._path,
              action: action,
              ttl: opts.file_use_interval
            });
          };
        })(this);
        this.on('user_change', underscore.throttle(file_use, opts.file_use_interval, true));
      }
      if (opts.cursors) {
        set_cursor_locs = (function(_this) {
          return function(locs) {
            var ref, x;
            x = {
              string_id: _this._string_id,
              user_id: _this._user_id,
              locs: locs,
              time: _this._client.server_time()
            };
            return (ref = _this._cursors) != null ? ref.set(x, 'none') : void 0;
          };
        })(this);
        this._throttled_set_cursor_locs = underscore.throttle(set_cursor_locs, this._opts.cursor_interval);
      }
    }

    SyncDoc.prototype.set_doc = function(value) {
      if ((value != null ? value.apply_patch : void 0) == null) {
        throw Error("value must be a document object with apply_patch, etc., methods");
      }
      this._doc = value;
    };

    SyncDoc.prototype.get_doc = function() {
      return this._doc;
    };

    SyncDoc.prototype.from_str = function(value) {
      this._doc = this._from_str(value);
    };

    SyncDoc.prototype.to_str = function() {
      var ref;
      return (ref = this._doc) != null ? typeof ref.to_str === "function" ? ref.to_str() : void 0 : void 0;
    };

    SyncDoc.prototype.dbg = function(f) {
      return this._client.dbg("SyncString." + f + ":");
    };

    SyncDoc.prototype.version = function(time) {
      var ref;
      return (ref = this._patch_list) != null ? ref.value(time) : void 0;
    };

    SyncDoc.prototype.version_without = function(times) {
      return this._patch_list.value(void 0, void 0, times);
    };

    SyncDoc.prototype.revert = function(version) {
      this.set_doc(this.version(version));
    };

    SyncDoc.prototype.undo = function() {
      var live, state, tm, value;
      state = this._undo_state;
      if (state == null) {
        state = this._undo_state = this._init_undo_state();
      }
      if (state.pointer === state.my_times.length) {
        value = this.version();
        live = this._doc;
        if (!live.is_equal(value)) {
          state.final = value.make_patch(live);
          state.pointer -= 1;
          return value;
        } else {
          tm = state.my_times[state.pointer - 1];
          state.pointer -= 2;
          if (tm != null) {
            state.without.push(tm);
            return this.version_without(state.without);
          } else {
            return value;
          }
        }
      } else {
        if (state.pointer >= 0) {
          state.without.push(state.my_times[state.pointer]);
          state.pointer -= 1;
        }
        return this.version_without(state.without);
      }
    };

    SyncDoc.prototype.redo = function() {
      var state;
      state = this._undo_state;
      if (state == null) {
        return this.get_doc();
      }
      if (state.pointer === state.my_times.length) {
        return this.get_doc();
      } else if (state.pointer === state.my_times.length - 1) {
        state.pointer += 1;
        return this.version().apply_patch(state.final);
      } else {
        state.without.pop();
        state.pointer += 1;
        if ((state.final == null) && state.pointer === state.my_times.length - 1) {
          state.pointer += 1;
        }
        return this.version_without(state.without);
      }
    };

    SyncDoc.prototype.in_undo_mode = function() {
      return this._undo_state != null;
    };

    SyncDoc.prototype.exit_undo_mode = function() {
      return delete this._undo_state;
    };

    SyncDoc.prototype._init_undo_state = function() {
      var state, x;
      if (this._undo_state != null) {
        this._undo_state;
      }
      state = this._undo_state = {};
      state.my_times = (function() {
        var j, len, ref, results;
        ref = misc.keys(this._my_patches);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          results.push(new Date(parseInt(x)));
        }
        return results;
      }).call(this);
      state.my_times.sort(misc.cmp_Date);
      state.pointer = state.my_times.length;
      state.without = [];
      return state;
    };

    SyncDoc.prototype.init_project_autosave = function() {
      var f;
      if (!LOCAL_HUB_AUTOSAVE_S || !this._client.is_project() || (this._project_autosave != null)) {
        return;
      }
      f = (function(_this) {
        return function() {
          if ((_this.hash_of_saved_version() != null) && _this.has_unsaved_changes()) {
            return _this._save_to_disk();
          }
        };
      })(this);
      return this._project_autosave = setInterval(f, LOCAL_HUB_AUTOSAVE_S * 1000);
    };

    SyncDoc.prototype.account_id = function(time) {
      return this._users[this.user_id(time)];
    };

    SyncDoc.prototype.time_sent = function(time) {
      return this._patch_list.time_sent(time);
    };

    SyncDoc.prototype.user_id = function(time) {
      return this._patch_list.user_id(time);
    };

    SyncDoc.prototype.touch = function(min_age_m) {
      var last_active, ref;
      if (min_age_m == null) {
        min_age_m = 5;
      }
      if (this._client.is_project()) {
        return;
      }
      if (min_age_m > 0) {
        last_active = (ref = this._syncstring_table) != null ? ref.get_one().get('last_active') : void 0;
        if (!((last_active == null) || +last_active <= +misc.server_minutes_ago(min_age_m))) {
          return;
        }
      }
      return this._client.query({
        query: {
          syncstrings: {
            string_id: this._string_id,
            project_id: this._project_id,
            path: this._path,
            deleted: this._deleted,
            last_active: misc.server_time(),
            doctype: misc.to_json(this._doctype)
          }
        }
      });
    };

    SyncDoc.prototype._set_initialized = function(error, cb) {
      var init;
      init = {
        time: misc.server_time()
      };
      if (error) {
        init.error = "error - " + (JSON.stringify(error));
      } else {
        init.error = '';
      }
      return this._client.query({
        query: {
          syncstrings: {
            string_id: this._string_id,
            project_id: this._project_id,
            path: this._path,
            init: init
          }
        },
        cb: cb
      });
    };

    SyncDoc.prototype.versions = function() {
      var v;
      v = [];
      this._patches_table.get().map((function(_this) {
        return function(x, id) {
          return v.push(x.get('time'));
        };
      })(this));
      v.sort(time_cmp);
      return v;
    };

    SyncDoc.prototype.all_versions = function() {
      var ref;
      return (ref = this._patch_list) != null ? ref.versions() : void 0;
    };

    SyncDoc.prototype.last_changed = function() {
      var v;
      v = this.versions();
      if (v.length > 0) {
        return v[v.length - 1];
      } else {
        return new Date(0);
      }
    };

    SyncDoc.prototype.close = function() {
      var ref, ref1, ref2, ref3, ref4;
      if (this._closed) {
        return;
      }
      this.emit('close');
      this.removeAllListeners();
      this._closed = true;
      if (this._periodically_touch != null) {
        clearInterval(this._periodically_touch);
        delete this._periodically_touch;
      }
      if (this._project_autosave != null) {
        clearInterval(this._project_autosave);
        delete this._project_autosave;
      }
      delete this._cursor_throttled;
      delete this._cursor_map;
      delete this._users;
      if ((ref = this._syncstring_table) != null) {
        ref.close();
      }
      delete this._syncstring_table;
      if ((ref1 = this._patches_table) != null) {
        ref1.close();
      }
      delete this._patches_table;
      if ((ref2 = this._patch_list) != null) {
        ref2.close();
      }
      delete this._patch_list;
      if ((ref3 = this._cursors) != null) {
        ref3.close();
      }
      delete this._cursors;
      if (this._client.is_project()) {
        this._update_watch_path();
      }
      if ((ref4 = this._evaluator) != null) {
        ref4.close();
      }
      return delete this._evaluator;
    };

    SyncDoc.prototype.reconnect = function(cb) {
      this.close();
      return this.connect(cb);
    };

    SyncDoc.prototype.connect = function(cb) {
      var query;
      if (!this._closed) {
        cb("already connected");
        return;
      }
      this.touch(0);
      query = {
        syncstrings: {
          string_id: this._string_id,
          project_id: this._project_id,
          path: this._path,
          deleted: null,
          users: null,
          last_snapshot: null,
          snapshot_interval: null,
          save: null,
          last_active: null,
          init: null,
          read_only: null,
          last_file_change: null,
          doctype: null
        }
      };
      this._syncstring_table = this._client.sync_table(query);
      return this._syncstring_table.once('connected', (function(_this) {
        return function() {
          _this._handle_syncstring_update();
          _this._syncstring_table.on('change', _this._handle_syncstring_update);
          return async.series([
            function(cb) {
              return async.parallel([_this._init_patch_list, _this._init_cursors, _this._init_evaluator], cb);
            }, function(cb) {
              _this._closed = false;
              if (_this._client.is_user() && (_this._periodically_touch == null)) {
                _this.touch(1);
                _this._periodically_touch = setInterval((function() {
                  return _this.touch(TOUCH_INTERVAL_M / 2);
                }), 1000 * 60 * TOUCH_INTERVAL_M);
              }
              if (_this._client.is_project()) {
                return _this._load_from_disk_if_newer(cb);
              } else {
                return cb();
              }
            }
          ], function(err) {
            if (_this._closed) {
              cb();
              return;
            }
            _this._syncstring_table.wait({
              until: function(t) {
                var ref;
                return (ref = t.get_one()) != null ? ref.get('init') : void 0;
              },
              cb: function(err, init) {
                return _this.emit('init', err != null ? err : init.toJS().error);
              }
            });
            if (err) {
              return cb(err);
            } else {
              _this.emit('change');
              _this.emit('connected');
              return cb();
            }
          });
        };
      })(this));
    };

    SyncDoc.prototype.delete_from_database = function(cb) {
      return async.parallel([
        (function(_this) {
          return function(cb) {
            return _this._client.query({
              query: {
                patches_delete: {
                  id: [_this._string_id],
                  dummy: null
                }
              },
              cb: cb
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this._client.query({
              query: {
                syncstrings_delete: {
                  project_id: _this._project_id,
                  path: _this._path
                }
              },
              cb: cb
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          return typeof cb === "function" ? cb(err) : void 0;
        };
      })(this));
    };

    SyncDoc.prototype._update_if_file_is_read_only = function(cb) {
      return this._client.path_access({
        path: this._path,
        mode: 'w',
        cb: (function(_this) {
          return function(err) {
            _this._set_read_only(!!err);
            return typeof cb === "function" ? cb() : void 0;
          };
        })(this)
      });
    };

    SyncDoc.prototype._load_from_disk_if_newer = function(cb) {
      var dbg, exists, tm;
      tm = this.last_changed();
      dbg = this._client.dbg("syncstring._load_from_disk_if_newer('" + this._path + "')");
      exists = void 0;
      return async.series([
        (function(_this) {
          return function(cb) {
            dbg("check if path exists");
            return _this._client.path_exists({
              path: _this._path,
              cb: function(err, _exists) {
                if (err) {
                  return cb(err);
                } else {
                  exists = _exists;
                  return cb();
                }
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (!exists) {
              dbg("file does NOT exist");
              _this._set_read_only(false);
              cb();
              return;
            }
            if (tm != null) {
              dbg("edited before, so stat file");
              return _this._client.path_stat({
                path: _this._path,
                cb: function(err, stats) {
                  if (err) {
                    return cb(err);
                  } else if (stats.ctime > tm) {
                    dbg("disk file changed more recently than edits, so loading");
                    return _this._load_from_disk(cb);
                  } else {
                    dbg("stick with database version");
                    return cb();
                  }
                }
              });
            } else {
              dbg("never edited before");
              if (exists) {
                dbg("path exists, so load from disk");
                return _this._load_from_disk(cb);
              } else {
                return cb();
              }
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            if (exists) {
              return _this._update_if_file_is_read_only(cb);
            } else {
              return cb();
            }
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          return _this._set_initialized(err, cb);
        };
      })(this));
    };

    SyncDoc.prototype._patch_table_query = function(cutoff) {
      var query;
      query = {
        string_id: this._string_id,
        time: cutoff ? {
          '>=': cutoff
        } : null,
        patch: null,
        user_id: null,
        snapshot: null,
        sent: null,
        prev: null
      };
      if (this._patch_format != null) {
        query.format = this._patch_format;
      }
      return query;
    };

    SyncDoc.prototype._init_patch_list = function(cb) {
      var patch_list;
      delete this._patch_list;
      patch_list = new SortedPatchList(this._from_str);
      this._patches_table = this._client.sync_table({
        patches: this._patch_table_query(this._last_snapshot)
      }, void 0, this._patch_interval, this._patch_interval);
      this._patches_table.once('connected', (function(_this) {
        return function() {
          var doc;
          patch_list.add(_this._get_patches());
          doc = patch_list.value();
          _this._last = _this._doc = doc;
          _this._patches_table.on('change', _this._handle_patch_update);
          _this._patches_table.on('before-change', function() {
            return _this.emit('before-change');
          });
          _this._patch_list = patch_list;
          return cb();
        };
      })(this));

      /*
      TODO/CRITICAL: We are temporarily disabling same-user collision detection, since this seems to be leading to
      serious issues involving a feedback loop, which may be way worse than the 1 in a million issue
      that this addresses.  This only address the *same* account being used simultaneously on the same file
      by multiple people which isn't something users should ever do (but they do in big demos).
      
      @_patch_list.on 'overwrite', (t) =>
           * ensure that any outstanding save is done
          @_patches_table.save () =>
              @_check_for_timestamp_collision(t)
       */
      return this._patches_table.on('saved', (function(_this) {
        return function(data) {
          return _this._handle_offline(data);
        };
      })(this));
    };


    /*
    _check_for_timestamp_collision: (t) =>
        obj = @_my_patches[t]
        if not obj?
            return
        key = @_patches_table.key(obj)
        if obj.patch != @_patches_table.get(key)?.get('patch')
            #console.log("COLLISION! #{t}, #{obj.patch}, #{@_patches_table.get(key).get('patch')}")
             * We fix the collision by finding the nearest time after time that
             * is available, and reinserting our patch at that new time.
            @_my_patches[t] = 'killed'
            new_time = @_patch_list.next_available_time(new Date(t), @_user_id, @_users.length)
            @_save_patch(new_time, JSON.parse(obj.patch))
     */

    SyncDoc.prototype._init_evaluator = function(cb) {
      if (misc.filename_extension(this._path) === 'sagews') {
        return this._evaluator = new Evaluator(this, cb);
      } else {
        return cb();
      }
    };

    SyncDoc.prototype._init_cursors = function(cb) {
      var emit_cursor_throttled, query;
      if (!this._client.is_user()) {
        return cb();
      } else {
        if (!this._opts.cursors) {
          cb();
          return;
        }
        query = {
          cursors: {
            string_id: this._string_id,
            user_id: null,
            locs: null,
            time: null
          }
        };
        this._cursors = this._client.sync_table(query);
        this._cursors.once('connected', (function(_this) {
          return function() {
            _this._cursor_map = immutable.Map();
            _this._cursors.get().map(function(locs, k) {
              var ref;
              return _this._cursor_map = _this._cursor_map.set(_this._users[(ref = JSON.parse(k)) != null ? ref[1] : void 0], locs);
            });
            return cb();
          };
        })(this));
        this._cursor_map = void 0;
        this._cursor_throttled = {};
        emit_cursor_throttled = (function(_this) {
          return function(account_id) {
            var f, t;
            t = _this._cursor_throttled[account_id];
            if (t == null) {
              f = function() {
                return _this.emit('cursor_activity', account_id);
              };
              t = _this._cursor_throttled[account_id] = underscore.throttle(f, _this._opts.cursor_interval);
            }
            return t();
          };
        })(this);
        return this._cursors.on('change', (function(_this) {
          return function(keys) {
            var account_id, j, k, len, ref, results;
            if (_this._closed) {
              return;
            }
            results = [];
            for (j = 0, len = keys.length; j < len; j++) {
              k = keys[j];
              account_id = _this._users[(ref = JSON.parse(k)) != null ? ref[1] : void 0];
              _this._cursor_map = _this._cursor_map.set(account_id, _this._cursors.get(k));
              results.push(emit_cursor_throttled(account_id));
            }
            return results;
          };
        })(this));
      }
    };

    SyncDoc.prototype.set_cursor_locs = function(locs) {
      if (this._closed) {
        return;
      }
      if (this._users.length <= 2) {
        return;
      }
      if (typeof this._throttled_set_cursor_locs === "function") {
        this._throttled_set_cursor_locs(locs);
      }
    };

    SyncDoc.prototype.get_cursors = function() {
      return this._cursor_map;
    };

    SyncDoc.prototype.save_asap = function(cb) {
      return this._save(cb);
    };

    SyncDoc.prototype._save = function(cb) {
      var min_time, patch, time;
      if (this._closed) {
        if (typeof cb === "function") {
          cb("string closed");
        }
        return;
      }
      if (this._last == null) {
        if (typeof cb === "function") {
          cb("string not initialized");
        }
        return;
      }
      if (this._last.is_equal(this._doc)) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (this._saving) {
        if (typeof cb === "function") {
          cb("saving");
        }
        return;
      }
      this._saving = true;
      patch = this._last.make_patch(this._doc);
      if (patch == null) {
        this._saving = false;
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      this._last = this._doc;
      time = this._client.server_time();
      min_time = this._patch_list.newest_patch_time();
      if ((min_time != null) && min_time >= time) {
        time = new Date((min_time - 0) + 1);
      }
      time = this._patch_list.next_available_time(time, this._user_id, this._users.length);
      this._save_patch(time, patch, cb);
      this.snapshot_if_necessary();
      this.emit('user_change');
      return this._saving = false;
    };

    SyncDoc.prototype._undelete = function() {
      if (this._closed) {
        return;
      }
      return this._syncstring_table.set(this._syncstring_table.get_one().set('deleted', false));
    };

    SyncDoc.prototype._save_patch = function(time, patch, cb) {
      var obj, ref, x;
      if (this._closed) {
        if (typeof cb === "function") {
          cb('closed');
        }
        return;
      }
      obj = {
        string_id: this._string_id,
        time: time,
        patch: JSON.stringify(patch),
        user_id: this._user_id
      };
      if (this._patch_format != null) {
        obj.format = this._patch_format;
      }
      if (this._deleted) {
        this._undelete();
      }
      if (this._save_patch_prev != null) {
        obj.prev = this._save_patch_prev;
      }
      this._save_patch_prev = time;
      this._my_patches[time - 0] = obj;
      if ((ref = this._undo_state) != null) {
        ref.without.unshift(time);
      }
      x = this._patches_table.set(obj, 'none', cb);
      return this._patch_list.add([this._process_patch(x, void 0, void 0, patch)]);
    };

    SyncDoc.prototype.save = function(cb) {
      if (this._save_debounce == null) {
        this._save_debounce = {};
      }
      misc.async_debounce({
        f: this._save,
        interval: this._save_interval,
        state: this._save_debounce,
        cb: cb
      });
    };

    SyncDoc.prototype.snapshot = function(time, force) {
      var obj, x;
      if (force == null) {
        force = false;
      }
      if (!misc.is_date(time)) {
        throw Error("time must be a date");
      }
      x = this._patch_list.patch(time);
      if (x == null) {
        console.warn("no patch at time " + time);
        return;
      }
      if ((x.snapshot != null) && !force) {
        return;
      }
      obj = {
        string_id: this._string_id,
        time: time,
        patch: JSON.stringify(x.patch),
        snapshot: this._patch_list.value(time, force).to_str(),
        user_id: x.user_id
      };
      if (force) {
        obj.sent = time;
      }
      x.snapshot = obj.snapshot;
      this._patches_table.set(obj, 'none', (function(_this) {
        return function(err) {
          if (!err) {
            _this._syncstring_table.set({
              string_id: _this._string_id,
              project_id: _this._project_id,
              path: _this._path,
              last_snapshot: time
            });
            return _this._last_snapshot = time;
          } else {
            return console.warn("failed to save snapshot -- " + err);
          }
        };
      })(this));
      return time;
    };

    SyncDoc.prototype.snapshot_if_necessary = function() {
      var time;
      time = this._patch_list.time_of_unmade_periodic_snapshot(this._snapshot_interval);
      if (time != null) {
        return this.snapshot(time);
      }
    };

    SyncDoc.prototype._process_patch = function(x, time0, time1, patch) {
      var err, obj, prev, ref, sent, snapshot, time, user_id;
      if (x == null) {
        return;
      }
      time = x.get('time');
      if (!misc.is_date(time)) {
        try {
          time = misc.ISO_to_Date(time);
          if (isNaN(time)) {
            return;
          }
        } catch (error1) {
          err = error1;
          return;
        }
      }
      user_id = x.get('user_id');
      sent = x.get('sent');
      prev = x.get('prev');
      if ((time0 != null) && time < time0) {
        return;
      }
      if ((time1 != null) && time > time1) {
        return;
      }
      if (patch == null) {
        patch = JSON.parse((ref = x.get('patch')) != null ? ref : '[]');
      }
      snapshot = x.get('snapshot');
      obj = {
        time: time,
        user_id: user_id,
        patch: patch
      };
      if (sent != null) {
        obj.sent = sent;
      }
      if (prev != null) {
        obj.prev = prev;
      }
      if (snapshot != null) {
        obj.snapshot = snapshot;
      }
      return obj;
    };

    SyncDoc.prototype._get_patches = function(time0, time1) {
      var m, v;
      if (time0 == null) {
        time0 = this._last_snapshot;
      }
      m = this._patches_table.get();
      v = [];
      m.map((function(_this) {
        return function(x, id) {
          var p;
          p = _this._process_patch(x, time0, time1);
          if (p != null) {
            return v.push(p);
          }
        };
      })(this));
      v.sort(patch_cmp);
      return v;
    };

    SyncDoc.prototype.has_full_history = function() {
      return !this._last_snapshot || this._load_full_history_done;
    };

    SyncDoc.prototype.load_full_history = function(cb) {
      var dbg, query;
      dbg = this.dbg("load_full_history");
      dbg();
      if (this.has_full_history()) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      query = this._patch_table_query();
      return this._client.query({
        query: {
          patches: [query]
        },
        cb: (function(_this) {
          return function(err, result) {
            var v;
            if (err) {
              return typeof cb === "function" ? cb(err) : void 0;
            } else {
              v = [];
              immutable.fromJS(result.query.patches).forEach(function(x) {
                var p;
                p = _this._process_patch(x, 0, _this._last_snapshot);
                if (p != null) {
                  return v.push(p);
                }
              });
              _this._patch_list.add(v);
              _this._load_full_history_done = true;
              return typeof cb === "function" ? cb() : void 0;
            }
          };
        })(this)
      });
    };

    SyncDoc.prototype.show_history = function(opts) {
      return this._patch_list.show_history(opts);
    };

    SyncDoc.prototype.get_path = function() {
      return this._path;
    };

    SyncDoc.prototype.get_project_id = function() {
      return this._project_id;
    };

    SyncDoc.prototype.set_snapshot_interval = function(n) {
      this._syncstring_table.set(this._syncstring_table.get_one().set('snapshot_interval', n));
    };

    SyncDoc.prototype._handle_offline = function(data) {
      var j, l, len, len1, now, obj, oldest, ref, results, snapshot_time;
      if (this._closed) {
        return;
      }
      now = misc.server_time();
      oldest = void 0;
      for (j = 0, len = data.length; j < len; j++) {
        obj = data[j];
        if (obj.sent) {
          continue;
        }
        if (now - obj.time >= 1000 * OFFLINE_THRESH_S) {
          obj.sent = now;
          this._patches_table.set(obj);
          if ((oldest == null) || obj.time < oldest) {
            oldest = obj.time;
          }
        }
      }
      if (oldest) {
        ref = this._patch_list.snapshot_times();
        results = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          snapshot_time = ref[l];
          if (snapshot_time - oldest >= 0) {
            results.push(this.snapshot(snapshot_time, true));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };

    SyncDoc.prototype._handle_syncstring_update = function() {
      var client_id, obj, ref, ref1, x;
      if (this._syncstring_table == null) {
        return;
      }
      x = (ref = this._syncstring_table.get_one()) != null ? ref.toJS() : void 0;
      client_id = this._client.client_id();
      if ((x == null) || (x.users == null)) {
        this._last_snapshot = void 0;
        this._snapshot_interval = schema.SCHEMA.syncstrings.user_query.get.fields.snapshot_interval;
        this._user_id = 0;
        this._users = [client_id];
        obj = {
          string_id: this._string_id,
          project_id: this._project_id,
          path: this._path,
          last_snapshot: this._last_snapshot,
          users: this._users,
          deleted: this._deleted,
          doctype: misc.to_json(this._doctype)
        };
        this._syncstring_table.set(obj);
        return this.emit('metadata-change');
      } else {
        this._last_snapshot = x.last_snapshot;
        this._snapshot_interval = x.snapshot_interval;
        this._users = x.users;
        this._project_id = x.project_id;
        this._path = x.path;
        if ((this._deleted != null) && x.deleted && !this._deleted) {
          this.emit("deleted");
        }
        this._deleted = x.deleted;
        this._user_id = (ref1 = this._users) != null ? ref1.indexOf(client_id) : void 0;
        if (this._user_id === -1) {
          this._user_id = this._users.length;
          this._users.push(client_id);
          this._syncstring_table.set({
            string_id: this._string_id,
            project_id: this._project_id,
            path: this._path,
            users: this._users
          });
        }
        if (!this._client.is_project()) {
          this.emit('metadata-change');
          return;
        }
        return async.series([
          (function(_this) {
            return function(cb) {
              if (_this._patch_list != null) {
                return cb();
              } else {
                return _this.once('connected', function() {
                  return cb();
                });
              }
            };
          })(this), (function(_this) {
            return function(cb) {
              if ((x.project_id != null) && _this._watch_path !== x.path) {
                return _this._update_watch_path(x.path, cb);
              } else {
                return cb();
              }
            };
          })(this), (function(_this) {
            return function(cb) {
              var ref2;
              if (((ref2 = x.save) != null ? ref2.state : void 0) === 'requested') {
                return _this._save_to_disk(cb);
              } else {
                return cb();
              }
            };
          })(this)
        ], (function(_this) {
          return function(err) {
            if (err) {
              _this.dbg("_handle_syncstring_update")("POSSIBLY UNHANDLED ERROR -- " + err);
            }
            return _this.emit('metadata-change');
          };
        })(this));
      }
    };

    SyncDoc.prototype._update_watch_path = function(path, cb) {
      var dbg;
      dbg = this._client.dbg("_update_watch_path('" + path + "')");
      if (this._file_watcher != null) {
        dbg("close");
        this._file_watcher.close();
        delete this._file_watcher;
        delete this._watch_path;
      }
      if (path == null) {
        dbg("not opening another watcher");
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (this._watch_path != null) {
        dbg("watch_path already defined");
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      dbg("opening watcher");
      this._watch_path = path;
      return async.series([
        (function(_this) {
          return function(cb) {
            return _this._client.path_exists({
              path: path,
              cb: function(err, exists) {
                var data, ref;
                if (err) {
                  return cb(err);
                } else if (!exists) {
                  dbg("write '" + path + "' to disk from syncstring in-memory database version");
                  data = (ref = _this.to_str()) != null ? ref : '';
                  return _this._client.write_file({
                    path: path,
                    data: data,
                    cb: function(err) {
                      dbg("wrote '" + path + "' to disk -- now calling cb");
                      return cb(err);
                    }
                  });
                } else {
                  return cb();
                }
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            dbg("now requesting to watch file");
            _this._file_watcher = _this._client.watch_file({
              path: path
            });
            _this._file_watcher.on('change', function() {
              dbg("event change");
              if (_this._closed) {
                _this._file_watcher.close();
                return;
              }
              if (_this._save_to_disk_just_happened) {
                dbg("@_save_to_disk_just_happened");
                _this._save_to_disk_just_happened = false;
              } else {
                dbg("_load_from_disk");
                _this._load_from_disk();
              }
            });
            _this._file_watcher.on('delete', function() {
              dbg("event delete");
              if (_this._closed) {
                _this._file_watcher.close();
                return;
              }
              dbg("delete: setting deleted=true and closing");
              _this.from_str('');
              _this.save(function() {
                _this._syncstring_table.set(_this._syncstring_table.get_one().set('deleted', true));
                return _this._syncstring_table.save(function() {
                  return _this.close();
                });
              });
            });
            return cb();
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          return typeof cb === "function" ? cb(err) : void 0;
        };
      })(this));
    };

    SyncDoc.prototype._load_from_disk = function(cb) {
      var dbg, exists, path;
      path = this.get_path();
      dbg = this._client.dbg("syncstring._load_from_disk('" + path + "')");
      dbg();
      if (this._load_from_disk_lock) {
        if (typeof cb === "function") {
          cb('lock');
        }
        return;
      }
      this._load_from_disk_lock = true;
      exists = void 0;
      return async.series([
        (function(_this) {
          return function(cb) {
            return _this._client.path_exists({
              path: path,
              cb: function(err, x) {
                exists = x;
                if (!exists) {
                  dbg("file no longer exists");
                  _this.from_str('');
                }
                return cb(err);
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            if (exists) {
              return _this._update_if_file_is_read_only(cb);
            } else {
              return cb();
            }
          };
        })(this), (function(_this) {
          return function(cb) {
            if (!exists) {
              cb();
              return;
            }
            return _this._client.path_read({
              path: path,
              maxsize_MB: MAX_FILE_SIZE_MB,
              cb: function(err, data) {
                if (err) {
                  dbg("failed -- " + err);
                  return cb(err);
                } else {
                  dbg("got it -- length=" + (data != null ? data.length : void 0));
                  _this.from_str(data);
                  _this._set_save({
                    state: 'done',
                    error: false,
                    hash: misc.hash_string(data)
                  });
                  return cb();
                }
              }
            });
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this._save(cb);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          _this._load_from_disk_lock = false;
          return typeof cb === "function" ? cb(err) : void 0;
        };
      })(this));
    };

    SyncDoc.prototype._set_save = function(x) {
      var ref, ref1;
      if (this._closed) {
        return;
      }
      if ((ref = this._syncstring_table) != null) {
        if (typeof ref.set === "function") {
          ref.set((ref1 = this._syncstring_table.get_one()) != null ? ref1.set('save', immutable.fromJS(x)) : void 0);
        }
      }
    };

    SyncDoc.prototype._set_read_only = function(read_only) {
      var ref, ref1;
      if (this._closed) {
        return;
      }
      if ((ref = this._syncstring_table) != null) {
        if (typeof ref.set === "function") {
          ref.set((ref1 = this._syncstring_table.get_one()) != null ? ref1.set('read_only', read_only) : void 0);
        }
      }
    };

    SyncDoc.prototype.get_read_only = function() {
      var ref, ref1;
      if (this._closed) {
        return;
      }
      return (ref = this._syncstring_table) != null ? (ref1 = ref.get_one()) != null ? ref1.get('read_only') : void 0 : void 0;
    };

    SyncDoc.prototype.wait_until_read_only_known = function(cb) {
      if (this._syncstring_table == null) {
        cb("@_syncstring_table must be defined");
        return;
      }
      return this._syncstring_table.wait({
        until: (function(_this) {
          return function(t) {
            var ref;
            return ((ref = t.get_one()) != null ? ref.get('read_only') : void 0) != null;
          };
        })(this),
        cb: cb
      });
    };

    SyncDoc.prototype.has_unsaved_changes = function() {
      return this.hash_of_live_version() !== this.hash_of_saved_version();
    };

    SyncDoc.prototype.hash_of_saved_version = function() {
      var ref, ref1;
      return (ref = this._syncstring_table) != null ? (ref1 = ref.get_one()) != null ? ref1.getIn(['save', 'hash']) : void 0 : void 0;
    };

    SyncDoc.prototype.hash_of_live_version = function() {
      var ref, s;
      s = (ref = this._doc) != null ? typeof ref.to_str === "function" ? ref.to_str() : void 0 : void 0;
      if (s != null) {
        return misc.hash_string(s);
      }
    };

    SyncDoc.prototype.save_to_disk = function(cb) {
      var f;
      if (!this.has_unsaved_changes()) {
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      this._save_to_disk();
      if (this._syncstring_table == null) {
        cb("@_syncstring_table must be defined");
        return;
      }
      if (cb != null) {
        f = (function(_this) {
          return function(cb) {
            if (_this._syncstring_table == null) {
              cb(true);
              return;
            }
            return _this._syncstring_table.wait({
              until: function(table) {
                var ref;
                return ((ref = table.get_one()) != null ? ref.getIn(['save', 'state']) : void 0) === 'done';
              },
              timeout: 10,
              cb: function(err) {
                if (err) {

                } else {
                  err = _this._syncstring_table.get_one().getIn(['save', 'error']);
                }
                if (err) {
                  _this.touch(0);
                }
                return cb(err);
              }
            });
          };
        })(this);
        return misc.retry_until_success({
          f: f,
          max_tries: 5,
          cb: cb
        });
      }
    };

    SyncDoc.prototype._save_to_disk = function(cb) {
      if (this._client.is_user()) {
        this.__save_to_disk_user();
        if (typeof cb === "function") {
          cb();
        }
        return;
      }
      if (this._saving_to_disk_cbs != null) {
        this._saving_to_disk_cbs.push(cb);
        return;
      } else {
        this._saving_to_disk_cbs = [cb];
      }
      return this.__do_save_to_disk_project((function(_this) {
        return function(err) {
          var j, len, v;
          v = _this._saving_to_disk_cbs;
          delete _this._saving_to_disk_cbs;
          for (j = 0, len = v.length; j < len; j++) {
            cb = v[j];
            if (typeof cb === "function") {
              cb(err);
            }
          }
          return _this.emit("save_to_disk_project", err);
        };
      })(this));
    };

    SyncDoc.prototype.__save_to_disk_user = function() {
      if (this._closed) {
        return;
      }
      if (!this.has_unsaved_changes()) {
        return;
      }
      this.touch();
      return this._set_save({
        state: 'requested',
        error: false
      });
    };

    SyncDoc.prototype.__do_save_to_disk_project = function(cb) {
      var data, hash, path;
      data = this.to_str();
      hash = misc.hash_string(data);
      if (hash === this.hash_of_saved_version()) {
        this._set_save({
          state: 'done',
          error: false,
          hash: hash
        });
        cb();
        return;
      }
      path = this.get_path();
      if (path == null) {
        cb("not yet initialized");
        return;
      }
      if (!path) {
        this._set_save({
          state: 'done',
          error: 'cannot save without path'
        });
        cb("cannot save without path");
        return;
      }
      this._save_to_disk_just_happened = true;
      return this._client.write_file({
        path: path,
        data: data,
        cb: (function(_this) {
          return function(err) {
            if (err) {
              _this._set_save({
                state: 'done',
                error: err
              });
            } else {
              _this._set_save({
                state: 'done',
                error: false,
                hash: misc.hash_string(data)
              });
            }
            return cb(err);
          };
        })(this)
      });
    };


    /*
     * When the underlying synctable that defines the state of the document changes
     * due to new remote patches, this function is called.
     * It handles update of the remote version, updating our live version as a result.
     */

    SyncDoc.prototype._handle_patch_update = function(changed_keys) {
      var changed, key, new_remote, ref;
      if (this._closed) {
        return;
      }
      if (changed_keys == null) {
        return;
      }
      if (this._patch_list == null) {
        return;
      }
      this._patch_list.add((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = changed_keys.length; j < len; j++) {
          key = changed_keys[j];
          results.push(this._process_patch(this._patches_table.get(key)));
        }
        return results;
      }).call(this));
      this._save();
      new_remote = this._patch_list.value();
      try {
        changed = !((ref = this._doc) != null ? ref.is_equal(new_remote) : void 0);
      } catch (error1) {
        changed = true;
      }
      if (changed) {
        this._last = this._doc = new_remote;
        return this.emit('change');
      }
    };

    SyncDoc.prototype.has_uncommitted_changes = function() {
      var ref;
      return (ref = this._patches_table) != null ? ref.has_uncommitted_changes() : void 0;
    };

    return SyncDoc;

  })(EventEmitter);

  exports.SyncDoc = SyncDoc;

  StringDocument = (function() {
    function StringDocument(_value) {
      this._value = _value != null ? _value : '';
      this.make_patch = bind(this.make_patch, this);
      this.apply_patch = bind(this.apply_patch, this);
      this.is_equal = bind(this.is_equal, this);
      this.to_str = bind(this.to_str, this);
    }

    StringDocument.prototype.to_str = function() {
      return this._value;
    };

    StringDocument.prototype.is_equal = function(other) {
      return this._value === (other != null ? other._value : void 0);
    };

    StringDocument.prototype.apply_patch = function(patch) {
      return new StringDocument(apply_patch(patch, this._value)[0]);
    };

    StringDocument.prototype.make_patch = function(other) {
      if ((this._value == null) || ((other != null ? other._value : void 0) == null)) {
        return;
      }
      return make_patch(this._value, other._value);
    };

    return StringDocument;

  })();

  exports._testStringDocument = StringDocument;

  exports.SyncString = (function(superClass) {
    extend(SyncString, superClass);

    function SyncString(opts) {
      var from_str;
      opts = defaults(opts, {
        id: void 0,
        client: required,
        project_id: void 0,
        path: void 0,
        save_interval: void 0,
        patch_interval: void 0,
        file_use_interval: void 0,
        cursors: false
      });
      from_str = function(str) {
        return new StringDocument(str);
      };
      SyncString.__super__.constructor.call(this, {
        string_id: opts.id,
        client: opts.client,
        project_id: opts.project_id,
        path: opts.path,
        save_interval: opts.save_interval,
        patch_interval: opts.patch_interval,
        file_use_interval: opts.file_use_interval,
        cursors: opts.cursors,
        from_str: from_str,
        doctype: {
          type: 'string'
        }
      });
    }

    return SyncString;

  })(SyncDoc);


  /*
  Used for testing
   */

  synctable = require('./synctable');

  exports.TestBrowserClient1 = (function(superClass) {
    extend(TestBrowserClient1, superClass);

    function TestBrowserClient1(_client_id, _debounce_interval) {
      this._client_id = _client_id;
      this._debounce_interval = _debounce_interval != null ? _debounce_interval : 0;
      this.client_id = bind(this.client_id, this);
      this.sync_string = bind(this.sync_string, this);
      this.sync_table = bind(this.sync_table, this);
      this.server_time = bind(this.server_time, this);
      this.mark_file = bind(this.mark_file, this);
      this.is_user = bind(this.is_user, this);
    }

    TestBrowserClient1.prototype.is_user = function() {
      return true;
    };

    TestBrowserClient1.prototype.mark_file = function() {};

    TestBrowserClient1.prototype.server_time = function() {
      return new Date();
    };

    TestBrowserClient1.prototype.sync_table = function(query, options, debounce_interval) {
      if (debounce_interval == null) {
        debounce_interval = 0;
      }
      debounce_interval = this._debounce_interval;
      return synctable.sync_table(query, options, this, debounce_interval, 0, false);
    };

    TestBrowserClient1.prototype.sync_string = function(opts) {
      opts = defaults(opts, {
        id: void 0,
        project_id: void 0,
        path: void 0,
        file_use_interval: 'default',
        cursors: false,
        save_interval: 0
      });
      opts.client = this;
      return new exports.SyncString(opts);
    };

    TestBrowserClient1.prototype.client_id = function() {
      return this._client_id;
    };

    return TestBrowserClient1;

  })(synctable.TestBrowserClient1);

}).call(this);
